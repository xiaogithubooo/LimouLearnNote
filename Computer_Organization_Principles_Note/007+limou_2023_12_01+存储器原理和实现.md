# 1.存储器层次

<img src="./assets/image-20231201153327589.png" alt="image-20231201153327589" style="zoom:50%;" />

一般来说越高层越贵，空间存储量越小。

1.   `cache` 和寄存器等高速存储器解决了与 `CPU` 速度不匹配的问题
2.   `cache` 以上的部分是由硬件自动完成的，而主存和辅存部分主要是硬件和操作系统控制的，实现了虚拟存储系统，解决内存容量不够的问题

# 2.存储器分类

## 2.1.根据存储介质来分类

1.   半导体存储器：主存、`cache`
2.   磁表面存储器：磁带、磁盘
3.   光存储器：光盘

## 2.2.根据存储方式来分类

1.   随机存取存储器：读写任何一个存储单元所需时间是一样的
2.   顺序存取存储器：读取一个存储单元所需时间取决于存储单元的物理位置
3.   直接存取存储器：这种存储器具有上述两种存储器的特征，最典型的就是磁盘，先选择数据存储的某一磁盘区域，然后使用磁头顺序查找一个磁盘上的数据
4.   相联存取存储器：按照内容访问的存储器，可以快速内容检索到存储位置进行读写，“快表”就是典型例子 

>   补充：另外读写时间和存储地址有关的存储器也可以归为串行访问存储器

## 2.3.根据信息更改来分类

1.   读写存储器：可读可写，磁盘等
2.   只读存储器：只可读取，典型的就是写入 `BIOS` 的 `ROM` 存储器（现在也有的可写，但是很麻烦）

## 2.4.根据信息保存来分类

1.   易失性存储器：主存、`cahce` 等
2.   非易失性存储器：磁盘、光盘等

>   补充：信息读出后，原存储信息被破坏，就叫”破坏性读出“（典型的就是 `DRAM` 芯片）。信息读出后，原存储信息不被破坏，就叫”非破坏性读出“。

# 3.存储器指标

## 3.1.存储容量

$存储容量 = 存储字的数量 × 存储字的字长$

>   补充：存储字的数量通常用一个纯量单位来表示，它表示存储器中可以保存的字（数据）的个数。这个单位可以是简单的数字，也可以根据具体情况使用诸如 "个"、"条"、"项" 等其他合适的单位。例如：一个存储器中可以保存 `10000` 个数据字，这里的 "个" 就是表示存储字数量的单位。
>
>   在实际应用中，存储字数量还经常以更大的计量单位来表示，例如千（`K`）、兆（`M`）、吉（`G`）、太（`T`）等。这些单位可以帮助我们更方便地描述存储器的容量规模，比如 "`1K` 个"、"`1M` 个"、"`1G` 个" 等。

## 3.2.单位成本

$每位价格 = \frac{总成本}{总容量}$

## 3.3.存储速度

$数据传输率/主存带宽 = \frac{存储字的资产}{存储周期}$

>   补充：存储周期/存取周期还可以被细分为存取时间和恢复时间（恢复稳定的电压状态）。
>
>   <img src="./assets/image-20231205171925736.png" alt="image-20231205171925736" style="zoom:50%;" />

# 4.存储器元件

## 4.1.RAM 芯片

`RAM` 芯片分为 `DRAM` 和 `SRAM` 两种，分别可以做出内存和高速缓存两种硬件，是两种硬件各自的核心组成芯片。

### 4.1.1.DRAM

>   提醒：我们提到的内存和辅存，实际上在逻辑上是统一编址的，都可以被程序所使用，只不过在程序（尤其是进程）看来，自己使用的是内存地址（实际也就是虚拟地址）。
>
>   因此这里我们讨论的是内存中 `DRAM` 芯片，不过不同场景下，主存究竟是指内存还是内存加辅存，需要依上下文决定。

#### 4.1.1.1.单行存储体

我们之前有提及，主存的大致结构就是由 `MAR`、`MDR` 和存储体构成，由时序控制逻辑来调配存储和寻址工作。而存储体由多个存储单元构成，而存储单元由多个存储元/存储元件构成。

<img src="./assets/image-20231205173424290.png" alt="image-20231205173424290" style="zoom:50%;" />

假定我们通电半导体，则半导体导通。然后输入电压，电容进行充电，则根据电容是否保存电荷来表示 `1/0`。而如果不输入电压，但是让 `MOS` 管正常工作，则半导体导通，可以导出电容的电量，得到存储的数据是 `1/0`。

这就完成了对一个比特位的读写过程，多个电元经过科学合理的连接，通过一条数据线统一管理进行读写。这条数据线就是一个存储单元（一个存储字），若干个存储单元就构成了一个存储体，或者叫做“存储矩阵”。

`CPU` 通过地址总线，传输地址给 `MAR`，`MAR` 存储起来后，使用译码器将 `n` 位的地址数据翻译为对应的字选线，设置字选线的高电平信号。字选线选择好后，`MDR` 就会通过数据总线（位线）取走对应的一个存储字长的数据。

>   补充：第一个存储单元到第二个存储单元只需要进行移位操作就可以相互推导两者的首地址。

![image-20231206232218773](./assets/image-20231206232218773.png)

地址数据送给 `MAR` 后有可能出现电信号不稳定的情况，因此就需要控制电路控制 `MAR`、译码器、`MDR` 协调工作，只有 `MAR` 稳定后才可以将电信号交给译码器，同理译码器的输出也是一样的。

>   补充：实际上 `MAR` 和 `MDR` 在现代计算机中，这两者通常直接集成到了 `CPU` 内部，而不再主存内，通常表现为 `CPU` 内的一个普通寄存器（暂存输入、输出数据）

另外还有几条线路需要补充，控制电路内的存储芯片对外还接通了：

-   片选线（芯片选择信号$\overline{CS}$和芯片使能信号$\overline{CE}$）：上划线代表只有在低电平时才有效，可以通过$\overline{CS}$选择对应内存条上的某一块存储体（因为一条内存有多个存储体集合而成），$\overline{CE}$信号也用于控制芯片的使能和失能，$\overline{CE}$信号通常只有一个，$\overline{CS}$信号通常有多个
-   读写控制线（$\overline{OE}$读控制线和$\overline{WE}$写控制线）：低电平表示正在读写操作（还有一种设计方法是两者结合，只留$\overline{WE}$一根线，低电平写，高电平读，这会导致对外暴露金属引脚不一样）

>   样例：根据不同的寻址方式，可以得出不同的结论
>
>   对于字长 `4Byte`，总容量为 `1KB = 1024Byte` 的内存条来说，一共有 `256` 行存储单元行。
>
>   -   按字节寻址，每次都只寻找一个字节的数据，则有 `1024` 个存储单元，需要对每个字节的存储单元编址，就需要 `10` 根地址线
>   -   按单字寻找，每次都只寻找一个字的数据，则有 `256` 个单元
>   -   按半字寻址，每次都寻找一半字的数据，则有 `512` 个单元
>   -   按双字寻址，每次都寻找双字的数据，则有 `128` 个单元

而上述提及的一整个电器器件就是 `DRAM` 芯片（利用栅极电容元件存储信息）。

#### 4.1.1.2.矩阵存储体

如果真的按照 $2^n$ 个存储单元一行一行来排布线路，则将会排布相当多的线路，因此最好将多个存储单元列为一行，多行形成矩阵，将单个的译码器改为一个行地址译码器和列地址译码器，每一个译码器只需要处理一般的地址位信息，两者结合就可以找到对应的存储单元来进行读写。

![image-20231207113432013](./assets/image-20231207113432013.png)

而电容的物理性质，决定了内存需要不断被刷新的工作机制。因此就可以根据行地址译码器，选中一行的存储单元们，进行一次一行的刷新，而刷新一整行实际上就是做了一次读操作，也就说：刷新需要占用一个读周期的时间。

而根据刷新时机的不同，`DRAM` 有三种主要的刷新策略，假设读写周期为 `t`：

1.   分散刷新：读写完就刷新，`t` 正常读写，`t` 用于刷新
2.   集中刷新：集中安排刷新，相当长的时间用于正常读取，在数据消失前在小部分时间内统一刷新（该时间内为四区，无法访问内存空间进行读写）
3.   异步刷新：将死区时间打散，分开刷新，每一段长时间的读取后就用一小段时间进行刷新

>   补充：下面使用刷新周期为 `2ms`，存取周期为 `0.5us`，矩阵大小为 `128*128` 的存储体为例，分别制定三种刷新方案。
>
>   ![image-20231207120018190](./assets/image-20231207120018190.png)

### 4.1.2.SRAM

告诉缓存的电器器件中，电器元件为双态触发器（对标主存中的栅极电容）内部由 `6` 个 `MOS` 管构成，该元件对 `1/0` 的定义和电容不一样，定义“`A` 高 `B` 高为 `1`，`A` 低 `B` 高为 `0`”。

![image-20231207122533660](./assets/image-20231207122533660.png)

由于使用的 `MOS` 管比较多，因此制作成本偏高，对应的功耗更大。并且触发器是保持稳定的，是非破坏性读出，无需重写（这就意味着无需刷新，读写速度更快，只要有电就行）。

由于电容里的电荷会随时间消散，因此就需要不断写入数据刷新电容，也就是刷新主存，而双稳态就不会有这种问题。

而且一般不会同时送行列地址，而是直接传输地址，因为 `cache` 的容量较小，同时送就可以了。

### 4.1.3.芯片对比

| 类型特点                       | DRAM                                 | SRAM         |
| ------------------------------ | ------------------------------------ | ------------ |
| **存储信息**                   | 电容                                 | 触发器       |
| **破坏性读出**                 | √                                    | ×            |
| **读出后重新读取数据（再生）** | √                                    | ×            |
| **刷新数据（刷新）**           | √（分散、集中、异步）                | ×            |
| **断电易失**                   | √                                    | √            |
| **运行速度**                   | 低                                   | 高           |
| **集成度**                     | 低                                   | 高           |
| **发热量**                     | 低                                   | 高           |
| **存储成本**                   | 低                                   | 高           |
| **输送行列地址**               | 分两次（复用）                       | 同时         |
| **连续读写**                   | 恢复时间较长，有可能是存储时间的几倍 | 恢复时间较短 |

### 4.1.4.提速手段

#### 4.1.4.1.双口 RAM

可以优化多核 `CPU` 访问同一根内存条的速度。

![image-20231207141212758](./assets/image-20231207141212758.png)

#### 4.1.4.2.多模块存储器

##### 4.1.4.2.1.单体多字存储器

![image-20231207143420227](./assets/image-20231207143420227.png)

##### 4.1.4.2.2.多体并存存储器

![image-20231207142004945](./assets/image-20231207142004945.png)

![image-20231207142332091](./assets/image-20231207142332091.png)

![image-20231207142557605](./assets/image-20231207142557605.png)

![image-20231207142621233](./assets/image-20231207142621233.png)

![image-20231207143102453](./assets/image-20231207143102453.png)

#### 4.1.4.3.双通道内存

待补充...

## 4.2.ROM 芯片

一般主板上的 `BIOS` 芯片就是一种 `ROM` 芯片，内部存储了“自举装入程序”，负责引导装入操作系统（也就是所谓“开机”），这些 `ROM` 芯片很适合做永久存储的存储器物。

### 4.2.1.MROM

掩模式只读存储器 `MROM`，厂家根据用户需求，在芯片生产过程中直接写死数据，之后任何人都无法重写，只能进行读取，可靠性虽然比较高，但是灵活性差、生产周期长、只能批量定制。

### 4.2.2.PROM

可编程只读存储器 `PROM`，用户可以用专门的 `PROM` 写入器写入信息，写一次后就不可更改。

### 4.2.3.EPROM

卡擦除可编程只读存储器 `EPROM`，允许用户写入信息，并且用某种方式擦除数据，可以进行多次重写。

-   `UVEPROM`：用紫外线照射擦除
-   `EEPROM`：用电擦除方式，擦除特定的字

### 4.2.4.Flash

闪速存储器 `Flash Memory`，典型的就是 `U` 盘和 `SD` 卡，由 `EEPROM` 发展过来，断电也可以保存信息，可以进行多次的快速擦除和重写（每个存储元只需要单个 `MOS` 管，位密度比 `RAM` 高，因此存储的位数据就更多，对应存储容量就越大）。并且需先擦除再写入，因此写的速度要比读的速度慢。

### 4.2.5.SSD

固态硬盘 `SSD`，有存储单元和控制单元构成，和闪存的最大区别在于控制单元不一样，但是存储介质的原理类似，`SSD` 速度快、功耗低、价格便宜，在很多的个人电脑上都使用了 `SSD` 固态硬盘替代了传统的机械硬盘。    

# 5.存储器硬件

## 5.1.内存

这里主要是详细提及主存和 `CPU` 的连接。

### 5.1.1.位拓展

![image-20231208150536123](./assets/image-20231208150536123.png)

![image-20231208150641004](./assets/image-20231208150641004.png)

上述将 `CPU` 的数据总线全部利用上了。

### 5.1.2.字扩展

#### 5.1.2.1.线选法

![image-20231208153018271](./assets/image-20231208153018271.png)

上述将 `CPU` 的地址总线全部利用上了，但是有缺陷。

#### 5.1.2.2.译码片选器

![image-20231208154004241](./assets/image-20231208154004241.png)

可以利用译码器来优化。

![image-20231208154319616](./assets/image-20231208154319616.png)

这样就可以让地址连续起来，并且全部利用起来。

![image-20231208155012303](./assets/image-20231208155012303.png)

但是这种设计导致一个明明只有 `8K` 个 `8bit` 的存储体，却有 `8k*2` 个合法地址，这很明显是比较离谱的（因此实际应用很少这么使用）。

![image-20231208155642024](./assets/image-20231208155642024.png)

## 5.2.磁盘

### 5.2.1.磁盘原理

![image-20231212230905275](./assets/image-20231212230905275.png)

### 5.2.2.磁盘组成

#### 5.2.2.1.盘片

#### 5.2.2.2.驱动器

#### 5.2.2.3.控制器

![image-20231212231254364](./assets/image-20231212231254364.png)

![image-20231212231759106](./assets/image-20231212231759106.png)

![image-20231212231917251](./assets/image-20231212231917251.png)

![image-20231212232108083](./assets/image-20231212232108083.png)



### 5.2.3.磁盘指标

![image-20231212232708428](./assets/image-20231212232708428.png)

![image-20231212233029314](./assets/image-20231212233029314.png)

旋转时间接近于转一半的时间，传输的过程是指划过磁道的时间，有的时候还可以加上磁盘控制器延迟时间（磁盘处理指令的时间）。

![image-20231212233548127](./assets/image-20231212233548127.png)

### 5.2.4.磁盘寻址

![image-20231212233953701](./assets/image-20231212233953701.png)

### 5.2.5.磁盘读写

![image-20231212234150979](./assets/image-20231212234150979.png)

### 5.2.6.磁盘阵列

![image-20231212234504382](./assets/image-20231212234504382.png)

![image-20231212234537006](./assets/image-20231212234537006.png)

![image-20231212234823187](./assets/image-20231212234823187.png)

![image-20231212235111422](./assets/image-20231212235111422.png)

![image-20231212235053993](./assets/image-20231212235053993.png)

![image-20231212235134569](./assets/image-20231212235134569.png)

## 5.3.SSD

### 5.3.1.SSD 原理

![image-20231215131220871](./assets/image-20231215131220871.png)

### 5.3.2.SSD 组成

![image-20231215131249302](./assets/image-20231215131249302.png)

![image-20231215131421577](./assets/image-20231215131421577.png)

系统每次读写的单位都是一个页，逻辑块号：

-   如果对应磁盘就是磁盘的块/扇区
-   如果对应 `SSD` 就是 `SSD` 的页，而不是块（这个块相当于磁盘的磁道）

### 5.3.3.SSD 读写特性

![image-20231215131936900](./assets/image-20231215131936900.png)

![image-20231215132247550](./assets/image-20231215132247550.png)

### 5.3.4.SSD 优势和劣势

![image-20231215132348238](./assets/image-20231215132348238.png)

![image-20231215132421832](./assets/image-20231215132421832.png)

## 5.4.Cache

### 5.4.1.Cache 原理

![image-20231215133733115](./assets/image-20231215133733115.png)

![image-20231215134105876](./assets/image-20231215134105876.png)

基于局部性原理，我们可以将数据周围的数据一起送给 `Cache`，这样 `CPU` 就只需要访问 `Cache` 即可。

![image-20231215134318726](./assets/image-20231215134318726.png)

因此很多代码访问类似二维数组的结构时，不会按照列来访问，而是行来访问具有一定的道理。

那怎么界定“周围”的数据提高命中率呢？

![image-20231215135230065](./assets/image-20231215135230065.png)

![image-20231215135257474](./assets/image-20231215135257474.png)

![image-20231215135517129](./assets/image-20231215135517129.png)

![image-20231215135625421](./assets/image-20231215135625421.png)

### 5.4.2.Cache 指标

![image-20231215134751593](./assets/image-20231215134751593.png)

![image-20231215134927672](./assets/image-20231215134927672.png)

![image-20231215135132647](./assets/image-20231215135132647.png)

### 5.4.3.Cache 映射

我们知道 `CPU` 有可能处理 `Cahae` 地址内的数据，也有可能处理内存地址内的数据，因此有必要区分两者的地址。

![image-20231215144639948](./assets/image-20231215144639948.png)

#### 5.4.3.1.全相连映射

主存块会放到 `Cache` 块的任意位置。

![image-20231215145329208](./assets/image-20231215145329208.png)

![image-20231215145417484](./assets/image-20231215145417484.png)

那么查询内存地址之前，先比对地址，查看 `cache` 是否有数据可以命中。

![image-20231215145534626](./assets/image-20231215145534626.png)

#### 5.4.3.2.直接映射

每个主存块只能放到一个特定的位置，$Cache块号 = 主存块号 \% Cache总快数$。

![image-20231215150008514](./assets/image-20231215150008514.png)

![image-20231215150154103](./assets/image-20231215150154103.png)

#### 5.4.3.3.组相连映射

`Cache` 块分为若干组，每个主存块可以存放到特定分组的任意位置，$组号 = 主存块号 \% 分组数$。

![image-20231215150420770](./assets/image-20231215150420770.png)

![image-20231215150546521](./assets/image-20231215150546521.png)

![image-20231215150751903](./assets/image-20231215150751903.png)

### 5.4.4.Cache 替换

每一次被访问的主存块，一定会被立即调入 `Cache`，但是如果 `Cache` 装满了怎么办？

![image-20231215153213217](./assets/image-20231215153213217.png)

我们以全相联映射来讲解几个常见的替换算法。

#### 5.4.4.1.随机算法

![image-20231215153537055](./assets/image-20231215153537055.png)

#### 5.4.4.2.先进先出算法

![image-20231215155451179](./assets/image-20231215155451179.png)

#### 5.4.4.3.近期最少使用算法

![image-20231215162449304](./assets/image-20231215162449304.png)

上面是我们自己做题的技巧，下面是计算机的处理逻辑。

![image-20231215163011330](./assets/image-20231215163011330.png)

![image-20231215172931728](./assets/image-20231215172931728.png)

![image-20231215173057595](./assets/image-20231215173057595.png)

![image-20231215173114343](./assets/image-20231215173114343.png)

![image-20231215173140620](./assets/image-20231215173140620.png)

#### 5.4.4.4.最不经常使用算法

![image-20231215174806377](./assets/image-20231215174806377.png)

### 5.4.5.Cache 写入

因为 `Cache` 保存的只是内存中的副本，如果只是修改 `Cache` 的话，就无法改动内存中的数据，导致 `CPU` 计算完后的数据无法写回内存，代码（或者说进程）就拿不到这些处理完后的数据，因此有必要设置 `Cache` 的写入算法来解决数据一致性的问题。

#### 5.4.5.1.Cache 写命中

##### 5.4.5.1.1.写回法

![image-20231215232428152](./assets/image-20231215232428152.png)

##### 5.4.5.1.2.全写法

![image-20231215232742471](./assets/image-20231215232742471.png)

#### 5.4.5.2.Cache 写不命中

##### 5.4.5.2.1.写分配法

![image-20231215232909370](./assets/image-20231215232909370.png)

##### 5.4.5.2.1.非写分配法

![image-20231215232938153](./assets/image-20231215232938153.png)

![image-20231215233226313](./assets/image-20231215233226313.png)

# 6.存储器存储

## 6.1.页式存储器

进程不可能将全部的的数据直接加载到内存中（很容易空间不够），并且加载进来的数据也不是马上会用到，这样会导致利用效率不高。

![image-20231216000457809](./assets/image-20231216000457809.png)

![image-20231216182935843](./assets/image-20231216182935843.png)

![image-20231216183155371](./assets/image-20231216183155371.png)

![image-20231216183954160](./assets/image-20231216183954160.png)

![image-20231216184222711](./assets/image-20231216184222711.png)

>   注意 `1`：在 `Linux` 那边的页表详细解释就是这里。
>
>   注意 `2`：这里的快表不要和 `cache` 的替换算法混淆，两者还是有很大区别的，前者是页表项的副本（在地址变换中加快变换速度），后者是主存块的副本（在得到物理地址后加速访问速度）。

## 6.2.虚拟存储器

### 6.2.1.页式存储器

![image-20231216185614199](./assets/image-20231216185614199.png)

![image-20231216185802484](./assets/image-20231216185802484.png)

![image-20231216190347953](./assets/image-20231216190347953.png)

访问位是为了页面替换，将主存内的数据替换出去，避免主存被占满。脏位和`Cache`的脏位类似，对主存快的内容进行修改后，脏位变为`1`，当这块空间被替换时就会被写回辅存，避免信息不一致问题。

页表内对应的有效位为 `0` 时应该时会引发缺页中断，以后再来探究。

### 6.2.2.段式存储器

![image-20231216193149185](./assets/image-20231216193149185.png)

### 6.3.段页式虚拟存储器

![image-20231216193416108](./assets/image-20231216193416108.png)
