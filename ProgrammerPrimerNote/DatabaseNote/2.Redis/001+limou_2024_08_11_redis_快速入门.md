# 1.Redis 官方安装

[依照 Redis 官方文档即可下载 Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/)。

```shell
# 安装 Redis
$ sudo apt-get install lsb-release curl gpg # 以下指令可能过时, 推荐您看官方文档
$ curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg
$ sudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg
$ echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list
$ sudo apt-get update
$ sudo apt-get install redis

```

`Redis` 也有经典的 `CS` 模式，因此需要启动服务。

```shell
# 启动 Redis
$ sudo systemctl enable redis-server
$ sudo systemctl start redis-server

```

测试是否安装成功。

```shell
# 测试 Redis
$ redis-cli
127.0.0.1:6379> ping
PONG

```

>   [!IMPORTANT]
>
>   补充：`6379` 是 `Redis` 默认的服务端程序运行端口号。

接下来，可以 [根据 Redis 官方的快速学习手册进行学习](https://redis.io/docs/latest/get-started/)，不过东西有点多，我们不如先来简单入门一下当然，如果觉得文档太难，可以看看 [别人搬运的尚硅谷 Redis 教程(非正版...)](https://www.bilibili.com/video/BV1UnY5ehE4b?vd_source=c92c89dbfcf9cc30c48086469621f35b&spm_id_from=333.788.videopod.episodes)。

# 2.Redis 登录退出

登录方式和 `MySQL` 是一样的，可以在命令行使用客户端登录的方式，也可以只执行单条的命令，我们可以简单试试启动 `Redis` 的客户端。

```shell
# Redis 的登录和退出
# 直接使用客户端登录并且使用
$ redis-cli -h 0.0.0.0 -p 6379

0.0.0.0:6379> ping
PONG # WebSocket 协议中, PING 和 PONG 是一种心跳机制, 服务器或客户端可以发送 PING, 而接收方会响应 PONG, 以确保连接存活

0.0.0.0:6379> set key hello
OK

0.0.0.0:6379> get key
"hello"

0.0.0.0:6379> exit # 退出 Redis

# 在命令行中只执行一次 Redis 的指令
$ redis-cli -h 0.0.0.0 -p 6379 ping
PONG

```

>   [!WARNING]
>
>   注意：`Redis` 其实在实际开发中是不会暴露给外界访问的，我们这里只不过是为了方便把配置文件改为 `0.0.0.0`，如果您只在本机操作 `redis` 则默认使用的是 `127.0.0.1` 地址，并且默认 `6379` 端口，此时可以直接省略 `-h` 和 `-p` 直接登录。

# 3.Redis 基本指令

我们先再来学几个指令尝尝鲜，这些指令在后面用到的概率也非常高，另外 `Redis` 的指令也可以无视对大小写。

## 3.1.SET, GET, DEL

`set, get, del` 这三个指令非常简单，就是设置（修改）、获取、删除键值对。

```shell
# 使用 set, get, del
0.0.0.0:6379> set my_key "hello"
OK

0.0.0.0:6379> get my_key
"hello"

0.0.0.0:6379> del my_key
(integer) 1

0.0.0.0:6379> get my_key
(nil)
```

>   [!IMPORTANT]
>
>   补充：实际上还有更加方便可用的变种指令
>
>   -   `setex <key_name> <seconds> <key_value>` 可以直接使用秒作为单位设置 `key` 的过期时间
>   -   `setpx <key_name> <milliseconds> <key_value>` 可以直接使用毫秒作为单位设置 `key` 的过期时间
>   -   `setnx <key_name> <key_value>` 只在 `key` 不存在时才进行设置，即如果 `key` 之前已经存在，不执行设置
>   -   `setxx <key_name> <key_value>` 只在 `key` 存在时才进行设置，即如果 `key` 之前不存在，不执行设置
>   -   `mset <key_name_1> <key_value_1> <key_name_2> <key_value_2> ...` 一次设置多个键值对
>   -   `mget key_name_1 key_name_2` 一次获取多个键值
>   -   另外 `del` 本身就支持删除多个键值对...

## 3.2.KEYS, EXISTS

`keys` 指令可以根据一定的样式，或者匹配模式来查询对应的 `key` 值，查询的复杂度是 $O(n)$，而 `exists` 则可以查询 `key` 存在的个数，时间复杂度是 $O(1)$。

```shell
# 使用 keys, exists
0.0.0.0:6379> mset key_1 "hello" key_2 "limou" # 这个是 set 的升级版, 可以一次设置多个 key-value 对
OK

0.0.0.0:6379> keys * # 查询所有 k-v 值
1) "key_2"
2) "backup1"
3) "backup3"
4) "backup4"
5) "key_1"
6) "backup2"

0.0.0.0:6379> keys key_? # 查询 key_1 key_2 key_y 等 k-v 值
1) "key_2"
2) "key_1"

0.0.0.0:6379> keys k* # 查询 k2ey key_2 kkkkey key_1 等 k-v 值
1) "key_2"
2) "key_1"

0.0.0.0:6379> keys key_[13] # 查询 key_1 key_3 这两个 k-v 值
1) "key_1"

0.0.0.0:6379> keys key_[^1] # 查询除了 key_1 以外的所有 key_2 key_w key_0 等 k-v 值
1) "key_2"

0.0.0.0:6379> keys key_[0-3] # 查询 key_1 key_2 key_3 这三个 k-v 值
1) "key_2"
2) "key_1"

0.0.0.0:6379> exists key_1 # 查找符合 key_1 的个数
(integer) 1

0.0.0.0:6379> exists key_1 key_2 # 查找符合 key_1, key_2 的个数
(integer) 2

```

>   [!CAUTION]
>
>   警告：`keys` 的时间复杂度比较大，一般在实际工程中会直接禁用这个命令，否者一旦 `Redis` 在有大量的指令时，就会出现“卡住”的情况，这和 `Redis` 的架构设计本身是有关系的，后面再说...

## 3.3.EXPIRE, TTL

`expire` 为指定的 `key` 值添加秒级的过期时间，返回 `1` 表示设置成功，返回 `0` 表示设置失败，并且可以对同一个 `key` 值反复使用达到修改过期时间的目的。而 ` TTL` 则可以获取指定 `key` 值的过去时间，单位也是秒级，其返回值为 `任意数字` 表示距离过期时间所剩的秒数，`-1` 表示没有关联过期时间，`-2` 表示 `key` 不存在。

```shell
# 使用 expire, ttl
0.0.0.0:6379> set key 100
OK

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> expire key 5 # 设置 key 的过期时间
(integer) 1

0.0.0.0:6379> get key # 每一秒获取一次
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
(nil)

0.0.0.0:6379> ttl key # 查看已经不存在的 key
(integer) -2

0.0.0.0:6379> set key 100 # 重新设置一个 key 值
OK

0.0.0.0:6379> set other_key 20 # 再设置另外一个 key 值
OK

0.0.0.0:6379> expire key 10 # 为第一个 key 设置过期时间
(integer) 1

0.0.0.0:6379> ttl key # 查看第一个 key 剩余的过期时间
(integer) 7

0.0.0.0:6379> ttl key # 查看第一个 key 剩余的过期时间
(integer) 4

0.0.0.0:6379> ttl other_key # 试图查看另外一个没有设置过期时间的 key 的剩余过期时间
(integer) -1

0.0.0.0:6379> set key 100 # 再次重新设置 key 值
OK

0.0.0.0:6379> get key # 正常获取
"100"

0.0.0.0:6379> expire key 100000 # 设置比较大的过期时间
(integer) 1

0.0.0.0:6379> ttl key # 查看剩余的过期时间
(integer) 99994

0.0.0.0:6379> expire key 10 # 重新设置过期时间
(integer) 1

0.0.0.0:6379> ttl key # 检查现在的过期时间
(integer) 9

```

>   [!IMPORTANT]
>
>   补充：实际上 `expire, ttl` 都有支持毫秒版本的 `pexpire, pttl`，使用方法类似。

## 3.4.TYPE

`type` 也很简单，可以返回 `key` 值的数据类型，返回值有 `none, string, list, set, zset, hash, stream...` 其实就对应后面数据类型。

```shell
# 使用 type
0.0.0.0:6379> set key 100
OK

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> type key
string

```

## 3.5.INCR, INCRBY, DECR, DECRBY, INCRBYFLOAR

`incr` 可以用来给一个字符串类型的实数进行 `+1` 操作，哪怕这个 `key` 值之前不存在，也会从 `0` 开始加起。`incrby` 也是类似，但是加上用户指定的整数值（注意只能是整数），不存在时，该 `key` 也是从 `0` 开始加起。而 `decr` 和 `decrby` 和前面两者类似，只不过是变成减而已。

>   [!IMPORTANT]
>
>   补充：顺口一提上述关于 `...by` 的指令都可以使用负数作为操作数。

对于浮点数来说，只使用一个指令 `incrbyfloat` 就够了，功能也是类似的，加减使用正负实数调控就行。

```shell
# 使用 incr, incrby, decr, decrby, incrbyfloat
# incr
0.0.0.0:6379> exists mykey
(integer) 0

0.0.0.0:6379> incr mykey
(integer) 1

0.0.0.0:6379> exists mykey
(integer) 1

0.0.0.0:6379> get mykey
"1"

0.0.0.0:6379> incr mykey
(integer) 2

0.0.0.0:6379> incr mykey
(integer) 3

0.0.0.0:6379> incr mykey
(integer) 4

0.0.0.0:6379> get mykey
"4"

# incrby
0.0.0.0:6379> incrby mykey 5
(integer) 9

# decr
0.0.0.0:6379> decr mykey
(integer) 8

# decrby
0.0.0.0:6379> decrby mykey 7
(integer) 1

# incrbyfloat
0.0.0.0:6379> incrbyfloat mykey 5.6
"9.6"
0.0.0.0:6379> incrbyfloat mykey -10.33
"-0.73"
```

## 3.6.APPEND, GETRANGE, SETRANGE, STRLEN

还可以对字符串进行操作，这些也比较简单...

```shell
# 使用 append, getrange, setrange, strlen
0.0.0.0:6379> set mykey "hello" # 设置初始字符串值到键 mykey
ok

0.0.0.0:6379> get mykey # 获取键 mykey 的值
"hello"

0.0.0.0:6379> append mykey " world" # 向 mykey 键追加字符串 " world"
(integer) 11

0.0.0.0:6379> get mykey # 获取追加后的 mykey 值
"hello world"

0.0.0.0:6379> getrange mykey 0 4 # 获取 mykey 值中从索引 0 到 4 的子串
"hello"

0.0.0.0:6379> getrange mykey 6 10 # 获取 mykey 值中从索引 6 到 10 的子串
"world"

0.0.0.0:6379> setrange mykey 6 "redis" # 设置 mykey 中从索引 6 开始的新值为 "redis"
(integer) 11

0.0.0.0:6379> get mykey # 获取 setrange 操作后的 mykey 值
"hello redis"

0.0.0.0:6379> strlen mykey # 获取 mykey 字符串的长度
(integer) 11

```

>   [!IMPORTANT]
>
>   补充：这些指令都很简单，如果您需要了解更多，可以 [前往 Redis 的官网中查看](https://redis.io/docs/latest/develop/get-started/)，不过由于我们使用 `Redis` 的大部分场景都是在代码中直接进行编程（除了一些运维人员、测试人员可能需要非常了解进行必要的检查以外），因此没有必要了解得特别细（除非需要使用）...

---

# 4.Redis 数据类型

## 4.1.外部数据类型

-   **空值 none** 当键值对不存在时的一种特殊类型
-   **字符串 string** 最基本的数据类型，支持二进制安全的字符串
-   **列表 list** 按插入顺序存储的字符串列表，支持从两端推入和弹出操作
-   **集合 set** 无序字符串集合，不允许重复元素
-   **有序集合 Zset** 类似于集合，但每个成员都有一个与之关联的分数，并且按分数排序（这里的分数不是 `1/2` 这种，只是一个权重值）
-   **哈希 hash** 键值对的集合，适用于存储对象的字段和对应的值
-   **流 stream** 时用于存储和管理日志数据、消息队列等类型的数据，流的条目按时间戳进行排序
-   **位图 bitmap** 可以看作是一种压缩的数据结构，按位存储数据
-   **地理位置 geospatial** 用于存储地理位置数据并进行地理空间查询
-   ...

我们来简单尝试以下。

```shell
# none
0.0.0.0:6379> type non_existing_key
none
```

```shell
# string
0.0.0.0:6379> set mystring "hello"
OK

0.0.0.0:6379> type mystring
string
```

```shell
# list
0.0.0.0:6379> lpush mylist "item1"
(integer) 1

0.0.0.0:6379> lpush mylist "item2"
(integer) 2

0.0.0.0:6379> lpush mylist "item3"
(integer) 3

0.0.0.0:6379> lrange mylist 0 -1 # 查询列表所有元素, -1 表示最后一个元素
1) "item3"
2) "item2"
3) "item1"
0.0.0.0:6379> lrange mylist 1 1 # 查询 mylist[1] 处的元素
1) "item2"
0.0.0.0:6379> type mylist
list
```

```shell
# set
0.0.0.0:6379> sadd myset "member1"
(integer) 1

0.0.0.0:6379> sadd myset "member2"
(integer) 1

0.0.0.0:6379> sadd myset "member3"
(integer) 1

0.0.0.0:6379> smembers myset
1) "member3"
2) "member2"
3) "member1"

0.0.0.0:6379> sismember myset "member1"
(integer) 1

0.0.0.0:6379> sismember myset "member4"
(integer) 0

0.0.0.0:6379> type myset
set
```

```shell
# zset
0.0.0.0:6379> zadd myzset 3 "member3"
(integer) 1

0.0.0.0:6379> zadd myzset 2 "member2"
(integer) 1

0.0.0.0:6379> zadd myzset 1 "member1"
(integer) 1

0.0.0.0:6379> zrange myzset 0 -1
1) "member1"
2) "member2"
3) "member3"

0.0.0.0:6379> zrank myzset "member2" # 查找是否存在元素并且返回排名
(integer) 1

0.0.0.0:6379> zrank myzset "member3"
(integer) 2

0.0.0.0:6379> zrank myzset "member1"
(integer) 0

0.0.0.0:6379> type myzset
zset
```

```shell
# hash
0.0.0.0:6379> hset myhash field1 "value1"
(integer) 1

0.0.0.0:6379> hset myhash field2 "value2"
(integer) 1

0.0.0.0:6379> hset myhash field3 "value3"
(integer) 1

0.0.0.0:6379> hkeys myhash # 获取哈希中的所有字段
1) "field1"
2) "field2"
3) "field3"

0.0.0.0:6379> hvals myhash # 获取哈希中的所有值
1) "value1"
2) "value2"
3) "value3"

0.0.0.0:6379> hexists myhash field2 # 检查某个字段是否存在于哈希中
(integer) 1

0.0.0.0:6379> type myhash
hash
```

```shell
# stream
0.0.0.0:6379> xadd mystream * name "limou" age 18 
"1723358298361-0"

0.0.0.0:6379> xadd mystream * name "eimou" age 10
"1723358303994-0"

0.0.0.0:6379> xadd mystream * name "gimou" age 20
"1723358311147-0"

0.0.0.0:6379> keys *
1) "mystream"
0.0.0.0:6379> xread count 3 streams mystream 0 # 0 表示从流的开始读取所有的消息
1) 1) "mystream"
   2) 1) 1) "1723358298361-0"
         2) 1) "name"
            2) "limou"
            3) "age"
            4) "18"
      2) 1) "1723358303994-0"
         2) 1) "name"
            2) "eimou"
            3) "age"
            4) "10"
      3) 1) "1723358311147-0"
         2) 1) "name"
            2) "gimou"
            3) "age"
            4) "20"
            
0.0.0.0:6379> xread count 3 streams mystream $ # $ 表示从最新的数据开始读取所有的消息
(nil)

0.0.0.0:6379> xread count 3 streams mystream 1723358311147-0 # 直接使用流 ID 查询就是读取该 ID 之后的所有消息
(nil)

0.0.0.0:6379> xread count 3 streams mystream 1723358303994-0
1) 1) "mystream"
   2) 1) 1) "1723358311147-0"
         2) 1) "name"
            2) "gimou"
            3) "age"
            4) "20"
            
0.0.0.0:6379> xread count 3 streams mystream 1723358298361-0
1) 1) "mystream"
   2) 1) 1) "1723358303994-0"
         2) 1) "name"
            2) "eimou"
            3) "age"
            4) "10"
      2) 1) "1723358311147-0"
         2) 1) "name"
            2) "gimou"
            3) "age"
            4) "20"
```

```shell
# bitmap
0.0.0.0:6379> setbit mybitmap 7 1 # 设置第 7 位为 1
(integer) 0

0.0.0.0:6379> setbit mybitmap 2 1 # 设置第 2 位为 1
(integer) 0

0.0.0.0:6379> getbit mybitmap 7 # 查看第 7 位设置的比特值
(integer) 1

0.0.0.0:6379> getbit mybitmap 6 # 查看第 7 位设置的比特值
(integer) 0

0.0.0.0:6379> bitcount mybitmap # 统计位图中总共有多少个设置为 1 的比特位
(integer) 2
```

```shell
# geospatial
0.0.0.0:6379> geoadd myplaces 13.361389 38.115556 "Palermo" # 设置一个地理位置, 这里设置了经纬度和地名
(integer) 1

0.0.0.0:6379> geoadd myplaces 15.087269 37.502669 "Catania"
(integer) 1

0.0.0.0:6379> geopos myplaces "Palermo" # 查询某个位置的经纬度
1) 1) "13.36138933897018433"
   2) "38.11555639549629859"
   
0.0.0.0:6379> geodist myplaces "Palermo" "Catania" km # 查询两个地点之间的距离, 以 km 单位
"166.2742"

0.0.0.0:6379> georadius myplaces 15 37 100 km # 查询以经纬度 15, 37 为中心, 半径为 100km 的所有地名
1) "Catania"
```

不知道您有没有发现很相当大的一部分数据类型是由 `string` 这个类型衍生出来的，因此如果需要细学其他的类型，就必须先对 `string` 有足够的理解，首先您至少需要知道几件事：

-   所有的键名类型都是字符类型
-   字符串类型的键值可以单纯是字符串、一般格式的 `JSON`、一般格式的 `XML`、数字、二进制流，但是一个字符串的最大值不能是 `512MB`
-   `Redis` 内部存储的字符串是完全安装二进制流的形式保存的，所以不处理字符集编码，客户端传入的是什么字符集就存储什么字符集

>   [!IMPORTANT]
>
>   补充：`Redis` 内部的哈希通常被称为 `field-value` 对，这主要是为了和 `Readis` 本身的 `key-value` 做区分。

## 4.2.内部数据类型

实际上 `Redis` 针对每一种数据结构都有自己的底层内部编码实现，而且是多种实现，这样 `Redis` 就会根据合适的场景选择合适的内部编码，例如下表。

| **数据结构** | **内部编码**          |
| ------------ | --------------------- |
| string       | `raw, int, embstr`    |
| list         | `linkedlist, ziplist` |
| set          | `hashtable, intset`   |
| zset         | `skiplist, ziplist`   |
| hash         | `hashtable, ziplist`  |
| ...          | ...                   |

我们可以通过 `object encoding 键名` 查询此时键的内部编码。

`Redis` 这样设计有两个好处：

-   方便 `Redis` 未来改进内部编码，而对外的数据结构和命令没有任何影响，这样可以开发出更优秀的内部编码
-   多种内部编码实现可以在不同场景下发挥各自的优势，例如 `ziplist` 比较节省内存，但是在列表元素比较较多的情况下，性能会下降，这时候 `Redis` 会根据配置选项将列表类型的内部实现转换为 `linkedlist`，整个过程用户是全无感知的

### 4.2.1.string 的内部编码

尤其是字符串类型，内部编码至少有三种 `int(8byte 的长整型), embstr(<= 39byte 的字符串), raw(> 39byte 的字符串)`, `Redis` 会自动根据当前的值来决定使用哪一种内部编码进行实现。

```shell
# 查看 string 内部编码的变化
0.0.0.0:6379> set key 123
OK

0.0.0.0:6379> object encoding key
"int"

0.0.0.0:6379> set key limou
OK

0.0.0.0:6379> object encoding key
"embstr"

0.0.0.0:6379> set key limou343434343434343434343434343434343434343434343434343434343434
OK

0.0.0.0:6379> object encoding key
"raw"
```

### 4.2.2.list 的内部编码

### 4.2.3.set 的内部编码

### 4.2.4.zset 的内部编码

### 4.2.5.hash 的内部编码

哈希本身的内部编码变化也值得我们关注，内部的编码实现至少有两种 `ziplist(压缩列表), hashtable(哈希表)`，这就比字符串要复杂一些，前者...后者...

### 4.2.6.

# 5.Redis 设计架构

实际上 `Redis` 采用的是单线程的架构，但是为什么采用单线程还能这么快呢？主要原因如下：

-   纯内存访问，这是最重要的一点，工作环境和 `MySQL` 等持久化数据库完全不一样
-   非阻塞 `IO` 模型，底层使用了 `epoll` 的 `ET` 模式，无论时连接、读写、关闭都被转化为事件来处理，因此不会在网络 `IO` 上浪费太多时间
-   单线程模型，无论客户端如何操作，在微观上一定时存在时间差的，因此就避免了线程切换开销的问题和并发加锁的问题

`Redis` 的这种特性，导致 `Redis` 只能作用于快速执行场景的热数据，一旦某个操作过长，就会导致严重延时的响应，这对 `Redis` 服务几乎是致命的。

# 6.Redis 常见用处

## 6.1.缓存功能

## 6.2.计数功能

## 6.3.共享会话

# 7.Redis 通信协议

## 7.1.通信协议解析



## 7.2.Cpp 客户端



## 7.3.Java 客户端

待补充...

# 8.Redis 的持久化

## 8.1.RDB



## 8.2.AOF



# 9.Redis 事务操作



# 10.Redis 主从复制



# 11.Redis 哨兵机制



# 12.Redis 集群机制



