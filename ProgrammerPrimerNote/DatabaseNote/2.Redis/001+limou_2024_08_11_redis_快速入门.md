# 1.Redis 官方文档

## 1.1.Redis 的安装

[依照 Redis 官方文档即可下载 Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/)。

```shell
安装 Redis
$ sudo apt-get install lsb-release curl gpg # 以下指令可能过时, 推荐您看官方文档
$ curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg
$ sudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg
$ echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list
$ sudo apt-get update
$ sudo apt-get install redis

```

`Redis` 也有经典的 `CS` 模式，因此需要启动服务。

```shell
启动 Redis
$ sudo systemctl enable redis-server
$ sudo systemctl start redis-server

```

测试是否安装成功。

```shell
测试 Redis
$ redis-cli
127.0.0.1:6379> ping
PONG

```

>   [!IMPORTANT]
>
>   补充：`6379` 是 `Redis` 默认的服务端程序运行端口号。

## 1.2.Redis 的学习

接下来，可以 [根据 Redis 官方的快速学习手册进行学习](https://redis.io/docs/latest/get-started/)：

-   [Redis 作为内存中数据类型存储快速入门](https://redis.io/docs/latest/develop/get-started/data-store/)，并且还需要 [阅读 Redis 中的数据类型](https://redis.io/docs/latest/develop/data-types/)，每一个数据类型都可以有对应的文档
-   [Redis 作为文档数据库快速入门](https://redis.io/docs/latest/develop/get-started/document-database/)（但是必须额外下载 `Redis Stack`）
-   [Redis 作为矢量数据库快速入门](https://redis.io/docs/latest/develop/get-started/vector-database/)（但是必须额外下载 `Redis Stack`，并且您必须学习过机器学习）

这几个文档还是非常简单易读的，非常推荐（和本系列一起阅读更佳）。

如果觉得文档太难看懂，可以看看 [别人搬运的尚硅谷 Redis 教程(非正版...)](https://www.bilibili.com/video/BV1UnY5ehE4b?vd_source=c92c89dbfcf9cc30c48086469621f35b&spm_id_from=333.788.videopod.episodes)。

# 2.Redis 登录退出

登录方式和 `MySQL` 是一样的，可以在命令行使用客户端登录的方式，也可以只执行单条的命令，我们可以简单试试启动 `Redis` 的客户端。

```shell
Redis 的登录和退出
# 直接使用客户端登录并且使用
$ redis-cli -h 0.0.0.0 -p 6379

0.0.0.0:6379> ping
PONG # WebSocket 协议中, PING 和 PONG 是一种心跳机制, 服务器或客户端可以发送 PING, 而接收方会响应 PONG, 以确保连接存活

0.0.0.0:6379> set key hello
OK

0.0.0.0:6379> get key
"hello"

0.0.0.0:6379> exit # 退出 Redis

# 在命令行中只执行一次 Redis 的指令
$ redis-cli -h 0.0.0.0 -p 6379 ping
PONG

```

>   [!WARNING]
>
>   注意：`Redis` 其实在实际开发中是不会暴露给外界访问的，我们这里只不过是为了方便把配置文件改为 `0.0.0.0`，如果您只在本机操作 `redis` 则默认使用的是 `127.0.0.1` 地址，并且默认 `6379` 端口，此时可以直接省略 `-h` 和 `-p` 直接登录。

# 3.Redis 指令教程

我们先再来学几个指令尝尝鲜，这些指令在后面用到的概率也非常高，另外 `Redis` 的指令也可以无视对大小写。

## 3.1.基础指令

### 3.1.1.SET, GET, DEL

`set, get, del` 这三个指令非常简单，就是设置（修改）、获取、删除键值对。

```shell
使用 set, get, del
0.0.0.0:6379> set my_key "hello"
OK

0.0.0.0:6379> get my_key
"hello"

0.0.0.0:6379> del my_key
(integer) 1

0.0.0.0:6379> get my_key
(nil)
```

>   [!IMPORTANT]
>
>   补充：实际上还有更加方便可用的变种指令
>
>   -   `setex <key_name> <seconds> <key_value>` 可以直接使用秒作为单位设置 `key` 的过期时间
>   -   `setpx <key_name> <milliseconds> <key_value>` 可以直接使用毫秒作为单位设置 `key` 的过期时间
>   -   `setnx <key_name> <key_value>` 只在 `key` 不存在时才进行设置，即如果 `key` 之前已经存在，不执行设置
>   -   `setxx <key_name> <key_value>` 只在 `key` 存在时才进行设置，即如果 `key` 之前不存在，不执行设置
>   -   `mset <key_name_1> <key_value_1> <key_name_2> <key_value_2> ...` 一次设置多个键值对
>   -   `mget key_name_1 key_name_2` 一次获取多个键值
>   -   另外 `del` 本身就支持删除多个键值对...

### 3.1.2.KEYS, EXISTS, SCAN

`keys` 指令可以根据一定的样式，或者匹配模式来查询对应的 `key` 值，查询的复杂度是 $O(n)$，而 `exists` 则可以查询 `key` 存在的个数，时间复杂度是 $O(1)$。

```shell
使用 keys, exists
0.0.0.0:6379> mset key_1 "hello" key_2 "limou" # 这个是 set 的升级版, 可以一次设置多个 key-value 对
OK

0.0.0.0:6379> keys * # 查询所有 k-v 值
1) "key_2"
2) "backup1"
3) "backup3"
4) "backup4"
5) "key_1"
6) "backup2"

0.0.0.0:6379> keys key_? # 查询 key_1 key_2 key_y 等 k-v 值
1) "key_2"
2) "key_1"

0.0.0.0:6379> keys k* # 查询 k2ey key_2 kkkkey key_1 等 k-v 值
1) "key_2"
2) "key_1"

0.0.0.0:6379> keys key_[13] # 查询 key_1 key_3 这两个 k-v 值
1) "key_1"

0.0.0.0:6379> keys key_[^1] # 查询除了 key_1 以外的所有 key_2 key_w key_0 等 k-v 值
1) "key_2"

0.0.0.0:6379> keys key_[0-3] # 查询 key_1 key_2 key_3 这三个 k-v 值
1) "key_2"
2) "key_1"

0.0.0.0:6379> exists key_1 # 查找符合 key_1 的个数
(integer) 1

0.0.0.0:6379> exists key_1 key_2 # 查找符合 key_1, key_2 的个数
(integer) 2

```

>   [!CAUTION]
>
>   警告：`keys` 的时间复杂度比较大，一般在实际工程中会直接禁用这个命令，否者一旦 `Redis` 在有大量的指令时，就会出现“卡住”的情况，这和 `Redis` 的架构设计本身是有关系的，后面再说...

还有一个比较高效的增量扫描 `scan` 指令，放回的数据是分批量的，即便是在单线程的情况下，也可以非阻塞返回大规模数据集，不会对 `Redis` 有很大的性能影响。

```shell
使用 scan
127.0.0.1:6379> scan 0 match "key_*" count 100 # 0 代表游标, 是扫描的起始位置, 表示从当前 Redis 键空间
1) "0" # 这里是因为数据量不大, 直接返回新的游标为 0 表示扫描完成, 如果数据量大会得到新的游标
2) 1) "key_2"
   2) "key_1"
```

可以看到 `keys` 是扫描整个键值空间，但是 `scan` 可以由用户指定游标进行增量扫描。

>   [!IMPORTANT]
>
>   补充：`Redis` 也是有关于数据库的概念的，也就是 `Redis` 键空间。

### 3.1.3.EXPIRE, TTL

`expire` 为指定的 `key` 值添加秒级的过期时间，返回 `1` 表示设置成功，返回 `0` 表示设置失败，并且可以对同一个 `key` 值反复使用达到修改过期时间的目的。而 ` TTL` 则可以获取指定 `key` 值的过去时间，单位也是秒级，其返回值为 `任意数字` 表示距离过期时间所剩的秒数，`-1` 表示没有关联过期时间，`-2` 表示 `key` 不存在。

```shell
使用 expire, ttl
0.0.0.0:6379> set key 100
OK

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> expire key 5 # 设置 key 的过期时间
(integer) 1

0.0.0.0:6379> get key # 每一秒获取一次
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> get key
(nil)

0.0.0.0:6379> ttl key # 查看已经不存在的 key
(integer) -2

0.0.0.0:6379> set key 100 # 重新设置一个 key 值
OK

0.0.0.0:6379> set other_key 20 # 再设置另外一个 key 值
OK

0.0.0.0:6379> expire key 10 # 为第一个 key 设置过期时间
(integer) 1

0.0.0.0:6379> ttl key # 查看第一个 key 剩余的过期时间
(integer) 7

0.0.0.0:6379> ttl key # 查看第一个 key 剩余的过期时间
(integer) 4

0.0.0.0:6379> ttl other_key # 试图查看另外一个没有设置过期时间的 key 的剩余过期时间
(integer) -1

0.0.0.0:6379> set key 100 # 再次重新设置 key 值
OK

0.0.0.0:6379> get key # 正常获取
"100"

0.0.0.0:6379> expire key 100000 # 设置比较大的过期时间
(integer) 1

0.0.0.0:6379> ttl key # 查看剩余的过期时间
(integer) 99994

0.0.0.0:6379> expire key 10 # 重新设置过期时间
(integer) 1

0.0.0.0:6379> ttl key # 检查现在的过期时间
(integer) 9

```

>   [!IMPORTANT]
>
>   补充：实际上 `expire, ttl` 都有支持毫秒版本的 `pexpire, pttl`，使用方法类似。

### 3.1.4.TYPE

`type` 也很简单，可以返回 `key` 值的数据类型，返回值有 `none, string, list, set, zset, hash, stream...` 其实就对应后面数据类型。

```shell
使用 type
0.0.0.0:6379> set key 100
OK

0.0.0.0:6379> get key
"100"

0.0.0.0:6379> type key
string

```

### 3.1.5.INCR, INCRBY, DECR, DECRBY, INCRBYFLOAR

`incr` 可以用来给一个字符串类型的实数进行 `+1` 操作，哪怕这个 `key` 值之前不存在，也会从 `0` 开始加起。`incrby` 也是类似，但是加上用户指定的整数值（注意只能是整数），不存在时，该 `key` 也是从 `0` 开始加起。而 `decr` 和 `decrby` 和前面两者类似，只不过是变成减而已。

>   [!IMPORTANT]
>
>   补充：顺口一提上述关于 `...by` 的指令都可以使用负数作为操作数。

对于浮点数来说，只使用一个指令 `incrbyfloat` 就够了，功能也是类似的，加减使用正负实数调控就行。

```shell
使用 incr, incrby, decr, decrby, incrbyfloat
# incr
0.0.0.0:6379> exists mykey
(integer) 0

0.0.0.0:6379> incr mykey
(integer) 1

0.0.0.0:6379> exists mykey
(integer) 1

0.0.0.0:6379> get mykey
"1"

0.0.0.0:6379> incr mykey
(integer) 2

0.0.0.0:6379> incr mykey
(integer) 3

0.0.0.0:6379> incr mykey
(integer) 4

0.0.0.0:6379> get mykey
"4"

# incrby
0.0.0.0:6379> incrby mykey 5
(integer) 9

# decr
0.0.0.0:6379> decr mykey
(integer) 8

# decrby
0.0.0.0:6379> decrby mykey 7
(integer) 1

# incrbyfloat
0.0.0.0:6379> incrbyfloat mykey 5.6
"9.6"
0.0.0.0:6379> incrbyfloat mykey -10.33
"-0.73"
```

### 3.1.6.APPEND, GETRANGE, SETRANGE, STRLEN

还可以对字符串进行操作，这些也比较简单...

```shell
使用 append, getrange, setrange, strlen
0.0.0.0:6379> set mykey "hello" # 设置初始字符串值到键 mykey
ok

0.0.0.0:6379> get mykey # 获取键 mykey 的值
"hello"

0.0.0.0:6379> append mykey " world" # 向 mykey 键追加字符串 " world"
(integer) 11

0.0.0.0:6379> get mykey # 获取追加后的 mykey 值
"hello world"

0.0.0.0:6379> getrange mykey 0 4 # 获取 mykey 值中从索引 0 到 4 的子串
"hello"

0.0.0.0:6379> getrange mykey 6 10 # 获取 mykey 值中从索引 6 到 10 的子串
"world"

0.0.0.0:6379> setrange mykey 6 "redis" # 设置 mykey 中从索引 6 开始的新值为 "redis"
(integer) 11

0.0.0.0:6379> get mykey # 获取 setrange 操作后的 mykey 值
"hello redis"

0.0.0.0:6379> strlen mykey # 获取 mykey 字符串的长度
(integer) 11

```

>   [!IMPORTANT]
>
>   补充：这些指令都很简单，如果您需要了解更多，可以 [前往 Redis 的官网中查看](https://redis.io/docs/latest/develop/get-started/)，不过由于我们使用 `Redis` 的大部分场景都是在代码中直接进行编程（除了一些运维人员、测试人员可能需要非常了解进行必要的检查以外），因此没有必要了解得特别细（除非需要使用）...

## 3.2.模块指令

除了基础的对于数据类型的操作指令，还有一些不同模块的指令，有需要再进行学习，不过这里先列出来：

> [!CAUTION]
>
> 警告：模块默认不直接内嵌到 `redis service` 中，因此需要您下载 `Redis` 的拓展 `Redis Stack` 才能使用。
>
> ```shell
> # 安装 Redis Stack
> # 停止传统的 Redis 服务
> $ sudo systemctl stop redis
> 
> # 检查是否停止 Redis 服务
> $ redis-cli
> Could not connect to Redis at 127.0.0.1:6379: Connection refused
> not connected> exit
> 
> # 开始安装 Redis Stack
> $ sudo apt-get install lsb-release curl gpg
> 
> $ curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg
> 
> $ sudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg
> 
> $ echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list
> 
> 
> $ sudo apt-get update
> $ sudo apt-get install redis-stack-server
> 
> # 由于我使用的是 Ubuntu24.04(这个时候比较新), 因此我需要使用二进制进行下载, 而无法使用包管理安装...
> 
> # 在 https://redis.io/downloads/#redis-stack-downloads 底部获取你所需要的安装链接
> 
> $ wget https://packages.redis.io/redis-stack/redis-stack-server-7.4.0-v1.jammy.x86_64.tar.gz
> 
> $ mv redis-stack-server-7.4.0-v1 redis-stack-server
> 
> $ sh redis-stack-server/bin/redis-stack-server
> # 此时就会启动输出...您可以开始测试是否已运行该服务...
> 
> # 打开另外一个终端开始测试
> $ redis-cli
> 127.0.0.1:6379> MODULE LIST
> 1) 1) "name"
>    2) "RedisCompat"
>    3) "ver"
>    4) (integer) 1
>    5) "path"
>    6) "/home/ljp/temp/redis-stack-server/lib/rediscompat.so"
>    7) "args"
>    8) (empty array)
> 2) 1) "name"
>    2) "redisgears_2"
>    3) "ver"
>    4) (integer) 20020
>    5) "path"
>    6) "/home/ljp/temp/redis-stack-server/lib/redisgears.so"
>    7) "args"
>    8) 1) "v8-plugin-path"
>       2) "/home/ljp/temp/redis-stack-server/lib/libredisgears_v8_plugin.so"
> 3) 1) "name"
>    2) "search"
>    3) "ver"
>    4) (integer) 21005
>    5) "path"
>    6) "/home/ljp/temp/redis-stack-server/lib/redisearch.so"
>    7) "args"
>    8) 1) "MAXSEARCHRESULTS"
>       2) "10000"
>       3) "MAXAGGREGATERESULTS"
>       4) "10000"
> 4) 1) "name"
>    2) "bf"
>    3) "ver"
>    4) (integer) 20802
>    5) "path"
>    6) "/home/ljp/temp/redis-stack-server/lib/redisbloom.so"
>    7) "args"
>    8) (empty array)
> 5) 1) "name"
>    2) "ReJSON"
>    3) "ver"
>    4) (integer) 20803
>    5) "path"
>    6) "/home/ljp/temp/redis-stack-server/lib/rejson.so"
>    7) "args"
>    8) (empty array)
> 6) 1) "name"
>    2) "timeseries"
>    3) "ver"
>    4) (integer) 11202
>    5) "path"
>    6) "/home/ljp/temp/redis-stack-server/lib/redistimeseries.so"
>    7) "args"
>    8) (empty array)
> 
> # 有比较多的回显就是配置成功了
> 
> ```

### 3.2.1.RediSearch(`FT`)

主要用于全文搜索和数据索引功能，核心命令如：
   - `FT.CREATE`、`FT.ADD`、`FT.SEARCH`：创建索引、添加文档、搜索查询
   - `FT.AGGREGATE`：执行聚合查询
   - `FT.DROPINDEX`、`FT.SYNUPDATE` 等

### 3.2.2.RedisJSON(`JSON`)

`RedisJSON` 模块用于在 `Redis` 中存储和操作 `JSON` 数据类型，核心命令如：

   - `JSON.SET`：设置 `JSON` 数据
   - `JSON.GET`：获取 `JSON` 数据
   - `JSON.DEL`：删除 `JSON` 键
   - `JSON.MGET`：从多个键中获取 `JSON` 值

### 3.2.3.RedisGraph(`GRAPH`)
   RedisGraph 提供了图数据库功能，用于图数据的存储和查询，核心命令如：
   - `GRAPH.QUERY`：使用 `Cypher` 查询语言执行查询。
   - `GRAPH.PROFILE`：分析查询性能。
   - `GRAPH.DELETE`：删除图。

### 3.2.4.RedisTimeSeries(`TS`)
`RedisTimeSeries` 是用于存储和分析时间序列数据的模块，核心命令如：

   - `TS.CREATE`：创建时间序列
   - `TS.ADD`：添加时间序列数据点
   - `TS.RANGE`、`TS.MRANGE`：查询时间范围内的数据
   - `TS.ALTER`：修改时间序列元数据

### 3.2.5.RedisAI(`AI`)
`RedisAI` 用于在 `Redis` 中运行机器学习模型，支持 `TensorFlow, PyTorch, ONNX...` 模型，核心命令如：

   - `AI.MODELSET`：加载机器学习模型
   - `AI.MODELRUN`：运行机器学习模型
   - `AI.SCRIPTSET`：设置自定义脚本
   - `AI.TENSORSET` 和 `AI.TENSORGET`：处理张量数据

### 3.2.6.RedisBloom(`BF`, `CF`, `CMS`, `TOPK`)
`RedisBloom` 提供了`布隆过滤器, 计数最小堆, Cuckoo Filter, TopK...` 等数据类型，适合处理大数据集合。

   - **布隆过滤器** (`BF`)：`BF.ADD`、`BF.EXISTS`
   - **Cuckoo Filter** (`CF`)：`CF.ADD`、`CF.EXISTS`
   - **Count-Min Sketch** (`CMS`)：`CMS.INCRBY`、`CMS.QUERY`
   - **TopK**：`TOPK.ADD`、`TOPK.QUERY`

这些模块可以根据场景进行组合使用，以增强 `Redis` 数据库的功能，从而更高效地处理搜索、图数据、时间序列分析和机器学习任务。

> [!IMPORTANT]
>
> 补充：由于有需要我补充这部分内容。
>
> ```shell
> # 使用 RediSearch 和 RedisJSON 的相关指令
> 0.0.0.0:6379> FT.CREATE \ # 设置添加索引
> idx:bicycle \ # 设置索引名称
> ON JSON \ # 表示针对 JSON 的索引
> PREFIX 1 bicycle: \ # 仅对具有 "bicycle:" 前缀的键创建索引(这里的数字代表可以设置多个前缀)
> SCORE 1.0 \ # 为该索引设置评分(用于索引之间进行评分比较)
> SCHEMA \ # 后面定义字段的模式
> $.brand AS brand TEXT WEIGHT 1.0 \
> $.model AS model TEXT WEIGHT 1.0 \
> $.description AS description TEXT WEIGHT 1.0 \
> $.price AS price NUMERIC \
> $.condition AS condition \
> TAG SEPARATOR "," # 设置标签, 用于分割不同 JSON 对象
> # 完整一行指令为 FT.CREATE idx:bicycle ON JSON PREFIX 1 bicycle: SCORE 1.0 SCHEMA $.brand AS brand TEXT WEIGHT 1.0 $.model AS model TEXT WEIGHT 1.0 $.description AS description TEXT WEIGHT 1.0 $.price AS price NUMERIC $.condition AS condition TAG SEPARATOR ","
> OK
> 
> # 上述描述的就是一个 JSON 对象的集合
> # {
> #   "bicycle:xxx": {
> #     "brand": "",
> #     "model": "",
> #     "description": "",
> #     "price": 0,
> #     "condition": ""
> #   },
> # }
> 
> # 可以使用 FT.INFO idx:bicycle 查看配置结果
> 
> # 设置 "键名-JSON:" 对
> 0.0.0.0:6379> JSON.SET \
> "bicycle:0" \
> "." \ # 存储在根处, 也可以是只设置字段
> "{\"brand\": \"Velorim\", \"model\": \"Jigger\", \"price\": 270, \"description\": \"Small and powerful, the Jigger is the best ride for the smallest of tikes! This is the tiniest kids\\u2019 pedal bike on the market available without a coaster brake, the Jigger is the vehicle of choice for the rare tenacious little rider raring to go.\", \"condition\": \"new\"}"
> # 完整指令为 JSON.SET "bicycle:0" "." "{\"brand\": \"Velorim\", \"model\": \"Jigger\", \"price\": 270, \"description\": \"Small and powerful, the Jigger is the best ride for the smallest of tikes! This is the tiniest kids\\u2019 pedal bike on the market available without a coaster brake, the Jigger is the vehicle of choice for the rare tenacious little rider raring to go.\", \"condition\": \"new\"}"
> 
> # 获取键对应 JSON 的某个字段
> 0.0.0.0:6379> JSON.GET bicycle:0 $.brand $.price
> "{\"$.brand\":[\"Velorim\"],\"$.price\":[270]}"
> 
> # 更新键对应 JSON 的某个字段
> 0.0.0.0:6379> JSON.SET bicycle:1234 $ '{"price": 600}'
> 
> # 查卡键对应 JSON 的所有字段‘
> 0.0.0.0:6379> JSON.GET bicycle:0
> "{\"brand\":\"Velorim\",\"model\":\"Jigger\",\"price\":270,\"description\":\"Small and powerful, the Jigger is the best ride for the smallest of tikes! This is the tiniest kids\xe2\x80\x99 pedal bike on the market available without a coaster brake, the Jigger is the vehicle of choice for the rare tenacious little rider raring to go.\",\"condition\":\"new\"}"
> 
> # 不过我们使用的是 JSON.GET, 如果使用 FT.SEARCH 还能用于执行基于全文索引的搜索查询, 它结合了索引、评分、排序和过滤功能, 可以用于复杂的搜索操作...
> 
> # 使用 FT 的查询
> 0.0.0.0:6379> FT.SEARCH "idx:bicycle" "*" LIMIT 0 10
> 1) (integer) 1
> 2) "bicycle:0"
> 3) 1) "$"
>    2) "{\"brand\":\"Velorim\",\"model\":\"Jigger\",\"price\":270,\"description\":\"Small and powerful, the Jigger is the best ride for the smallest of tikes! This is the tiniest kids\xe2\x80\x99 pedal bike on the market available without a coaster brake, the Jigger is the vehicle of choice for the rare tenacious little rider raring to go.\",\"condition\":\"new\"}"
> 
> ```
>
> 更多待补充...

## 3.3.自定指令

除了已有的基础指令和模块指令，还可以使用 `Lua` 脚本代码编写出用户自己定义的指令，待补充...

# 4.Redis 数据类型

## 4.1.外部数据类型

知道前面的基础指令后，就可以知道 `Redis` 是一个跨语言的大号键值对存储数据库，但是除了简单的字符类型以外，键位对应的值还可以是其他数据类型，主要的数据类型有一下六种。

-   **空值 None** 当键值对不存在时的一种特殊类型
-   **字符 String** 最基本的数据类型，支持二进制安全的字符串
-   **列表 List** 按插入顺序存储的字符串列表，支持从两端推入和弹出操作
-   **无权集合 Set** 无序字符串集合，不允许重复元素
-   **带权集合 Zset** 类似于集合，但每个成员都有一个与之关联的分数，并且按分数排序（这里的分数不是 `1/2` 这种，只是一个权重值）
-   **键值集合 Hash** 键值对的集合，适用于存储对象的字段和对应的值，也可以叫哈希，这意味着键对应的值也可以是一系列键值对（有点套娃）

>   [!IMPORTANT]
>
>   补充：也有一些比较高级的类型，有很多是字符类型演变而来。
>
>   -   **位图 bitmap** 可以看作是一种压缩的数据类型，按位存储数据
>   -   **地理位置 geospatial** 用于存储地理位置数据并进行地理空间查询
>   -   **流 stream** 用于存储和管理日志数据、消息队列等类型的数据，流的条目按时间戳进行排序
>   -   **基数 HyperLogLog** 用于统计某个数据流中不重复元素的数量（如果您的需求是要 **存储所有的元素并进行操作**，那么 `Set` 是合适的选择；如果您只是需要 **估算独立元素的数量**，且不关心精确值，那么 `Hyper LogLog` 会更高效）
>   -   ...

>   [!IMPORTANT]
>
>   补充：流的存在，使得 `Redis` 可以简单充当一个消息队列，但是这不是 `Redis` 的主要应用场景。不过这可以作为中小型项目的消息队列组件，尤其是在已经引入 `Redis` 时，可以快速把 `Redis` 作为消息队列，减低系统复杂度。

我们来简单尝试一下。

```shell
# None
0.0.0.0:6379> type non_existing_key
none

```

```shell
# String
0.0.0.0:6379> set mystring "hello"
OK

0.0.0.0:6379> type mystring
string

```

```shell
# List
0.0.0.0:6379> lpush mylist "item1"
(integer) 1

0.0.0.0:6379> lpush mylist "item2"
(integer) 2

0.0.0.0:6379> lpush mylist "item3"
(integer) 3

0.0.0.0:6379> lrange mylist 0 -1 # 查询列表所有元素, 0 表示最先一个元素, -1 表示最后一个元素
1) "item3"
2) "item2"
3) "item1"
0.0.0.0:6379> lrange mylist 1 1 # 查询 mylist [1] 处的元素
1) "item2"
0.0.0.0:6379> type mylist
list

```

```shell
# Set
0.0.0.0:6379> sadd myset "member1"
(integer) 1

0.0.0.0:6379> sadd myset "member2"
(integer) 1

0.0.0.0:6379> sadd myset "member3"
(integer) 1

0.0.0.0:6379> smembers myset
1) "member3"
2) "member2"
3) "member1"

0.0.0.0:6379> sismember myset "member1"
(integer) 1

0.0.0.0:6379> sismember myset "member4"
(integer) 0 # 表示不存在这个元素

0.0.0.0:6379> type myset
set

```

```shell
# Zset
0.0.0.0:6379> zadd myzset 3 "member3"
(integer) 1

0.0.0.0:6379> zadd myzset 2 "member2"
(integer) 1

0.0.0.0:6379> zadd myzset 1 "member1"
(integer) 1

0.0.0.0:6379> zrange myzset 0 -1
1) "member1"
2) "member2"
3) "member3"

0.0.0.0:6379> zrank myzset "member2" # 查找是否存在元素并且返回排名
(integer) 1

0.0.0.0:6379> zrank myzset "member3"
(integer) 2

0.0.0.0:6379> zrank myzset "member1"
(integer) 0

0.0.0.0:6379> type myzset
zset

```

```shell
# Hash
0.0.0.0:6379> hset myhash field1 "value1"
(integer) 1

0.0.0.0:6379> hset myhash field2 "value2"
(integer) 1

0.0.0.0:6379> hset myhash field3 "value3"
(integer) 1

0.0.0.0:6379> hkeys myhash # 获取哈希中的所有字段
1) "field1"
2) "field2"
3) "field3"

0.0.0.0:6379> hvals myhash # 获取哈希中的所有值
1) "value1"
2) "value2"
3) "value3"

0.0.0.0:6379> hexists myhash field2 # 检查某个字段是否存在于哈希中
(integer) 1

0.0.0.0:6379> type myhash
hash

```

>   [!IMPORTANT]
>
>   补充：下面补充一些高级数据类型的使用。
>
>   ```shell
>   # Bitmap
>   0.0.0.0:6379> setbit mybitmap 7 1 # 设置第 7 位为 1
>   (integer) 0
>   
>   0.0.0.0:6379> setbit mybitmap 2 1 # 设置第 2 位为 1
>   (integer) 0
>   
>   0.0.0.0:6379> getbit mybitmap 7 # 查看第 7 位设置的比特值
>   (integer) 1
>   
>   0.0.0.0:6379> getbit mybitmap 6 # 查看第 7 位设置的比特值
>   (integer) 0
>   
>   0.0.0.0:6379> bitcount mybitmap # 统计位图中总共有多少个设置为 1 的比特位
>   (integer) 2
>   
>   ```
>
>   ```shell
>   # Geospatial
>   0.0.0.0:6379> geoadd myplaces 13.361389 38.115556 "Palermo" # 设置一个地理位置, 这里设置了经纬度和地名
>   (integer) 1
>   
>   0.0.0.0:6379> geoadd myplaces 15.087269 37.502669 "Catania"
>   (integer) 1
>   
>   0.0.0.0:6379> geopos myplaces "Palermo" # 查询某个位置的经纬度
>   1) 1) "13.36138933897018433"
>      2) "38.11555639549629859"
>      
>   0.0.0.0:6379> geodist myplaces "Palermo" "Catania" km # 查询两个地点之间的距离, 以 km 单位
>   "166.2742"
>   
>   0.0.0.0:6379> georadius myplaces 15 37 100 km # 查询以经纬度 15, 37 为中心, 半径为 100km 的所有地名
>   1) "Catania"
>   
>   ```
>
>   ```shell
>   # Stream
>   # 添加流
>   0.0.0.0:6379> xadd \ # 添加流的指令
>                 mystream \ # 设置流的名称
>                 * \ # * 代表由 Redis 自己生成时间戳
>                 name "limou" age 18 # 代表流存储的数据
>   "1723358298361-0"
>   # 每条消息都有一个唯一的 ID, 这个 ID 由两部分组成, 使用 - 分隔
>   # 第一部分是一个时间戳(毫秒级), 表示消息被写入流的时间
>   # 第二部分是一个序列号, 用来区分同一时间戳下的不同消息(为了区分同时间戳)
>   
>   0.0.0.0:6379> xadd mystream * name "eimou" age 10
>   "1723358303994-0"
>   
>   0.0.0.0:6379> xadd mystream * name "gimou" age 20
>   "1723358311147-0"
>   
>   # 查询流
>   0.0.0.0:6379> keys *
>   1) "mystream"
>   0.0.0.0:6379> xread count 3 streams mystream 0 # 0 表示从流的开始读取所有的消息
>   1) 1) "mystream"
>      2) 1) 1) "1723358298361-0"
>            2) 1) "name"
>               2) "limou"
>               3) "age"
>               4) "18"
>         2) 1) "1723358303994-0"
>            2) 1) "name"
>               2) "eimou"
>               3) "age"
>               4) "10"
>         3) 1) "1723358311147-0"
>            2) 1) "name"
>               2) "gimou"
>               3) "age"
>               4) "20"
>               
>   0.0.0.0:6379> xread count 3 streams mystream $ # $ 表示从最新的数据开始读取所有的消息
>   (nil)
>   
>   0.0.0.0:6379> xread count 3 streams mystream 1723358311147-0 # 直接使用流 ID 查询就是读取该 ID 之后的所有消息
>   (nil)
>   
>   0.0.0.0:6379> xread count 3 streams mystream 1723358303994-0
>   1) 1) "mystream"
>      2) 1) 1) "1723358311147-0"
>            2) 1) "name"
>               2) "gimou"
>               3) "age"
>               4) "20"
>               
>   0.0.0.0:6379> xread count 3 streams mystream 1723358298361-0
>   1) 1) "mystream"
>      2) 1) 1) "1723358303994-0"
>            2) 1) "name"
>               2) "eimou"
>               3) "age"
>               4) "10"
>         2) 1) "1723358311147-0"
>            2) 1) "name"
>               2) "gimou"
>               3) "age"
>               4) "20"
>   # 这种情况下是直接消费数据的, 并且数据不会因为消费消失
>   
>   ```
>
>   ```shell
>   # HyperLogLog 
>   0.0.0.0:6379> PFADD ip_set \
>                   "192.168.0.1" \
>                   "192.168.0.2" \
>                   "192.168.0.3" \
>                   "192.168.0.1" \ # 这个是重复的 IP 地址
>                   "192.168.0.4" \
>                   "192.168.0.5" # 完整指令为 PFADD ip_set "192.168.0.1" "192.168.0.2" "192.168.0.3" "192.168.0.1" "192.168.0.4" "192.168.0.5"
>   (integer) 1
>   
>   0.0.0.0:6379> PFCOUNT ip_set
>   (integer) 5
>   ```

不知道您有没有发现很相当大的一部分数据类型是由 `string` 这个类型衍生出来的，因此如果需要细学其他的类型，就必须先对 `string` 有足够的理解，首先您至少需要知道几件事：

-   所有的键名类型都是字符类型
-   字符串类型的键值可以单纯是（但是一个字符串的最大值不能是 `512MB`）：
    -   字符串
    -   一般格式的 `JSON`
    -   一般格式的 `XML`
    -   数字
    -   二进制流

-   `Redis` 内部存储的字符串是完全按照二进制流的形式保存的，所以不需要处理字符集编码，客户端传入的是什么字符集就存储什么

>   [!IMPORTANT]
>
>   补充：`Redis` 内部的哈希通常被称为 `field-value` 对，这主要是为了和 `Readis` 本身的 `key-value` 做区分。

## 4.2.内部数据类型

实际上 `Redis` 针对每一种数据类型都有自己的底层内部编码实现，而且是多种实现，这样 `Redis` 就会根据合适的场景选择合适的内部编码，例如下表（除去空类型剩下的五个类型）。

| **数据类型** | **内部编码**          |
| ------------ | --------------------- |
| String       | `raw, int, embstr`    |
| List         | `linkedlist, ziplist` |
| Set          | `hashtable, intset`   |
| Zset         | `skiplist, ziplist`   |
| Hash         | `hashtable, ziplist`  |

我们可以通过 `object encoding 键名` 查询此时键的内部编码。

`Redis` 这样设计有两个好处：

-   方便 `Redis` 未来改进内部编码，而对外的数据类型和命令没有任何影响，这样可以开发出更优秀的内部编码
-   多种内部编码实现可以在不同场景下发挥各自的优势，例如 `ziplist` 比较节省内存，但是在列表元素比较较多的情况下，性能会下降，这时候 `Redis` 会根据配置选项将列表类型的内部实现转换为 `linkedlist`，整个过程用户是全无感知的

### 4.2.1.String 的内部编码

尤其是字符串类型，内部编码至少有三种 `int(8byte 的长整型), embstr(<= 39byte 的字符串), raw(> 39byte 的字符串)`, `Redis` 会自动根据当前的值来决定使用哪一种内部编码进行实现。

```shell
# 查看 string 内部编码的变化
0.0.0.0:6379> set key 123
OK

0.0.0.0:6379> object encoding key
"int"

0.0.0.0:6379> set key limou
OK

0.0.0.0:6379> object encoding key
"embstr"

0.0.0.0:6379> set key limou343434343434343434343434343434343434343434343434343434343434
OK

0.0.0.0:6379> object encoding key
"raw"
```

### 4.2.2.List 的内部编码

### 4.2.3.Set 的内部编码

### 4.2.4.Zset 的内部编码

### 4.2.5.Hash 的内部编码

哈希本身的内部编码变化也值得我们关注，内部的编码实现至少有两种 `ziplist(压缩列表), hashtable(哈希表)`，这就比字符串要复杂一些，前者...后者...

# 5.Redis 设计架构

实际上 `Redis` 采用的是单线程的架构，但是为什么采用单线程还能这么快呢？主要原因如下：

-   纯内存访问，这是最重要的一点，工作环境和 `MySQL` 等持久化数据库完全不一样
-   非阻塞 `IO` 模型，底层用 `epoll` 的 `ET` 模式，无论时连接、读写、关闭都被转化为事件来处理，因此不会在网络 `IO` 上浪费太多时间
-   单线程模型，无论客户端如何操作，在微观上一定时存在时间差的，因此就避免了线程切换开销的问题和并发加锁的问题

`Redis` 的这种特性，导致 `Redis` 只能作用于快速执行场景的热数据，一旦某个操作过长，就会导致严重延时的响应，这对 `Redis` 服务几乎是致命的。

# 6.Redis 通信协议

## 6.1.通信协议解析



## 6.2.Cpp 客户端



## 6.3.Java 客户端

待补充...

# 7.Redis 的持久化

## 7.1.RDB



## 7.2.AOF



# 8.Redis 事务操作



# 9.Redis 的流水线



# 10.Redis 集群管理

为了支持分布式架构，`Redis` 支持以下基础功能：

- `Redis` 提供了复制功能，实现了存在多个相同数据的 `Redis` 副本，一般会分为主服务器和从服务器
- 并且 `Redis` 也提供了支持高可用的哨兵机制，可以保证 `Redis` 节点的故障发现和故障转移

## 10.1.Redis 主从复制



## 10.2.Redis 哨兵机制



# 11.Redis 功能定位

下面将讨论一个非常重要的问题，究竟是我们学会使用 `Redis` 后，该如何接入到我们自己项目中，在哪里应该使用 `Redis`，在哪里不应该使用 `Redis`，我们需要解决的是 `Why` 的问题。相信我，`Why` 的问题永远要比 `What` 的问题要重要得多。

> 吐槽：老实说，专用的 `RabbitMQ, Apache Kafka` 消息队列可以替代 `Redis` 作为消息队列的部分，而使用 `Mongodb` 文档数据库可以替代 `Redis` 作为文档数据库的部分。因此从简单作为数据库上划分还是无法找到 `Redis` 的定位，因此下面从业务功能上来划分会更容易找到 `Redis` 在架构中的定位。 

## 11.1.从数库上划分

### 11.1.3.内存数据库

类似 `MySQL` 等数据库，把 `Redis` 当作内存中的数据库来使用也是不错的选择，但是一定要注意持久化的问题。这一点只需要知道对数据类型的操作和 `API` 即可，比较容易理解。

### 11.1.2.文档数据库

`Redis` 通常作为键值存储系统，而不是传统的文档数据库（如 `MongoDB`）。但可以通过存储 `JSON` 或类似的文档数据类型，将其用于模拟文档数据库。

*   **实现方式**：可以将文档存储为 `Redis` 的字符串（`String`）或哈希表（`Hash`）。
*   **用途**：适用于需要高性能读写、低延迟操作和实时数据处理的场景，特别是非结构化数据，且以键值对方式存储。
*   **例子**：将用户信息存储为 `JSON` 格式的字符串，或将对象的属性存储为哈希表。

### 11.1.3.向量数据库

**向量数据库** 是一种专门用于存储和查询向量（数字序列）的数据库，通常用于处理需要快速相似性搜索的非结构化数据（如文本、图像、音频等）。在这种数据库中，数据被转化为向量，并在向量空间中进行存储和检索。

*   **实现方式**：数据通过机器学习模型（如 `Word2Vec, BERT` 等）转化为向量后，存储在数据库中。查询时，数据库通过计算向量之间的距离或相似度，找到与查询向量最相似的数据。
*   **用途**：适用于需要基于相似性进行快速查询的场景，例如图像搜索、语义搜索、推荐系统等。向量数据库能高效地处理大规模数据集，并提供高效的相似性检索。
*   **例子**：将图像特征或文本嵌入（如文本的词向量）存储在向量数据库中，当用户查询时，数据库通过计算向量之间的相似度返回相关的图片或文本内容。

>   [!NOTE]
>
>   吐槽：机器学习的部分我学习的不多，待补充...

## 11.2.从功能上划分

### 11.2.1.缓存功能



### 11.2.2.排行榜功能



### 11.2.3.计数器功能



### 11.2.4.社交网络功能



### 11.2.5.简易消息队列功能

