# 1.数据类型

## 1.1.四大类型

### 1.1.1.值类型

| 值类型       | 描述                                                         | 默认值    |
| ------------ | ------------------------------------------------------------ | --------- |
| bool         | 布尔值 $[False, True]$                                       | False     |
| char         | 16 位 Unicode 字符 $[U+0000, U+ffff]$                        | '\0'      |
| sbyte/byte   | 8 位有符号整数 $[-128, 127]$/8 位无符号整数 $[0, 255]$       | 0         |
| short/ushort | 16 位有符号整数类型 $[-32 768, 32 767]$/16 位无符号整数类型 $[0, 65 535]$ | 0         |
| int/uint     | 32 位有符号整数类型 $ [-2 147 483 648, 2 147 483 647]$/32 位无符号整数类型 $[0, 4 294 967 295]$ | 0         |
| long/ulong   | 64 位有符号整数类型 $[-9 223 372 036 854 775 808, 9 223 372 036 854 775 807]$/64 位无符号整数类型 $[0, 18 446 744 073 709 551 615]$ | 0L/0      |
| float/double | 32 位单精度浮点型 $[-3.4 x 1038, + 3.4 x 1038]$/64 位双精度浮点型 $[(+/-)5.0 x 10-324, (+/-)1.7 x 10308]$ | 0.0F/0.0D |
| decimal      | 128 位精确的十进制值 $[\frac{-7.9 × 10^{28},\, 7.9 × 10^{28}}{10^{0到128}}]$ | 0.0M      |

### 1.1.2.引用类型

-   对象引用类型
-   动态引用类型
-   字符串类型

### 1.1.3.指针类型

### 1.1.4.可空类型



# 2.类型转化

-   隐式转化
-   显示转化
-   转化方法

# 3.面向对象

## 3.1.封装

### 3.1.1.装箱拆箱

### 3.1.2.访问限定符

*   **Pubilc** 任何公有成员可以被外部的类访问
*   **Private** 只有同一个类中的函数可以访问它的私有成员
*   **Protected** 该类内部和继承类中可以访问
*   **internal** 同一个程序集的对象可以访问
*   **Protected internal** 3 和 4 的并集，符合任意一条都可以访问

### 3.2.3.成员

#### 3.2.3.1.成员变量

-   只读属性
-   只写属性
-   自定义只读属性
-   自定义只写属性
-   属性可计算

#### 3.2.3.2.成员方法

-   按值传递
-   按引用传递（`ref`）
-   按输出传递（`out`）

-   构造方法
-   析构方法，无法被继承和重载???

## 3.2.继承

### 3.2.1.类继承

### 3.2.2.接口继承

## 3.3.多态

### 3.3.1.静态多态

-   函数重载
-   运算符重载

### 3.3.2.动态多态

抽象类内抽象方法和普通类内虚方法、抽象属性

# 4.数组

# 5.字符串

# 6.枚举

# 7.预处理指令

# 8.正则表达式

# 9.异常机制

```c#
// 异常语法
throw 异常;

try {
   // 引起异常的语句
}
catch(ExceptionName e1) {
   // 错误处理代码
}
catch(ExceptionName e2) {
   // 错误处理代码
}
...
catch(ExceptionName eN) {
   // 错误处理代码
}
finally {
   // 要执行的语句
}
```

# 10.文件 IO

# 11.规定特性

特性可以为程序元素（类，方法，属性）添加元数据，这些可以在运行时或编译时提供额外的信息，允许开发者在代码中嵌入描述性数据。`C#` 的特性和 `Cpp` 的属性是一样的，都是 `Attributes`，也都有类似的功能。

## 11.1.预定义特性

*   AttributeUsage：`[AttributeUsage(Targets, AllowMultiple, Inherited)]` 用于指定特性可以怎样应用在哪些程序元素
    *   Targets：指定特性可以应用于哪些元素（如类、方法、属性等）
    *   AllowMultiple：指示是否可以在同一元素上多次应用该特性
    *   Inherited：指示特性是否可以被派生类继承
*   Conditional：`[Conditional(conditionalSymbol)]` 
*   Obsolete：`[Obsolete("...", bool)]` 用于标记某个类、方法或属性为过时，提示开发者不再使用它

## 11.2.自定义特性

要定义自定义特性，需要创建一个类，并从 `System.Attribute` 类继承。可以添加构造函数和属性，以便在使用特性时传递数据。

```c#
// 定义自定义特性
using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
public class MyCustomAttribute : Attribute {
    public string Description { get; }
    public int Version { get; }

    // 构造函数
    public MyCustomAttribute(string description, int version) {
        Description = description;
        Version = version;
    }
}
```

在这个示例中，`MyCustomAttribute` 特性可以应用于类和方法，包含两个属性：`Description` 和 `Version`。

一旦定义了自定义特性，就可以将其应用于类、方法、属性等。

```c#
// 使用自定义特性
[MyCustomAttribute("This is a sample class", 1)]
public class SampleClass
{
    [MyCustomAttribute("This is a sample method", 2)]
    public void SampleMethod()
    {
        // 方法实现
    }
}
```

在这个示例中，`MyCustomAttribute` 被应用于 `SampleClass` 类和 `SampleMethod` 方法。

# 12.反射

# 13.索引器

# 14.委托和事件

## 14.1.委托

`C#` 中的委托 `delegate` 类似于 `C/C++` 中函数的指针，是存有某个方法的引用的一种引用类型变量，引用可在运行时被改变。

```c#
// 使用委托来托管调用
using System;

delegate int NumberChanger(int n);

namespace DelegateAppl {
   class TestDelegate
      static int num = 10;
      public static int AddNum(int p) {
         num += p;
         return num;
      }

      public static int MultNum(int q) {
         num *= q;
         return num;
      }
      public static int getNum() {
         return num;
      }

      static void Main(string[] args) {
         // 创建委托实例
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         // 使用委托对象调用方法
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```

## 14.2.事件

事件是基于委托的一个特殊类型，用于实现发布-订阅模式。事件允许一个对象（发布者）通知其他对象（订阅者）某个事件的发生。事件通常使用 `event` 关键字声明，并且它的类型是一个委托。通过将委托作为事件的类型，`C#` 确保所有订阅该事件的方法都符合这个签名。

# 15.集合

-   动态数组
-   哈希表
-   排序列表
-   堆栈
-   队列
-   点阵列

# 16.泛型

# 17.匿名方法

## 17.1.Lambda

## 17.2.匿名方法

# 18.多线程

# 19.不安全代码

