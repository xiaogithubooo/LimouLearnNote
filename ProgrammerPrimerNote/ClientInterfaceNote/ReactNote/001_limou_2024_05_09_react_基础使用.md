果本系列文章对您有帮助，可以 [star 一下我的 limou-learn-note](https://github.com/xiaogithubooo/LimouLearnNote)，求求惹(๑＞ ＜)☆♡~**

**叠甲：以下文章主要是依靠我的实际编码学习中总结出来的经验之谈，求逻辑自洽，不能百分百保证正确，有错误、未定义、不合适的内容请尽情指出！**

[TOC]

>   [!NOTE]
>
>   概要：...

>   [!NOTE]
>
>   资源：...

------

# 1.React 的下载

`React` 也是一个 `JS` 库，和 `Vue` 是类似，不过这个库开发起来要比 `Vue` 更加快速，两者都是为了构建单体应用程序的 `SPA` 的 `JS` 库。不过我需要在您有 `Vue` 的基础上再进一步学习 `React`，这样后面我们才能对比出两者的区别（这点很重要）。

因此我们只需要下载 `React` 的 `JS` 代码就可以使用 `React` 了，我们先不使用脚手架，暂时使用最原生的开发方式。[这里提供一个官方文档，里面提供了最新的源代码链接](https://react.docschina.org/learn/installation)，这里我只展示我此时编写文档时最新的链接（下面的三个链接都在官方提供的 `HTML` 页面中）。

```html
<!-- 源代码链接 -->
<script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->

<!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->

```

当然您也可以选择从远端直接下载源代码，顺着链接把代码保存到本地文件中进行引用即可，这里我保持上面的引入方式。

>   [!WARNING]
>
>   注意：本教程采用的 `React` 版本为 `React18`，可能和旧版本有些语法上的不同...

# 2.React 的第一份代码

```jsx
<!-- React 的第一份代码 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->

    <!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->
    </head>
<body>
    <!-- 这个块是 React 应用的一个挂载点 -->
    <div id="example"></div>

    <script type="text/babel"> <!-- 标记 JavaScript 代码块为使用了 JSX 语法的代码 -->
    // 创建一个名为 App 的应用
    function App() {
        return <h1>Hello, React!</h1>; // 这里其实就是 JSX 语法, 允许您在 JS 中编写 HTML 结构, 这里的 JS 代码返回了一个 <h1> 元素
    }

    // 寻找挂载点, 创建一个名为 root 的根节点
    const root = ReactDOM.createRoot(document.getElementById("example")); // 其实就是寻找 DOM 页面中 id=example 的元素
    
    // 挂载
    root.render(<App />); // 使用根节点 root 来渲染 App 应用, React 将调用 App() 将结果插入到挂载点中
    </script>
</body>
</html>

```

![image-20240923135756886](./assets/image-20240923135756886.png)

上述代码如果您有点难以理解，就按下面这样简单理解：

1.   创建挂载点 = 创建空容器
2.   编写应用 = 编写函数
3.   创建根节点 = 寻找 `DOM` 元素
4.   挂载 = 渲染

>   [!NOTE]
>
>   吐槽：如果您学过 `Linux` 的文件挂载，应该能很快理解上面的过程，因为这和将文件系统挂载到挂载点的逻辑是很类似的...

# 3.React 的组件

## 3.1.组件的创建

利用 `React 元素` 可以构建出一个 `React 应用`，而 `React 元素` 是由 `JSX` 编写的一种不可变对象，一旦创建就不可改变。下述 `React DOM` 最终可以通过 `ReactDOM 库` 来映射到 `浏览器 DOM`，最终渲染到浏览器上。

```jsx
const element = <p>这是一个 React 元素</p>;
```

>   [!IMPORTANT]
>
>   补充：上述这种既不像字符串又不像 `HTML` 的语法就是 `JSX`，这种语法是通过 `JS` 来实现的，`React` 通过大量的 `JSX` 声明来创建 `React 元素`，进而构建出用户界面（完全可以说 `JSX` 就是为了 `React` 而设计的）。

>   [!IMPORTANT]
>
>   补充：`React 元素` 几乎都是由 `JSX` 编写的，尽管 `React` 提供了无需使用 `JSX` 的纯 `JS` 用法来编写 `React 应用`，但是一般不推荐这么做...


>   [!IMPORTANT]
>
>   补充：`React DOM` 可以看作一种 `虚拟 DOM`，最终是一定要转化为 `物理 DOM` 也就是 `浏览器 DOM`...

去除掉函数，我们尝试改写一下我们之前的第一份代码，让您直观理解整个编写过程。

```jsx
<!-- 改写 React 的第一份代码 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->
    
    <!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->
</head>
<body>
    <!-- 这个块是 React 应用的一个挂载点 -->
    <div id="example"></div>

    <script type="text/babel">
    // 相当于创建一个匿名的应用, 这个匿名的 React 应用目前只由一个 React 元素构成
    const element = <p>这是一个 React 元素</p>;

    // 寻找挂载点, 并且创建一个名为 root 的根节点
    const root = ReactDOM.createRoot(document.getElementById("example")); // 其实就是寻找 DOM 页面中 id=example 的元素
    
    // 挂载
    root.render(element); // 使用根节点 root 来渲染 element 应用, React 将自动将 element 元素转化为应用(这只是一种粗糙理解, 实际可能不是这么做的, 我这种表述只是方便学习), 将结果插入到挂载点中
    </script>
</body>
</html>

```

![image-20240923135747858](./assets/image-20240923135747858.png)

>   [!CAUTION]
>
>   警告：上述所谓的“匿名应用、元素转化为应用”只是我的个人说法，方便学习而已...

## 3.2.组件的更新

`React` 元素都是不可变得，包括内容和属性，更新界面的唯一办法就是创建新的元素再次传入 `root.render()` 进行重新挂载，这里给一个在页面上实时显示时间的例子，和我们第一份代码一样，照猫画虎。

```jsx
<!-- 更新组件(正常) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->
    
    <!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->
</head>
<body>
    <!-- 挂载点 -->
    <div id="example"></div>

    <script type="text/babel">
    // 寻找挂载点, 创建根节点
    const root = ReactDOM.createRoot(document.getElementById("example"));
    
    // 编写 Tick 应用
    function Tick() {
        const element = (
        <div>
            <h1>Hello, React!</h1>
            <h2>现在是 {new Date().toLocaleTimeString()}.</h2>
        </div>
        ); // 这里的 element 还是算一个 React 元素

        // 实时挂载
        root.render(element); // 这是一种一边创建应用一边挂载的写法, 也是非常常见的, 这意味应用可以在调用的时候被渲染, 而不是交给外部的渲染
    }
    
    setInterval(Tick, 1000); // 每嗝 1 s 就调用 Tick()
    </script>
</body>
</html>

```

甚至封装得更严密一些，可以这么写：

```jsx
<!-- 更新组件(封装) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->
    
    <!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->
</head>
<body>
    <!-- 挂载点 -->
    <div id="example"></div>

    <script type="text/babel">
    // 编写 Tick 应用
    function Tick() {
        // 寻找挂载点, 创建根节点
        const root = ReactDOM.createRoot(document.getElementById("example"));
        
        // 堆积 React 元素
        const element = (
        <div>
            <h1>Hello, React!</h1>
            <h2>现在是 {new Date().toLocaleTimeString()}.</h2>
        </div>
        ); // 这里的 element 还是算一个 React 元素

        // 实时挂载
        root.render(element); // 这是一种一边创建应用一边挂载的写法, 也是非常常见的, 这意味应用可以在调用的时候被渲染, 而不是交给外部的渲染
    }
    
    // 每嗝 1 s 就调用 Tick()
    setInterval(Tick, 1000);
    </script>
</body>
</html>

```

如果希望提高代码可维护性，可以进行解耦：

```jsx
<!-- 更新组件(解耦) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->
    
    <!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->
</head>
<body>
    <!-- 挂载点 -->
    <div id="example"></div>

    <script type="text/babel">
        // 分离骨架, 本质也是一个应用(子应用: 控制界面显示)
        function Clock(props) {
            return (
                <div>
                    <h1>Hello, React!</h1>
                    <h2>现在是 {props.date.toLocaleTimeString()}.</h2>
                </div>
            );
        }

        // 编写 Tick 应用(父应用: 控制数据传入)
        function Tick() {
            // 寻找挂载点, 创建根节点
            const root = ReactDOM.createRoot(document.getElementById("example"));
            
            // 实时挂载
            root.render(<Clock date={new Date()} />); // 这是一种一边创建应用一边挂载的写法, 也是非常常见的, 这意味应用可以在调用的时候被渲染, 而不是交给外部的渲染
        }

        // 每嗝 1 s 就调用 Tick()
        setInterval(Tick, 1000);
    </script>
</body>
</html>

```

另外 `React JSX` 也可以把核心代码封装在一个 `.js` 文件中，然后交给其他的 `HTML` 页面中使用 `<script type="text/babel" src="xxx.js"></script>` 的方式引入，并且借此使用组件。

```jsx
// anonymity_app.js
// 分离骨架, 本质也是一个应用(子应用: 控制界面显示)
function Clock(props) {
    return (
        <div>
            <h1>Hello, React!</h1>
            <h2>现在是 {props.date.toLocaleTimeString()}.</h2>
        </div>
    );
}

// 编写 Tick 应用(父应用: 控制数据传入)
function Tick() {
    // 寻找挂载点, 创建根节点
    const root = ReactDOM.createRoot(document.getElementById("example"));
    
    // 实时挂载
    root.render(<Clock date={new Date()} />); // 这是一种一边创建应用一边挂载的写法, 也是非常常见的, 这意味应用可以在调用的时候被渲染, 而不是交给外部的渲染
}

// 每嗝 1 s 就调用 Tick()
setInterval(Tick, 1000);
```

```html
<!-- test.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script> <!-- React 核心构建界面库: 组件声明, 状态管理, 生命周期... -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <!-- ReactDOM 组件渲染库: 把 React 组件实时渲染到浏览器 DOM 上, 处理和浏览器渲染相关的工作 -->
    
    <!-- 不要使用这个链接到实际生产中(原因我们后面再来提及): -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- Babel Standalone 即时 JSX 语法编译库: 这个链接指向 Babel 的源代码, 这个源代码用用于编译现代 JS 代码和 JSX 代码, JSX 是 JS 代码的拓展, 如果不使用这个链接就会导致代码中的 JSX 语法无法被正确转化, 因此无法被浏览器渲染 -->
</head>
<body>
    <!-- 挂载点 -->
    <div id="example"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

好了，到这就可以了，相信您对于 `React` 的基本代码编写还是比较熟悉了。

>   [!IMPORTANT]
>
>   补充：实际上还能结合 `ES6` 的类写法，不过为了不给您添加负担，我把这部分略过...

## 3.3.组件的模板

`JSX` 看起来就像是嵌入到 `JS` 中的 `HTML`，不过内部编写的标签和 `HTML` 是有很大的不同的。一个 `JSX` 如果有多个标签组成，就需要一个根标签进行包裹。`JSX` 的标签中还可以使用 `{}` 模板填写 `JS` 代码，这点很像一些具有模板的框架（`Falsk` 和 `Django` 包括 `Vue` 中就有使用类似的技术，功能也是类似的）

```jsx
// 演示 JSX 的一些特点
<script>
const i = 0; // 由于无法在 {} 中使用 if-else 的 JS 代码, 所以这里只能使用三元表达式
const element = (
    <div>
        <ul>
            <li>项目1</li>
            <li>项目2</li>
            <li>项目{2+1}</li>
            <li>{i == 0 ? 'yes' : 'no'}</li>
        </ul>
    </div>
); // 上面多个标签组合时, 最外面总有且只有一个根元素(这里是 div 元素)
</script>
```

`JSX` 还允许模板中存在数组，这方便我们后续对一个数组进行操作后再进行渲染，这里只是简单用一下。

```jsx
// 模板中的数组
var contentArr = [
  <img src="https://example.com/image1.jpg" alt="Image 1" />,
  <p>这是一段关于图片的描述。</p>,
  <img src="https://example.com/image2.jpg" alt="Image 2" />,
  <p>这是一段关于第二张图片的描述。</p>,
];

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <div>{contentArr}</div>
);

```

`JSX` 的注释可以写在 `{/* ... */}` 中。

## 3.4.组件的属性

`React 应用` 有几个比较重要的属性（其实应该是 `JSX` 的属性），这里统一给您讲述一下：

-   `React DOM` 把 `className` 作为类属性名称，而不是直接使用 `class`

-   `style` 样式属性，`React` 也推荐您使用内联模式来赋予样式，样式的语法和 `CSS` 是很类似的（比较大的区别是 `CSS` 使用连字符命名，而 `JSX` 使用驼峰命名，并且不支持伪类等语法）

-   `data-xxx` 自定义属性（后面进行演示），自定义的属性应该使用 `data-` 作为前缀才能使用

```jsx
// anonymity_app.js
var aStyle = {
    fontSize: 100,
    color: '#FF0000'
};
const element = <p className="elem" style={aStyle}>这是一个 React 元素{/*这是不显示到浏览器上的注释*/}</p>;
const root = ReactDOM.createRoot(document.getElementById("example"));
root.render(element);

```

```html
<!-- test.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="example"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

![image-20240923145849610](./assets/image-20240923145849610.png)

## 3.5.组件的类别

>   [!NOTE]
>
>   吐槽：应用不过就是大的组件罢了，这两个词混用有时候也挺合理的...

`React` 的组件主要分为两种：

-   函数组件，使用参数 `props` 获得属性值
-   类组件，继承自 `React.Component.属性字段` 使用 `this.props.属性字段` 获取属性值

### 3.5.1.函数组件

```jsx
// anonymity_app.js: 定义函数组件
var aStyle = {
    fontSize: 100,
    color: '#FF0000'
};

// 定义函数组件
function Show(props) {
    return (
        <p className="elem" style={aStyle}>message: {props.message}{/* 这个 props 可以用来读取属性值 */}</p>
    );
}

const root = ReactDOM.createRoot(document.getElementById("example"));
root.render(<Show message="This is a info message."/>); // 这里的 <Show message=""> 中的 message 已经是一个 React 应用的属性了, 不用 data- 前缀, 这个前缀是加给 JSX 的

```

```html
<!-- test.html: 使用函数组件 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="example"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

### 3.5.2.类组件

```jsx
// anonymity_app.js: 定义类组件
var aStyle = {
    fontSize: 100,
    color: '#FF0000'
};

// 定义类组件
class Show extends React.Component {
    render() { // render() 用来定义返回组件的渲染内容
        return (
            <p className="elem" style={aStyle}>
                message: {this.props.message} {/* 通过 this.props 访问属性值 */}
            </p>
        );
    }
}

const root = ReactDOM.createRoot(document.getElementById("example"));
root.render(<Show message="This is a info message."/>); 

```

```jsx
<!-- test.html: 使用类组件 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="example"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

>   [!WARNING]
>
>   注意：在 `React18` 中，函数组件也几乎成为了主流，我建议您使用函数组件（这种说法只适用于 `React16` 在函数组件中引入 `Hook` 之后的版本）。

>   [!IMPORTANT]
>
>   补充：`React 应用` 中函数组件通常使用大驼峰法，在使用的时候也和函数名一样。

## 3.6.组件的复合

多个组件可以复合在一起，也就是说多个 `React 应用` 可以复合出更复杂的 `React 应用`，我们这里把之前实现的两个组件 ` Tick 和 Show` 复合为一个 `App` 组件。

```jsx
// anonymity_app.js: 定义复合组件
var aStyle = {
    color: '#FF0000'
};

// 编写 Tick 应用
function Tick() {
    const tip = ReactDOM.createRoot(document.getElementById("tip"));

    const element = (
    <div>
        <h1>Hello, React!</h1>
        <h2>现在是 {new Date().toLocaleTimeString()}.</h2>
    </div>
    );

    tip.render(element);
}

// 编写 Show 应用
function Show(props) {
    return (
        <p style={aStyle}>message: {props.message}</p>
    );
}

// 编写 App 应用
function App() {
    setInterval(Tick, 1000); // 每嗝 1 s 就调用 Tick()
    return (
        <div>
            <div id="tip"></div>
            <div id="show"><Show message="This is a info message." /></div>
        </div>
    );
}

const app = ReactDOM.createRoot(document.getElementById("app"));
app.render(<App />); // 这里的 <Show message=""> 中的 message 已经是一个 React 应用的属性了, 不用 data- 前缀, 这个前缀是加给 JSX 的

```

```html
<!-- test.html: 使用复合组件 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

![image-20240923173226947](./assets/image-20240923173226947.png)

## 3.7.组件的状态

### 3.7.1.函数组件的状态

`useState` 就是组件的使用状态，这是一个 `Hook(钩子函数)`，`userState hook` 允许函数组件中使用状态管理功能。我们前面不是提到 `React` 创建的 `React 元素` 是由 `JSX` 编写的一种不可变对象么？但是我们一旦发生数据改变（状态改变）就需要重新手动挂载对象，这未免太过于麻烦，因此就有了上面这个一个钩子函数。编写格式如下，每次调用修改函数进行修改时，就会导致变量被修改，并且自动重新挂载本组件：

```jsx
const [变量, 修改函数] = React.useState(初始值); // const 表示变量要用修改函数修改而无法直接被赋值修改
```

我们编写一个计时器复合到我们之前的复合应用代码中。

```jsx
// anonymity_app.js: 函数组件的状态
var aStyle = {
    color: '#FF0000'
};

// 编写 Tick 应用
function Tick() {
    const root = ReactDOM.createRoot(document.getElementById("tip"));

    const element = (
    <div>
        <h1>Hello, React!</h1>
        <h2>现在是 {new Date().toLocaleTimeString()}.</h2>
    </div>
    );

    root.render(element);
}

// 编写 Show 应用
function Show(props) {
    return (
        <p style={aStyle}>message: {props.message}</p>
    );
}

// 编写 Counter 应用
function Counter() {
    const [count, setCount] = React.useState(0);

    return (
        <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}

// 编写 App 应用
function App() {
    setInterval(Tick, 1000); // 每嗝 1 s 就调用 Tick()
    return (
        <div>
            <div id="tip"></div>
            <div id="show"><Show message="This is a info message." /></div>
            <div id="counter"><Counter /></div>
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById("app"));
root.render(<App />); // 这里的 <Show message=""> 中的 message 已经是一个 React 应用的属性了, 不用 data- 前缀, 这个前缀是加给 JSX 的

```

```html
<!-- test.html: 函数组件的状态 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

![image-20240923201734597](./assets/image-20240923201734597.png)

另外我们之前不是有一个需要重复挂载的 `Tick` 应用么，改写为状态的写法试试？

```jsx
// anonymity_app.js: 函数组件的状态
var aStyle = {
    color: '#FF0000'
};

// 编写 Tick 应用
function Tick() {
    const [time, setTime] = React.useState(new Date().toLocaleTimeString());
    
    React.useEffect(() => { // 这是一个副作用钩子函数, 以后我们详细解释
        const interval = setInterval(() => { // 设置一个定时器
            setTime(new Date().toLocaleTimeString()); // 每秒修改一次时间
        }, 1000);
    }, [/* 依赖项 */]);

    return (
        <div>
            <h1>Hello, React!</h1>
            <h2>现在是 {time}.</h2>
        </div>
    );
}

// 编写 Show 应用
function Show(props) {
    return (
        <p style={aStyle}>message: {props.message}</p>
    );
}

// 编写 Counter 应用
function Counter() {
    const [count, setCount] = React.useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}

// 编写 App 应用
function App() {
    return (
        <div>
            <div id="tip"><Tick /></div>{/* 其实这里直接写标签的写法也间接证明了一般挂载点只有一个即可, 没必要像我们之前写的挂载两次 */}
            <div id="show"><Show message="This is a info message." /></div>
            <div id="counter"><Counter /></div>
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById("app"));
root.render(<App />); // 这里的 <Show message=""> 中的 message 已经是一个 React 应用的属性了, 不用 data- 前缀, 这个前缀是加给 JSX 的

```

```html
<!-- test.html: 函数组件的状态 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

![image-20240923201758853](./assets/image-20240923201758853.png)

### 3.7.2.类组件的状态

同样的，类组件也有类似的操作，并且实际上类组件的状态要比函数组件的状态要先推出，但是写起来可麻烦了...上述复合应用代码可以改写如下：

```jsx
// anonymity_app.js: 类组件的状态
var aStyle = {
    color: '#FF0000'
};

// 编写 Tick 类组件
class Tick extends React.Component {
    constructor(props) { // 构造函数
        super(props);
        this.state = { time: new Date().toLocaleTimeString() }; // 初始状态
    }

    componentDidMount() { // 模块渲染后
        this.interval = setInterval(() => {
            this.setState({ time: new Date().toLocaleTimeString() }); // 设置状态
        }, 1000);
    }

    componentWillUnmount() { // 模块将卸载
        clearInterval(this.interval);
    }

    render() {
        return (
            <div>
                <h1>Hello, React!</h1>
                <h2>现在是 {this.state.time}.</h2>
            </div>
        );
    }
}

// 编写 Show 类组件
class Show extends React.Component {
    render() {
        return (
            <p style={aStyle}>message: {this.props.message}</p>
        );
    }
}

// 编写 Counter 类组件
class Counter extends React.Component { // 和上面的应用是类似的
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }

    incrementCount = () => {
        this.setState({ count: this.state.count + 1 });
    };

    render() {
        return (
            <div>
                <p>Count: {this.state.count}</p>
                <button onClick={this.incrementCount}>Increment</button>
            </div>
        );
    }
}

// 编写 App 类组件
class App extends React.Component {
    render() {
        return (
            <div>
                <div id="tip"><Tick /></div>
                <div id="show"><Show message="This is a info message." /></div>
                <div id="counter"><Counter /></div>
            </div>
        );
    }
}

const root = ReactDOM.createRoot(document.getElementById("app"));
root.render(<App />);

```

```html
<!-- test.html: 类组件的状态 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <script type="text/babel" src="./anonymity_app.js"></script>
</body>
</html>

```

## 3.8.组件的接口

## 3.9.组件的生命

# 4.React 的事件

# 5.React 的列表

# 6.React 的路由

# 7.React 的 Ajax

# 8.React 的样式



---

>   [!NOTE]
>
>   结语：...

**如果本系列文章对您有帮助，可以 [star 一下我的 limou-learn-note](https://github.com/xiaogithubooo/LimouLearnNote)，求求惹(๑＞ ＜)☆♡~**