# 1.第一份代码

我们先来根据 `Vue` 的设计架构编写第一份代码，主要是来了解视图和模型是怎么回事，以及关于 `vue.js` 的引入安装过程。

```html
<!-- 第一份 Vue 代码 -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <!-- 编写视图 -->
        <div id="app"> <!-- 这里必须写明对应的 id 来绑定 vue 应用 -->
            <h1>{{ message1 + ' ' + message2 }}</h1>  <!-- {{}} 可以直接获取模型中的选项数据 -->
            <p>{{ method() }}</p> <!-- {{}} 内可以直接调用模型中的选项方法, 一定要带上括号 -->
            <input type="text" v-model="message1"> <!-- 可以通过属性的方式来获取数据, 这里的 v-model 实际上被转化为 value -->
            <input type="button" v-model="message2">
        </div>

        <!-- 定义模型 -->
        <script>
            var data = { message1: 'Hello', message2: 'Vue!' }
            var vae = new Vue({ // 每个 vue 应用都需要通过实例化 Vue 来实现, 然后在实现内部加上 Vue 的相关选项
                el: '#app', // el 值代表模型对应到 DOM 中的 id 值
                data: data, // data 值代表模型中的所有数据
                methods: { // methods 值代表模型中的所有方法
                    method: function() {
                        return this.message1 + " I'm limou3434!";
                    }
                }
            })
        </script>
    </body>
</html>
```

>   吐槽：不知道为什么，`<script>` 标签编写的模型必须写在视图的后面，否则视图无法工作，我猜测是 `vue.js` 库是对原有 `.html` 进行动态修改的结果，而不是惰性加载...

# 2.自定属性和保留属性

`Vue` 允许 ` var vue= new Vue()` 在 `data` 内自定义属性，但是 `vue` 本身也有自己的保留属性。保留属性如果需要被其他 `JS` 代码使用，就需要用 `$` 字符起头属性。

```html
<!-- 使用 $ 来区分保留的属性 -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="vue_det">
            <h1>name : {{name}}</h1>
            <h1>url : {{url}}</h1>
            <h1>age : {{age}}</h1>
        </div>

        <script type="text/javascript">
            // 我们的数据对象
            var data = { name: "limou", url: "www.limou3434.com", age: 18 }
            var vm = new Vue({ el: '#vue_det', data: data })

            document.write(vm.$data === data) // true
            document.write("<br>")
            document.write(vm.$data.$name === data.$name) // true
            document.write("<br>")
            document.write(vm.$el === document.getElementById('vue_det')) // true
        </script>
    </body>
</html>
```

>   补充：但是数据本身不需要使用 `$`，直接使用 `Vue` 对象引用即可。

# 3.响应系统

`Vue` 的响应式系统是指 `vue.js` 提供的一套机制，用于追踪数据的变化并自动更新相关的视图。当 `Vue` 实例中的数据发生变化时，`Vue` 会自动更新页面上显示的内容，以保持数据和视图的一致性。这种机制使得开发者能够更加专注于业务逻辑，而不需要手动更新 `DOM`。

```html
<!-- 尝试体验响应系统(从模型到视图的响应) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<body>
    <!-- 同时可以看到视图的结果是最后一次数据修改的结果 -->
    <div id="vue_det">
        <h1>name : {{name}}</h1>
        <h1>url : {{url}}</h1>
        <h1>age : {{age}}</h1>
    </div>

    <script type="text/javascript">
        var data = { name: "limou", url: "www.limou3434.com", age: 18}
        var vue = new Vue({ el: '#vue_det', data: data })

        // data 和 vue 引用的数据其实是相同的对象
        document.write(vue.name === data.name) // true
        document.write("<br>")

        // 设置 data 内部数据的会影响到 vue 数据
        vue.name = "gimou"
        document.write(data.name + "<br>") // gimou

        // 设置 vue 内部数据的会影响到 data 数据
        data.age = 20
        document.write(vue.age) // 20
    </script>
</body>
</html>
```

```html
<!-- 尝试体验响应系统(从视图到模型的响应) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<body>
    <div id="app">
        <p>{{ message }}</p>
        <input v-model="message">
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                message: 'Runoob!'
            }
        })
</script>
</body>
</html>
```

>   补充：`v-model` 通常用来给 `input, select, textarea, checkbox, radio` 等表单控件元素上创建双向数据绑定，同步更新 `value` 值和对应模型内的数据值。

上述的响应式，主要是体现在对数据的响应同步上，无论是使用特殊属性（例如 `v-model`），还是使用模板语法（例如 `{{}}`），都可以达到对应的效果。

# 4.模板语法

## 4.1.数据渲染

`Vue` 的核心是允许您采用简洁的模板语法来声明式的将数据渲染进 `DOM` 的系统，而无需使用复杂的 `DOM API`，而达到这一简化操作的主要工具就是使用模板语法配合响应系统。

-   普通文本，最简单的方法就是直接使用 `{{ 数据 }}` 把数据绑定进去
-   无属性 `HTML` 文本，需要使用标签属性 `v-html="<x>...</x>"` 输出 `HTML` 代码
-   有属性 `HTML` 文本，需要使用标签属性 `v-bind:属性="字面值/数据, ..."` 绑定属性的值（使用属性绑定的时候可以使用 `v-bind:属性="{'属性值1':字面值/数据1, '属性值2':字面值/数据2, ...}"` 中的数据值是否为真来控制该属性值是否绑定给标签，若为 `false` 则不会绑定该属性（因此也可以借此来编写有多个 `class` 属性的标签）。还可以把这些键值对直接作为一个整体，使用模型先存储起来再使用、通过计算方法返回、使用三元表达式、直接内联样式、设置样式对象为一个数据...）
-   `JS` 表达式文本，无需用到什么操作，只需要在 `{{}}` 内部直接写 `JS` 表达式即可对数据进行操作

```html
<!-- 尝试使用模板语法 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<style>
    .myclass { /* 类选择器 */
        background: #444;
        color: #eee;
    }
</style>
<body>
    <div id="app"> <!-- 注意 Vue 只允许绑定到唯一的 DOM 元素 -->
        <!-- 文本 -->
        <p>{{ message1 }}</p>
        <!-- 无属性 HTML 文本 -->
        <div v-html="message2"></div>
        <!-- 有属性 HTML 文本 -->
        <label for="r">修改颜色</label><input type="checkbox" v-model="message3" id="r"> <!-- 以防遗忘这里的 for 就是和左边的 id 绑定焦点 -->
        <div v-bind:class="{'myclass': message3}">有属性标签</div><br> <!-- 注意上一行的 v-model 是双向绑定的, 因此选项的改动会导则模型也改动, 最终导致这里的 class 属性被设置, class 是 v-bind 的参数 -->
        <!-- JS 表达式 -->
        {{ message4 ? 'YES' : 'NO' }}<br>
        {{ message1.split('').reverse().join('') }}
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                message1: '纯文本',
                message2: '<h1>无属性标签</h1>',
                message3: false,
                message4: true
            }
        })
    </script>
</body>
</html>
```

>   补充：`v-xxx` 这种属性也被称为 **指令**，而 `v-xxx:arg` 中的 `arg` 也被称为指令的 **参数**。注意，由两个常见的属性需要您注意。
>
>   -   `v-on:` 缩写为 `@`，主要用于监听 `DOM` 事件，并在事件触发时执行相应的 `Vue` 实例方法或 `JavaScript` 表达式
>   -   `v-bind:` 缩写为 `:`，主要用于动态地绑定 `HTML` 元素的属性或者组件
>
>   而 `v-model="xxx"` 实际上是 `v-bind:value="xxx"` 和 `v-on:input="xxx = $event.target.value"` 两者的简化，前者负责填入 `value` 属性值，后者负责实现数据双向绑定在监听到 `input` 事件时将表单控件的值更新到属性值。
>
>   当用户在 `input` 元素中输入内容时，会触发 `input` 事件。这个事件会传递一个事件对象 `$event`，通过 `$event.target.value` 可以获取到 `input` 元素的当前值。
>
>   关于 `v-on` 的使用，这里还不是特别频繁，本文章后续将会进行详解和实践...

>   补充：由于可以通过 `v-bind` 修改标签的属性，因此通过对标签的动态绑定就可以让标签的样式动态修改。

修饰符是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。待补充...

## 4.2.过滤器

有些时候，有些数据需要遵从一点的格式进行过滤再进行显示，直接使用函数对文本处理又有些繁琐，干脆就使用过滤器来简化一些代码（实际上过滤器本质上也是一种 `JS` 函数）。

```html
<!-- 尝试使用过滤器 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<body>
<div id="app">
    <p>{{ data1 | currency('€') }}</p>
    <p>{{ data2 | capitalize }}</p>
</div>

<script type="text/javascript">
    // 我们的数据对象
    var vm = new Vue({
        el: '#app',
        data: {
            data1: '18.12',
            data2: 'limou'
        },
        filters: {
            currency: function (value, symbol) {
                if (isNaN(value)) return ''
                let num = parseFloat(value) // 将字符串转换为数字
                symbol = symbol || '$' // 检查参数是否传递，若未传递则使用默认值
                return symbol + num.toFixed(2) // 保留两位小数并返回
            },
            capitalize: function (value) {
                if (!value) return ''
                value = value.toString()
                return value.charAt(0).toUpperCase() + value.slice(1)
            }
        }
    })
</script>
</body>
</html>
```

>   补充：`|` 可以连续多次传递使用，也就是说在一个 `{{}}` 中可以有多个 `|`，例如 `{{ data1 | data2 | data3 }}`。

>   补充：另外过滤器不会影响数据的改变，只会影响数据的拷贝也就是参数的改变（除非在过滤器内部直接把数据改了）。

>   吐槽：类似的语法糖我第一次应该是 `shell` 的管道符和 `Cpp` 较高版本中的管道符，作用也挺类似...

# 5.控制流

不出意料，控制流也可以使用 `v-xxx` 的指令来实现，也就是 `v-if="", else-if="", v-else-if="", v-for=""`。

```html
<!-- 尝试使用控制流 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<body>
    <div id="app">
        <button @click="toggleHeader">显示开关</button>
        <h2 v-if="showEnable">标题</h2>

        <ul v-if="showEnable">
            <li v-for="item in items" :key="item.id">
                {{ 'id: ' + item.id + ', ' + 'item: ' + item.name }}
            </li>
        </ul>
        <div v-else> <!-- 其实还有一个 v-else-if -->
            <p>内容已被隐藏</p>
        </div>
    </div>

    <script>
        var app = new Vue({
            el: '#app',
            data: {
                showEnable: true,
                items: [
                    { id: 1, name: 'Item 1' },
                    { id: 2, name: 'Item 2' },
                    { id: 3, name: 'Item 3' }
                ]
            },
            methods: {
                toggleHeader: function () {
                    this.showEnable = !this.showEnable;
                }
            }
        });
    </script>
</body>
</html>
```

>   补充：`v-show=""` 可以直接根据布尔值来达到是否显示标签的目的。

>   补充：还有一种控制流的使用形式就是使用模板。
>
>   ```html
>   <!-- 使用模板 -->
>   {{#if ok}}
>     <h1>Yes</h1>
>   {{/if}}
>   ```
>

# 6.应用关键属性

之前我们关顾着快速使用了，关于 `new Vue()` 中 `Vue()` 的内部属性还没怎么详细说明，现在重新梳理一下。

## 4.1.挂载属性(el)

这里的 `#app` 其实是一个 `CSS` 选择器，用来定位页面中的某个元素，`Vue` 实例将会控制这个元素及其内部，您其实有多种选择。

1.   使用 `id` 选择器 `el: '#id'` 来指定一个标签为挂载点
2.   使用 `class` 选择器 `el: '.class'` 来指定一个类的所有标签作为挂载点
3.   使用属性选择器 `el: '[attribute]'` 来指定一个元素的属性作为挂载点（挂载到第一个具有该属性的元素上）
4.   使用标签选择器 `el: 'tag'` 可以直接使用 `HTML` 标签名作为挂载点
5.   使用 `DOM` 元素选择器 `el: dom` 可以直接传入一个使用 `DOM API` 获取到的 `DOM` 元素（变量）作为挂载点
6.   使用动态绑定可通过 `el: JS变量` 来动态地指定挂载点（此时的 `JS` 变量可以动态修改为上面的任意一种方法）

## 4.2.数据属性(data)

数据属性也就是 `data` 属性，内部可以存储 `{data1: 1, data2: "str", data3: 3.14}` 等 `<key, value>` 数据，可以通过 `{{ key }}` 的形式在标签内部直接被访问，也可以通过标签的属性直接填入 `"key"` 属性值。

>   注意：不要忘记数据属性是具有 `Vue` 的一个强大特征之一，即 `响应式` 特征。

## 4.3.方法属性(methods)

`methods` 可以在内部以键值对的形式存储 `{func1: function() {}, func2: function() {} }` 等 `<key, value>` 方法，可以被 `{{ func1() }}` 的形式在标签内部直接被调用，也可以通过标签的属性直接填入 `"key"` 属性值。

>   警告：不过值得警惕的是，这种方法属性内的 `key` 直接被调用则会导致方法在渲染完毕后立刻被调用而达不到监视的作用（例如按钮按下事件的触发），这种情况通常使用 `v-on` 指令来完成。

>   注意：同时不要忘记方法可以通过管道符进行串联。

## 4.4.计算属性(computed)

有一说一，计算属性和方法属性完全类似，但是从理论上计算属性效率可能要高一些。我们完全可以使用 `methods` 来替代 `computed`，效果上两个都是一样的，但 `computed` 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 `methods` 在重新渲染的时候，函数总会重新调用执行。另外 `computed` 属性默认只有 `getter`，不过在需要时您也可以提供一个 `setter`。

```html
<!-- 尝试使用监听属性 -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <script>
            var vue = new Vue({
                el: '#app',
                data: {
                    firstName: 'John',
                    lastName: 'Doe'
                },
                computed: {
                    fullName: {
                        get: function () {
                            return this.firstName + ' ' + this.lastName;
                        },
                        set: function (newValue) {
                            var names = newValue.split(' ');
                            this.firstName = names[0];
                            this.lastName = names[names.length - 1];
                        }
                    }
                }
            });
            vue.fullName = 'limou 3434'
            document.write('firstName: ' + vue.firstName);
            document.write('<br>');
            document.write('lastName: ' + vue.lastName);
        </script>
    </body>
</html>
```

## 4.5.监听属性(watch)

为了更加方便根据数据的变化自动调用某些方法，`Vue` 对象内部还有监听属性方法，只要对应的数据发送了变动就会调用属性内对应数据标签的方法。

```html
<!-- 尝试使用监听属性 -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id = "app">
            千米: <input type = "text" v-model = "kilometers">
            米: <input type = "text" v-model = "meters">
        </div>
        <p id="info"></p>
        <script>
            var vm = new Vue({
                el: '#app',
                data: {
                    kilometers : 0,
                    meters: 0
                },
                watch: {
                    kilometers: function(newVal, oldVal) { // 自动接收当前监测的发生变动的数据的新值和旧值作为参数(也可以只接受一个参数, 默认先接受新值)
                        if (newVal == oldVal) return
                        console.log("newVal: " + newVal + ", oldVal: " + oldVal) // 另外这里会打印两次, 因为下一句的修改会导致 meters 被修改调用对应的监听方法
                        this.meters = this.kilometers * 1000
                    },
                    meters: function(newVal, oldVal) {
                        if (newVal == oldVal) return
                        this.kilometers = newVal / 1000
                    }
                }
            })

            // 也可以在实例外部设置监听方法, 和上面的是等价的
            vm.$watch('kilometers', function(newValue, oldValue) {
                // 这个回调将在 vm.kilometers 改变后调用
                document.getElementById("info").innerHTML = "修改前值为: " + oldValue + "，修改后值为: " + newValue
            })
        </script>
    </body>
</html>
```

>   吐槽：不过我还挺好奇的，这里去掉监听方法内的 `if(newVal == oldVal)` 竟然不会出现循环调用，上述代码中修改了 `kilometers` 数据的同时会触发对应的监听方法，而监听方法内部则会修改 `meters`，进而导致调用该数据对应的监听方法。因此理论上来说是会造成循环调用的，但是 `vue` 貌似把这个逻辑给做好了，能够判断当 `newVal` 和 `oldVal` 相等时不会发生循环调用，不过为了健壮性和避免一些意外的情况，我还是对此做了防护...
>
>   并且比较也无法使用 `===` 来比较相等，这也是我感觉非常疑惑的一点，只能使用 `==` 否则日志会被输出两次...

# 7.事件处理器

## 7.1.内联 JS 事件

我们之前有提到过，事件处理通常会使用到 `v-on` 指令，这里来详细展开一下，这里提醒您一句，可以用 `@` 简化 `v-on` 的书写，这里我将大量采用这种写法。

```html
<!-- 尝试使用 v-on 监听事件 -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <button @click="counter += 1">增加 1</button>
            <p>这个按钮被点击了 {{ counter }} 次。</p>
        </div>
        <script>
            new Vue({
                el: '#app',
                data: {
                    counter: 0
                }
            })
        </script>
    </body>
</html>
```

## 7.2.调用 JS 事件

上面写法比较简单，只是简单内联 `JS` 表达式，没有直接调用 `JS` 函数，但一般需要的都是调用 `JS` 函数的。

```html
<!-- 尝试使用 v-on 监听事件 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<body>
<div id="app">
    <!-- greet 是在下面 Vue 实例中定义的方法名 -->
    <button @click="greet">Greet</button>
</div>

<script>
    var app = new Vue({
        el: '#app',
        data: {
            name: 'Vue.js'
        },
        // 在 methods 属性中直接定义方法
        methods: {
            greet: function (event) {
                alert('Hello ' + this.name + '!')
                // event 是原生 DOM 事件的事件对象
                if (event) {
                    alert(event.target.tagName) // 调用提示弹窗, 这将会打印出事件对象就是 BUTTON 自己
                }
            }
        }
    })
    // 也可以用 JavaScript 直接调用方法(下面两种是等价的)
    app.greet() // -> 'Hello Vue.js!'
</script>
</body>
</html>
```

## 7.3.事件修饰符

`Vue` 为 `v-on` 提供了许多事件修饰符来处理 `DOM` 事件的细节，可以通过由点 `.` 表示的指令后缀来调用修饰符，修饰符可以在设置好某些细节的情况下更好执行事件。

*   `.prevent` 阻止默认事件
*   `.stop` 阻止冒泡
*   `.capture` 阻止捕获
*   `.self` 只监听触发该元素的事件
*   `.once` 只触发一次事件，然后事件被移除无法生效
*   `.left` 左键事件
*   `.right` 右键事件
*   `.middle` 中间滚轮事件
*   `.keyCode编号` 限制按键条件，不过由于记住 `keyCode编号` 比较困难，因此 `Vue` 提供了小写的许多功能按键来替代这一功能

>   补充：关于事件的传递，为了知识的完整性，这里我也稍微补充一下事件传播的三个阶段。
>
>   -   **捕获阶段**：事件从 `document`（或者更高层的祖先节点）开始，向目标元素的父节点传递，直到到达目标元素
>   -   **目标阶段**：事件到达目标元素，即事件的实际触发点
>   -   **冒泡阶段**：事件从目标元素开始，向上冒泡，经过目标元素的父节点，直到到达 `document`（或者更高层的祖先节点）
>
>   ```html
>   <!-- 演示三个阶段 -->
>   <!DOCTYPE html>
>   <html lang="en">
>       <head>
>           <meta charset="UTF-8">
>           <title>Capture Phase Example</title>
>           <style>
>               .container {
>                   padding: 50px;
>                   background-color: lightgrey;
>               }
>               .box {
>                   padding: 50px;
>                   background-color: lightblue;
>               }
>           </style>
>       </head>
>       <body>
>           <div id="app" class="container">
>               <div class="box" id="box">
>                   Click me
>               </div>
>           </div>
>   
>           <script>
>               // 捕获阶段事件处理器
>               document.querySelector('.container').addEventListener('click', function() {
>                   console.log('Container clicked during capturing phase');
>               }, true); // true 表示捕获阶段
>   
>               // 目标阶段事件处理器
>               document.querySelector('#box').addEventListener('click', function() {
>                   console.log('Box clicked');
>               }, false); // false 表示冒泡阶段
>   
>               // 冒泡阶段事件处理器
>               document.querySelector('.container').addEventListener('click', function() {
>                   console.log('Container clicked during bubbling phase');
>               }, false); // false 表示冒泡阶段
>           </script>
>       </body>
>   </html>
>   ```

```html
<!-- 尝试使用事件修饰符 .prevent -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <form @submit.prevent="handleSubmit">
                <button type="submit">Submit</button>
            </form>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleSubmit() {
                        alert('Form submitted');
                    }
                }
            });
        </script>
    </body>
</html>
```

```html
<!-- 尝试使用事件修饰符 .stop -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <button @click.stop="handleClick">Click Me</button>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleClick() {
                        alert('Button clicked');
                    }
                }
            });
        </script>
    </body>
</html>
```

```html
<!-- 尝试使用事件修饰符 .capture -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app" class="container">
            <div class="box" @click.capture="handleCaptureClick">
                Click me
            </div>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleCaptureClick() {
                        alert('Box clicked during capturing phase');
                    }
                }
            });
        </script>
    </body>
</html>
```

`self` 没懂，待补充...

```html
<!-- 尝试使用事件修饰符 .once -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <button @click.once="handleOnceClick">Click Me</button>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleOnceClick() {
                        alert('Clicked once');
                    }
                }
            });
        </script>
    </body>
</html>
```

```html
<!-- 尝试使用事件修饰符 .left -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <button @click.left="handleLeftClick">Left Click</button>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleLeftClick() {
                        alert('Left mouse button clicked');
                    }
                }
            });
        </script>
    </body>
</html>
```

```html
<!-- 尝试使用事件修饰符 .right -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <button @contextmenu.right="handleRightClick">Right Click</button>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleRightClick() {
                        alert('Right mouse button clicked');
                    }
                }
            });
        </script>
    </body>
</html>
```

```html
<!-- 尝试使用事件修饰符 .middle -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
    </head>
    <body>
        <div id="app">
            <button @click.middle="handleMiddleClick">Middle Click</button>
        </div>

        <script>
            new Vue({
                el: '#app',
                methods: {
                    handleMiddleClick() {
                        alert('Middle mouse button clicked');
                    }
                }
            });
        </script>
    </body>
</html>
```

```html
<!-- 尝试使用事件修饰符 .keyCode编号 或 .键 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="vue2.js"></script> <!-- 引入 vue2.js 库 -->
</head>
<body>
<div id="app">
    <!--- <input @keyup.13="handleEnterKey" placeholder="Press Enter"> 13 就是 Enter 键的键码 -->
    <input @keyup.enter="handleEnterKey" placeholder="Press Enter"> <!-- 13 就是 Enter 键的键码 -->
</div>

<script>
    new Vue({
        el: '#app',
        methods: {
            handleEnterKey() {
                alert('Enter key pressed');
            }
        }
    });
</script>
</body>
</html>
```

# 8.表单



# 9.组件



# 10.指令

## 10.1.内置的指令

内置的指令有很多，我们之前讲过很多了，这里不在赘述，这里提一下只是为了帮助您构建比较完整的知识体系，顺便帮您复习一下...

## 10.2.自定义指令



# 11.路由



# 12.动画



# 13.混入



# 14.Ajax



# 15.响应接口

