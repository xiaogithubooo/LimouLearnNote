# 1.索引的意义

>   索引可以提高海量数据库的性能（不加内存，不改程序，不调 `sql`），只需要执行正确的 `create index` ，查询速度就可能提高成百上千倍。
>
>   但查询速度的提高是以插入、更新、删除的速度作为代价的，这些写操作增加了大量的 `IO`。

上述这段话还有很多是我们体会不到的，继续往下看。

我们先记住，`MySQL` 的服务器进程，所有的 `CURD` 都是在内存中进行的，索引也是这样，在内存中一定存在某种数据结构。

而优化算法的因素主要有两个：

-   组织数据的方法（例如：顺序表改写为二树树表）
-   算法的设计本身（例如：顺序查找改为二分查找）

而索引就是针对第一个方式对数据做优化，让查询速度变快，我们可以见一见什么叫索引。

1.   先建立一个 `.sql` 文件，该文件可以创建大批量的随机数：

     ```sql
     # 待补充
     ```

2.   使用 `ALTER TABLE table_name ADD INDEX(字段);` 添加索引

3.   比较不带索引和带上索引的查询速度差异...

# 2.磁盘和 SQL

之前在 `Linux` 里学习了文件 `IO`，里面有提到磁盘的结构和抽象，而 `MySQl` 也可以看作是一种特殊的文件系统。

`MySQL` 层下不是直接对接硬盘，而是对接操作系统，通过调用操作系统来进行文件管理。

`MySQL` 的 `IO` 次数更加频繁，因此为了提高基本的 `IO` 效率，`MySQL` 进行 `IO` 的基本单位是 `16KB`（系统文件是用 `4KB` 的逻辑块来查找，而磁盘是 `512byte` 来读取）。

这 `16KB` 的 `IO` 操作实际上是向操作系统提出来的。

这刚好和 `InnoDB` 引擎的大小一样：

```sql
# 查看大小
mysql> show global status like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| Innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.01 sec)
```

因此可以衍生出以下思考：

-   对于 `MySQL` 来说，数据文件都是以 `page=16KB` 为单位在磁盘中保存的
-   `MySQL` 的 `CURD` 都需要通过 `CPU` 计算，因此就必须要 `CPU` 参与，进一步就需要内存参与，要通过操作系统接口，把数据从磁盘移动到内存中
-   磁盘和内存的交互就是一种 `IO` 操作，`IO` 的基本单位就是 `page`
-   而为了更好在内存中操作和提高效率（导致效率低下的主要矛盾是 `IO` 次数而不是一次 `IO` 大小），`MySQl` 向内存申请了一个较大的 `Buffer Pool=128M` 内存空间，来进行各种缓存，以便提高命中率，减少大量的系统和磁盘交互的次数
-   `MySQL` 内部会存在大量的 `page`，因此就需要对 `page` 先描述再组织，然后用一定的数据结构连接起来，因此就是 `MySQl` 对 `page` 进行了建模

# 3.索引的原理

经过前面的对比和铺垫，接下来我们就可以来深入了解索引的原理了，首先创建一个 `user` 表：

```sql
# 创建 user 表
mysql> create table if not exists user (
    ->     id int primary key, -- 一定要添加主键（会默认生成主键索引）
    ->     age int not null,
    ->     name varchar(16) not null
    -> );
Query OK, 0 rows affected (0.02 sec)

mysql> show create table user\G
*************************** 1. row ***************************
       Table: user
Create Table: CREATE TABLE `user` (
  `id` int(11) NOT NULL,
  `age` int(11) NOT NULL,
  `name` varchar(16) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

mysql> insert into user (id, age, name) values(3, 18, 'limou');
Query OK, 1 row affected (0.00 sec)

mysql> insert into user (id, age, name) values(4, 16, 'dimou');
Query OK, 1 row affected (0.00 sec)

mysql> insert into user (id, age, name) values(2, 26, 'iimou');
Query OK, 1 row affected (0.00 sec)

mysql> insert into user (id, age, name) values(5, 36, 'eimou');
Query OK, 1 row affected (0.00 sec)

mysql> insert into user (id, age, name) values(1, 56, 'pimou');
Query OK, 1 row affected (0.00 sec)

mysql> select * from user;
+----+-----+-------+
| id | age | name  |
+----+-----+-------+
|  1 |  56 | pimou |
|  2 |  26 | iimou |
|  3 |  18 | limou |
|  4 |  16 | dimou |
|  5 |  36 | eimou |
+----+-----+-------+
5 rows in set (0.00 sec)
```

我们发现，我向具有主键的表中插入时，数据会自动进行排序。



