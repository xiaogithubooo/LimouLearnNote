>   前要：在网络服务中，如果对 `CURD` 不加限制，会出现什么问题？
>
>   在多个客户端同时向一个卖票服务器买票时（假设票数只剩一张），`A` 客户端让数据库内的票数 `count` 减 `1`，但是还没来得及更新数据，又有 `B` 服务器查询数据库，此时 `B` 服务器看到票数还是 `1`，又进行了减 `1` 操作，导致一张票被同时卖了两次。

`CURD` 的过程需要满足什么条件，才能解决上述问题呢？

1. 买票的过程得应该是原子操作（要么抢到，要么没抢）
2. 买票的过程中不能被相互影响（不能被互相影响，要割裂/独立开来）
3. 买完票后应该要永久有效（必须要做持久化，不能只是在内存中操作）
4. 买前和买后都是确定的状态（不能出现中间状态，要保证一致性）

# 1.事务的理解

## 1.1.事务的概念

事务简单来理解就是 **一组 DML 语句**，也就是一组用于数据操作（插入数据、删除数据...）的语句。

事务主要处理操作量大，复杂度高的数据，这些数据往往需要多条 `SQL` 语句来构成。

但是事务还不仅仅是多条语句的集合，还必须保证四个属性（`ACID`）才能保证安全运行事务：

-   **原子性(Atomicity)**：一组 `DML` 语句/一个事务，要么全部成功，要么全部失败，这是由 `MySQL` 提供的机制来保障的。

-   **一致性(Consistency)**：在事务开始和结束以后，数据库的完整性没有被破坏，写入的数据必须完全符合所有的预设规则（在 `MySQL` 中，一致性时被其他三个属性来保证的，但是需要数据库和用户来配合，才能得到一致性）

-   **隔离性(Isolation)**：防止多个事务并发执行时由于交叉执行导致的数据不一致问题，事务隔离有不同的等级

    (1)读未提交（`Read Uncommitted`）

    (2)读提交（`Read Committed`）

    (3)可重复读（`Repeatable Read`）

    (4)串行化（`Serialzable`）

-   **持久性(Durability)**：事务处理完后，对表中数据的影响是永久的（哪怕系统挂了也不会丢失），也就是持久化

>   注意：学习事务一定要在使用数据库的用户视角来理解。

事务在 `MySQL` 内也一定是一个具体对象，这就需要先描述再组织。

另外，事务不是 `MySQl` 天然就存在，而是为了在应用程序访问数据库的时候，能够简化编程模型，不需要考虑各种潜在并发问题、网络问题，用户只需要提交和回滚。因此，事务的本质是为了应用层服务的，而不是面向数据库内部。

## 1.2.事务的版本

`MySQL` 中只有使用了 `Innodb` 数据库引擎的数据库或数据表才可以支持事务，其他基本都不支持。

```sql
# 查看 MySQL 的引擎是否支持事务
show engines \G
*************************** 1. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 2. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
9 rows in set (0.00 sec)
```

# 2.事务的操作

## 2.1.做一些准备工作

首先，事务有两种提交方式：

-   自动提交
-   手动提交

```sql
# 查看事务提交方式
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)
```

可以用 `SET` 来改变 `MySQL` 的自动提交方式。

```sql
# 取消事务自动提交
mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.00 sec)

mysql> set autocommit=1;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)
```

然后我们切换超级用户，使用 `netstat -nltp` 是一个用于显示网络连接、路由表和网络接口信息的命令行工具查看 `MySQL` 是否成功运行且占用端口号。

```cmd
# 查看网络状态
# netstat -nltp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
 tcp6       0      0 :::3306                 :::*                    LISTEN      7404/mysqld         
```

原本是应该使用 `Windows11` 的 `cmd` 来远程访问 `Centos7` 云服务的 `MySQL` 服务，不过需要提前在 `Windows11` 中提前下载好 `MySQL`，所以我们先用本地的两个客户端来模拟，后续再来详细了解。

然后修改事务等级，不然有些现象会看不到。

```sql
# 客户端中设置事务隔离级别并且重启检查
mysql> set global transaction isolation level read uncommitted;
Query OK, 0 rows affected (0.00 sec)

mysql> quit
Bye

$ mysql -uroot -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 32
Server version: 5.7.44 MySQL Community Server (GPL)

Copyright (c) 2000, 2023, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> select @@tx_isolation;
+------------------+
| @@tx_isolation   |
+------------------+
| READ-UNCOMMITTED |
+------------------+
1 row in set, 1 warning (0.00 sec)
```

启动两个 `MySQL` 客户端（模拟并发场景），然后其中一个客户端建立一个如下的表结构：

```sql
# 客户端1：创建表结构
create table if not exists account(
id int primary key,
name varchar(50) not null default '',
blance decimal(10,2) not null default 0.0
)ENGINE=InnoDB DEFAULT CHARSET=UTF8;
```

```sql
# 客户端2：查看是否能看到 account 数据表
mysql> desc account;
+--------+---------------+------+-----+---------+-------+
| Field  | Type          | Null | Key | Default | Extra |
+--------+---------------+------+-----+---------+-------+
| id     | int(11)       | NO   | PRI | NULL    |       |
| name   | varchar(50)   | NO   |     |         |       |
| blance | decimal(10,2) | NO   |     | 0.00    |       |
+--------+---------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

可以在一个客户端中查看连接情况，可以看到确实存在两个本地客户端。

```sql
# 客户端1：查看 MySQL 的连接情况
mysql> show processlist\G
*************************** 1. row ***************************
     Id: 33
   User: ljp
   Host: localhost
     db: limou_database
Command: Query
   Time: 0
  State: starting
   Info: show processlist
*************************** 2. row ***************************
     Id: 34
   User: ljp
   Host: localhost
     db: limou_database
Command: Sleep
   Time: 355
  State: 
   Info: NULL
2 rows in set (0.00 sec)
```

## 2.2.正常情况的事务

启动事务有两种方法：(1)`start transaction;` (2)`begin`

一旦开启事务，后续的 `SQL` 操作都属于同一个事务的部分。并且，我还设置了一个保存点（可选）

```sql
# 客户端1：启动事务
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> savepoint s1;
Query OK, 0 rows affected (0.00 sec)
```

```sql
# 客户端2：启动事务
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from account;
Empty set (0.00 sec)
```

然后进行插入工作，设置第二个保存点，并且查看插入的数据是否同步到另外一个客户端。

```sql
# 客户端1：插入数据
mysql> insert into account values (2, 'limou', 10000);
Query OK, 1 row affected (0.00 sec)

mysql> savepoint s2;
Query OK, 0 rows affected (0.00 sec)
```

```sql
# 客户端2：查看数据
mysql> select * from account;
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  2 | limou | 10000.00 |
+----+-------+----------+
1 row in set (0.00 sec)
```

尝试插入更多的插入和设置保存点的操作，同时没插入一个记录，就检查客户端是否数据同步。

```sql
# 客户端1：插入数据和保存
mysql> savepoint s2;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into account values (1, 'dimou', 11030);
Query OK, 1 row affected (0.00 sec)

mysql> savepoint s3;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into account values (3, 'iimou', 10431);
Query OK, 1 row affected (0.00 sec)
```

```sql
# 客户端2：每次插入，就查看一次数据表
mysql> select * from account;
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  2 | limou | 10000.00 |
+----+-------+----------+
2 rows in set (0.00 sec)

mysql> select * from account;
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  2 | limou | 10000.00 |
|  3 | iimou | 10431.00 |
+----+-------+----------+
3 rows in set (0.00 sec)
```

如果我们突然后悔了，可以回滚事务。

```sql
# 客户端1：回滚事务
mysql> rollback to s3;
Query OK, 0 rows affected (0.00 sec)
```

```sql
# 客户端2：查看回滚后的数据表
mysql> select * from account;
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  2 | limou | 10000.00 |
+----+-------+----------+
2 rows in set (0.00 sec)
```

可以看到，数据表确实发生了回退，如果我们这个时候使用 `COMMIT` 就会提交本次事务。

```sql
# 客户端1：提交事务
mysql> commit;
Query OK, 0 rows affected (0.01 sec)
```

>   补充：使用 `roolback` 还可以将所有操作全部取消，但是一般很少这么做。

而事务只有在启动的时候才可以进行回滚操作，而一旦提交了就无法进行回滚。

## 2.3.异常情况的事务

如果其中一个服务端在事务状态下奔溃了会怎么样？其他客户端会自动回滚，也就是保证原子性，要么不做，要么就操作完。

```sql
# 客户端1：不断插入数据最后因为异常导致奔溃，插入一次就在客户端2中查看一次
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into account values (3, 'eimou', 20431);
Query OK, 1 row affected (0.01 sec)

mysql> insert into account values (4, 'eimou', 30434);
Query OK, 1 row affected (0.00 sec)

mysql> ^C
mysql> Aborted
```

```sql
# 客户端2：客户端1插入后不断查找数据表，最后检查奔溃后的数据表
mysql> select * from account;
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  2 | limou | 10000.00 |
+----+-------+----------+
2 rows in set (0.00 sec)

mysql> select * from account;
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  2 | limou | 10000.00 |
|  3 | eimou | 20431.00 |
|  4 | eimou | 30434.00 |
+----+-------+----------+
4 rows in set (0.00 sec)

mysql> select * from account; # 奔溃后，这里自动发生了回滚，回到开头
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  2 | limou | 10000.00 |
+----+-------+----------+
2 rows in set (0.00 sec)
```

也有一些其他的情况会发生自动回滚（客户端因为关闭 `shell` 而导致退出），但是如果事务已经进行了提交（也就是使用了 `COMMIT`），就不会再进行回滚（包括因为崩溃造成的自动回滚）。

但是我们之前设置的自动提交又是什么鬼？不是事务会自动提交吗？从现象来看，无论是设置 `autocommit` 为 `OFF` 还是 `ON` 现象都是一样的结果（这个您可以自己实验一下），那这个 `autocommit` 究竟有什么用呢？您先知道一个点，只要是手动开启启动事务，就必须手动提交，和是否设置自动提交无关即可。

而对比有无设置 `autocommit`  的两种情况：

### 2.3.1.设置为 OFF

```sql
# 客户端1：设置 autocommit 为 OFF，然后在事务中进行删除记录
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.00 sec)

mysql> delete from account where id=3;
Query OK, 1 row affected (0.01 sec)

mysql> Aborted
```

```sql
# 客户端2：不断查看数据表
mysql> select * from account; # 客户端1没删除之前
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  3 | timou | 50434.00 |
+----+-------+----------+
2 rows in set (0.00 sec)

mysql> select * from account; # 客户端1删除后
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
+----+-------+----------+
1 row in set (0.00 sec)

mysql> select * from account; # 客户端1奔溃后，发现记录恢复
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  3 | timou | 50434.00 |
+----+-------+----------+
2 rows in set (0.00 sec)
```

### 2.3.2.设置为 ON

```sql
# 客户端1：进行删除操作，但是不在事务中删除后崩溃
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

mysql> delete from account where id=3;
Query OK, 1 row affected (0.01 sec)

mysql> Aborted
```

```sql
# 客户端2：不断查看数据表
mysql> select * from account; # 客户端1没删除之前
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
|  3 | timou | 50434.00 |
+----+-------+----------+
2 rows in set (0.00 sec)

mysql> select * from account; # 客户端1删除后
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
+----+-------+----------+
1 row in set (0.00 sec)

mysql> select * from account; # 客户端1奔溃后，发现记录没有恢复
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
+----+-------+----------+
1 row in set (0.00 sec)
```

而且就算客户端2之前有做 `BEGIN`，再 `COMMIT` 后也不会恢复数据。

以上测试说明，只要设置了 `autocommit`，就会把一条单纯的 `SQL` 语句单独看作一个事务，都会被自动 `BEGIN` 和 `COMMIT`。因此如果没设置 `autocommit` 就会因为没有 `COMMIT` 而导致数据回滚。

>   复习：再理一理，`BEGIN` 是开启事务处理，`COMMIT` 是事务提交，防止回滚。

但是如果我们手动进行回滚呢？

```sql
# 客户端1：删除数据表，但是先 commit 再崩溃
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.01 sec)

mysql> delete from account where id=1;
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> Aborted
```

```sql
# 客户端2：不断查看数据表
mysql> select * from account; # 客户端1删除记录前
+----+-------+----------+
| id | name  | blance   |
+----+-------+----------+
|  1 | dimou | 11030.00 |
+----+-------+----------+
1 row in set (0.00 sec)

mysql> select * from account; # 客户端1删除记录后
Empty set (0.00 sec)

mysql> select * from account; # 客户端1崩溃后，没有发生回滚
Empty set (0.00 sec)
```

也侧面证明了：对于 `InnoDB` 里一条单纯的 `SQL` 就是一个完整的事务，最后都会因为 `autocommit=ON` 而自动提交（但是 `SELECT` 有点特殊，您先记住就行，因为 `MySQL` 有 `MVCC`）。

>   补充：`COMMIT` 操作实际上就是数据持久化的一种手段。

到这里就可以看到事务本身的原子性（回滚）和持久性（提交）。

#  3.事务的隔离



