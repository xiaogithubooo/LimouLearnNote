**信号量**：有些时候进程们虽然会访问同一份资源，但只是访问资源内不同的部分，如果真的让进程一个一个串行访问，就会慢很多，因此就可以先申请“信号量”，也就是对应资源内部某一个部分的访问权力

信号量可以先简单理解为计数器 `count`，申请信号量就会 `--`，执行流申请信号量成功后，临界资源内部一定会预留该执行流想要的资源（也就是预定机制）。

而只有该执行流执行完了，释放了信号量（也就是 `++`），才可以被别的执行流申请同样临界资源内部资源对应的的信号量。

并且不能使用一个全局变量来充当信号量，原因很简单，哪怕是父子进程也会因为写实拷贝而无法同步信号量。

就算真的可以看见一个变量，也会因为进程切换和时序的问题导致数据不同步。

另外，信号量也需要被所有进程看到，因此它天然就是临界资源，因此需要先保护自己的 `++` 或 `--` 是安全的、原子的。

必须保证信号量的 `++` 或 `--` 操作是原子的（不被 `CPU` 切换），否则很难做到保护临界资源。

# 5.信号量

## 5.1.信号量概念

>   注意：信号量的概念开头有，建议您复习一下...

我们之前有简单提及过信号量（`semaphore`，简写 `sem`） 的概念，这里摆在上面供给您复习，并且我们这次来深刻理解信号量的概念和使用。

如果一个共享资源不被当作整体看待，而是让不同的执行流访问不同的区域的话，那就可以提高并发效率，只有在访问共享资源内同一小部分资源时，才会进行同步或者互斥。

但是这就设计到几个问题：

1.   如何知道共享资源内有多少个子资源？
2.   如何保证这个子资源就是给程序员的？程序员如何知道他一定可以拥有某个子资源呢？

申请信号量类似去电影院买票，是一种资源预定机制，只要把票买好了，哪怕没有真的去坐电影院的座位，您心里也十分清楚：这个座位在没有任何意外的情况下，在看电影的期间一定属于您的。而与之类似的，信号量也是这样，本质是一个计数器，访问共享资源前先申请信号量资源 `sem--`（`P` 操作），使用完共享资源后释放信号量资源 `sem++`（`V` 操作）。

那如果申请了信号量后没有进行访问会怎么样？没有任何关系，操作系统一定会为您的线程预留一个子资源。

## 5.2.信号量接口

### 5.2.1.信号量初始

```cpp
//信号量初始
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
//pshared：0 表示线程间共享，非零表示进程间共享
//value：信号量初始值
```

### 5.2.2.信号量销毁

```cpp
//信号量销毁
int sem_destroy(sem_t *sem);
```

### 5.2.3.信号量等待

```cpp
//信号量等待
int sem_wait(sem_t *sem); //P()，会将信号量的值减 1
```

### 5.2.4.信号量发布

```cpp
//发布信号量
int sem_post(sem_t *sem); //V()，表示资源使用完毕，可归还资源，将信号量值加 1
```

## 5.3.信号量原理

待补充...

## 5.4.循环队列下的生产者-消费者模型（RingQueue）

使用信号量则可以写出更为高效的不加互斥锁的生产者-消费者模型，我以循环队列为例子书写代码，关于循环队列的基础知识这里就不再提及，您可以看我之前的文章。

-   如果队列为满，我们不希望生产者运行

-   如果队列为空，我们不希望消费者运行

这样我们就会发现，生产者和消费者指向同一份资源就需要互斥或同步，但只要没有指向同一份数据，就不需要这么做，假设循环队列存放的元素较多，则大部分情况下，两者是很难指向同一块资源空间的，因此如果我们在写入和读出的时候，只对队列加锁，效率会比较低：

-   某个时间点，消费者明明可以消费多余的数据，却因为生产者需要新增加数据，导致队列被整体加锁，进而消费者被阻塞
-   某个时间点，生产者明明可以生产多余的数据，却因为消费者需要新读取数据没导致队列被整体加速，进而生产者被阻塞

在其他不指向同一资源空间的大部分情况下，让两者并发执行即可，因此实际上我们之前写的生产者-消费者模型在这方面是有一点效率问题的：线程抢占资源过于霸道，之间将所有资源都占有了。

并且在这里两者的关心点不同：

-   生产者关心空间大小，有空间就生产，就可以使用一个计数器，我们可以使用 `spaceSem` 空间信号量，起始应该是 `n`（队列的大小）
-   消费者关心数据多少，有数据就消费，就可以使用一个计数器，我们可以使用 `dataSem` 空间信号量，起始大小应该是 `0`

而生产者在申请信号量的时候（`P(spaceSem)`），可能没有真的在生产资源，只不过循环队列一定有一个空间供生产者生产，而退出的时候不应该释放信号量，因为生产后的数据空间依旧是被占用的，但是我们需要对消费者消费后的空间进行信号量释放（`V(dataSem)`）。

而消费就需要申请使用消费资源 `P(dataSem)`，此时一定有一个数据资源供给消费者使用，而消费后，该空间无人占有，就需要让生产者来生产（`V(spaceSem)`）。

我们重新来捋一下，假设循环队列为空：

1.   从消费者开始，消费者做操作 `P(dataSem)` 后，此时生产者因为各种客观条件，还没来得及生产任何数据，因此消费者 `P()` 操作失败，消费者被阻塞等待，也就是队列为空时互斥
2.   生产者没理会消费者，它开始做操作 `P(spaceSem)` 申请信号量（此时为 `n`），申请成功，生产数据，并且增加消费者的信号量 `V(spaceSem)`，消费者被唤醒
3.   假设这次时消费者消费数据的时候慢了，虽然成功申请了消费信号量，但是仍在处理数据中，而生产者速度突然快起来了，不断申请生产信号量，释放消费信号量，直到生产信号量为 `0`，此时循环队列为满，生产者申请不到生产信号量，被系统挂起...

那如何让两个线程处理不同位置的数据呢？这就需要程序员自己把控了，我们会在代码中体现出来。

>   补充：`PV` 操作在系统中保证为原子操作。

我们先来尝试使用信号量来控制一个生产者对接一个消费者的情况。

```cpp
//ringQueue.hpp
#pragma once
#include <vector>
#include "sem.hpp"

const int gDefaultNum = 5;

template <typename T>
class RingQueue
{
public:
	RingQueue(const int& num = gDefaultNum)
		: _ringQueue(num), _num(num)
		, p_step(0), c_step(0)
		, _space_sem(num), _data_sem(0)
	{}

	~RingQueue()
	{}

	void Push(const T& in)
	{
		/*生产者生产数据*/
		//申请空间资源
		_space_sem.P();

		//生产数据放入队列
		_ringQueue[p_step++] = in;
		p_step %= _num;

		//释放数据资源
		_data_sem.V();
	}

	void Pop(T* out)
	{
		/*消费者消费数据*/
		//申请数据资源
		_data_sem.P();

		//消费数据取出队列
		*out = _ringQueue[c_step++];
		c_step %= _num;

		//释放空间资源
		_space_sem.V();
	}

	void Debug()
	{
		std::cerr << "[debug]"
		<< "size:" << _ringQueue.size()
		<< " num:" << _num
		<< '\n';
	}

private:
	std::vector<T> _ringQueue; //循环队列
	int _num; //循环队列的大小
	int p_step; //生产者下标
	int c_step; //消费者下标
	Sem _space_sem; //空间资源
	Sem _data_sem; //数据资源
};

```

```cpp
//sem.hpp
#pragma once
#include <semaphore.h>

class Sem
{
public:
    Sem(int value)
    {
        sem_init(&_sem, 0, value);
    }

    void P()
    {
        sem_wait(&_sem); //申请信号量资源
    }

    void V()
    {
        sem_post(&_sem); //释放信号量资源
    }

    ~Sem()
    {
        sem_destroy(&_sem);
    }
private:
    sem_t _sem;
};
```

```cpp
//testMain.hpp
#include <iostream>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <ctime>
#include <cstdlib>
#include "ringQueue.hpp"

//生产者方法
void* Producer(void* args)
{
    RingQueue<int>* rq = (RingQueue<int>*)args;
    while(true)
    {
        //1.生产数据
        int x = rand() %100 + 1;
        std::cout << "生产数据" << x << '\n';

        //2.推送数据
        rq->Push(x);
        
        //3.控制循环速度，便于观察数据生产和消费
        //sleep(1);
    }
    return nullptr;
}

//消费者方法
void* Consumer(void* args)
{
    RingQueue<int>* rq = (RingQueue<int>*)args;
    while(true)
    {
        //1.获取数据
        int x = 0;
        rq->Pop(&x);

        //2.数据处理
        std::cout << "消费数据" << x << '\n';
        
        //3.控制循环速度，便于观察数据生产和消费
        sleep(3);
    }
    return nullptr;
}

int main()
{
    //设置随机数 种子
    srand((uint64_t)time(nullptr) ^ getpid());

    //构建循环队列
    RingQueue<int>* rq = new RingQueue<int>(10);
    rq->Debug();


    //创建和初始化生产者和消费者线程
    pthread_t p, c;
    pthread_create(&p, nullptr, Producer, (void*)rq);
    pthread_create(&c, nullptr, Consumer, (void*)rq);

    //释放线程
    pthread_join(p, nullptr);
    pthread_join(c, nullptr);

    return 0;
}
```

```cpp
# makefile
rq:testMain.cc
	g++ -o $@ $^ -std=c++11 -lpthread

.PHONY:clean
clean:
	rm -f rq
```

而如果我们需要多个角色怎么办？生产者和生产者之间、消费者和消费者之间必然时互斥关系，因此我们肯定时需要为两种角色各自加锁的。

那么生产者和生产者的临界资源是哪一个呢？不是循环队列整体，而是内部的每一个元素。

下面我们来写写看，并且使用智能锁来保证同类者竞争选出一个生产者或者消费者。

```cpp
//ringQueue.hpp
#pragma once
#include <vector>
#include <pthread.h>
#include "sem.hpp"
#include "lock.hpp"

const int gDefaultNum = 5;

template <typename T>
class RingQueue
{
public:
	RingQueue(const int& num = gDefaultNum)
		: _ringQueue(num), _num(num)
		, p_step(0), c_step(0)
		, _space_sem(num), _data_sem(0)
	{}

	~RingQueue()
	{}

	void Push(const T& in)
	{
		/*生产者生产数据*/
		//申请空间资源（一般先申请信号量，先分配好空间资源，相当于“先买票再来排队进入电影院”）
		_space_sem.P();

		//对所有生产者加锁（如果先加锁，只有一个进程会进行 P() 操作，无法尽快分配资源）
		LockGuard psLock(&_plock);

		//生产数据放入队列
		_ringQueue[p_step++] = in;
		p_step %= _num;

		//释放数据资源
		_data_sem.V();
	}

	void Pop(T* out)
	{
		/*消费者消费数据*/
		//申请数据资源
		_data_sem.P();

		//对所有消费者加锁
		LockGuard csLock(&_clock);

		//消费数据取出队列
		*out = _ringQueue[c_step++];
		c_step %= _num;

		//释放空间资源
		_space_sem.V();
	}

	void Debug()
	{
		std::cerr << "[debug]"
		<< "size:" << _ringQueue.size()
		<< " num:" << _num
		<< '\n';
	}

private:
	std::vector<T> _ringQueue; //循环队列
	int _num; //循环队列的大小
	int p_step; //生产者下标
	int c_step; //消费者下标
	Sem _space_sem; //空间资源
	Sem _data_sem; //数据资源
	pthread_mutex_t _plock; //生产者之间的锁
	pthread_mutex_t _clock; //消费者之间的锁
};
```

```cpp
//lock.hpp
#pragma once
#include <iostream>
#include <pthread.h>

//封装锁
class Mutex
{
public:
    Mutex(pthread_mutex_t* mtx)
        : _pmtx(mtx)
    {}
    void Lock()
    {
        std::cout << "智能加锁" << '\n';
        pthread_mutex_lock(_pmtx);
    }
    void UnLock()
    {
        std::cout << "智能解锁" << '\n';
        pthread_mutex_unlock(_pmtx);
    }
    ~Mutex()
    {}

private:
    pthread_mutex_t* _pmtx;
};

//智能锁（有点类似智能指针）
class LockGuard
{
public:
    LockGuard(pthread_mutex_t* mtx)
        : _mtx(mtx)
    {
        _mtx.Lock();
    }
    ~LockGuard()
    {
        _mtx.UnLock();
    }

private:
    Mutex _mtx;
};
```

```cpp
//sem.hpp
#pragma once
#include <semaphore.h>

class Sem
{
public:
    Sem(int value)
    {
        sem_init(&_sem, 0, value);
    }

    void P()
    {
        sem_wait(&_sem); //申请信号量资源
    }

    void V()
    {
        sem_post(&_sem); //释放信号量资源
    }

    ~Sem()
    {
        sem_destroy(&_sem);
    }
private:
    sem_t _sem;
};
```

```cpp
//testMain.hpp
#include <iostream>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <ctime>
#include <cstdlib>
#include "ringQueue.hpp"

//生产者方法
void* Producer(void* args)
{
    RingQueue<int>* rq = (RingQueue<int>*)args;
    while(true)
    {
        //1.生产数据
        int x = rand() % 100 + 1;
        std::cout << pthread_self() << ":生产数据" << x << '\n';

        //2.推送数据
        rq->Push(x);
        
        //3.控制循环速度，便于观察数据生产和消费
        sleep(1);
    }
    return nullptr;
}

//消费者方法
void* Consumer(void* args)
{
    RingQueue<int>* rq = (RingQueue<int>*)args;
    while(true)
    {
        //1.获取数据
        int x = 0;
        rq->Pop(&x);

        //2.数据处理
        std::cout << pthread_self() << ":消费数据" << x << '\n';
        
        //3.控制循环速度，便于观察数据生产和消费
        sleep(6);
    }
    return nullptr;
}

const int size = 3;

int main()
{
    //设置随机数 种子
    srand((uint64_t)time(nullptr) ^ getpid());

    //构建循环队列
    RingQueue<int>* rq = new RingQueue<int>(10);
    rq->Debug();


    //创建和初始化生产者和消费者线程
    pthread_t ps[size], cs[size];

    for(int i = 0; i < size; i++)
        pthread_create(ps + i, nullptr, Producer, (void*)rq);
    for(int i = 0; i < size; i++)
        pthread_create(cs + i, nullptr, Consumer, (void*)rq);

    //释放线程
    for(int i = 0; i < size; i++)
        pthread_join(ps[i], nullptr);
    for(int i = 0; i < size; i++)
        pthread_join(cs[i], nullptr);

    return 0;
}
```

```cpp
# makefile
rq:testMain.cc
	g++ -o $@ $^ -std=c++11 -lpthread

.PHONY:clean
clean:
	rm -f rq
```

在代码中我们会发现，多生产多消费的最大意义在于：

1.   为什么需要多线程代码？生产者在生产数据的时候，可能处理时间较久，而此时多生产者的多线程代码可以将已经生产好的数据放入队列中，这就大大提高了生产效率。同理，消费者也是类似的原理

2.   我们为什么需要信号量？表征临界资源中的子资源，让共享资源更加颗粒化。

     ```mermaid
     flowchart LR
     lock["加锁"] --> if["判断与访问"] --> unclock["解锁"]
     ```

     而有了信号量，就可以提前假设出临界资源的使用情况，不需要显式的进入临界区，然后判断临界区内部临界资源的情况。

     ```mermaid
     flowchart LR
     sem["提前申请信号量"] --> lock["加锁"] -.-x if["判断与访问"] -.-x unclock["解锁"]
     lock --> unclock
     ```

# 6.线程池

要提线程池久不得不提到池化技术了，池化技术也是一种预定机制，如果在代码中大量反复申请资源可能会降低效率（例如不断使用 `new` 申请内存，会导致内存碎片、底层反复的系统调用），因此很有必要提前给“资源池存蓄好资源”。

而线程池也是一种池化技术，线程过多会带来调度开销，影响缓存局部性和整体性，而线程池内维护多个提前申请的线程，等待管理者分配可以并发的任务，避免短时间任务时创建和销毁线程的代价，保证内核的充分利用，防止过度调度。

首先我们需要对线程进行封装，再使用封装后的线程来构成线程池。

```cpp
//thread.hpp
#pragma once
#include <iostream>
#include <string>
#include <functional>
#include <pthread.h>

struct ThreadData
{
    void* _args;
    std::string _name;
};

typedef void*(*func_t)(void*);

class Thread
{
    /*线程封装*/
public:
    Thread(int num, func_t callback, void* args)
        : _func(callback)
    {
        /*传递名称*/
        std::string name = "Thread-";
        name += std::to_string(num);
        _tdata._args = args;
        _tdata._name = name;
    }

    void Start()
    {
        /*线程启动*/
        pthread_create(&_tid, nullptr, _func, (void*)(&_tdata));
    }

    void Join()
    {
        /*线程等待*/
        pthread_join(_tid, nullptr);
    }

    std::string Name()
    {
        /*线程名字*/
        return _tdata._name;
    }

    ~Thread()
    {}
private:
    pthread_t _tid;
    ThreadData _tdata;
    func_t _func;
};
```

```cpp
//threadPool.hpp
#pragma once
#include <iostream>
#include <vector>
#include <queue>
#include <string>
#include <unistd.h>
#include <pthread.h>
#include "thread.hpp"
#include "lockGuard.hpp"
#include "log.hpp"

//线程池（这里的运行逻辑实际上就是生产者-消费者模型）
const int gThreadNum = 3;

template <typename T>
class ThreadPool
{
private:
    //线程默认调用方法（相当于消费）
    static void* routine(void* tdata) //this 指针有一个坑，这个函数实际具有两个参数类型，最好不要写成成员函数
    {
        ThreadData* td = (ThreadData*)tdata;
        ThreadPool<T>* tp = (ThreadPool<T>*)td->_args;
        while(true)
        {
            T task;
            {
                LockGuard lockGuard(tp->GetMutex()); //智能锁
                while(tp->IsEmpty()) tp->WaitCond(); //内部自动释放锁（在被重新唤醒时会自动持有锁，不影响后续析构）
                
                task = tp->GetTask(); //获取任务（从共享空间拿到私有空间）
                LogMessage(DEBUG, "%s:%d+%d=%d | file:%s | line:%d", td->_name.c_str(), task._x, task._y, task()), __FILE__, __LINE__;
            }

            sleep(10);
        }
    }

public:
    ThreadPool(int threadNum = gThreadNum)
        : _num(threadNum)
    {
        for(int i = 0; i < _num; i++)
            _threads.push_back(new Thread(i, routine, this));
    
        pthread_mutex_init(&_lock, nullptr);
        pthread_cond_init(&_cond, nullptr);
    }

    void Run()
    {
        /*线程创建*/
        for(auto& iter : _threads)
        {
            iter->Start();
            LogMessage(NORMAL, "%s %s", iter->Name().c_str(), "run...");
        }
    }

    void PushTask(const T& task)
    {
        /*给线程放置任务*/
        LockGuard lockGuard(&_lock); //添加智能锁
        _task_queue.push(task);
        pthread_cond_signal(&_cond);
    }

    pthread_mutex_t* GetMutex()
    {
        return &_lock;
    }

    bool IsEmpty()
    {
        return _task_queue.empty();
    }

    void WaitCond()
    {
        pthread_cond_wait(&_cond, &_lock);
    }

    T GetTask()
    {
        T t = _task_queue.front();
        _task_queue.pop();
        return t;
    }

    ~ThreadPool()
    {
        std::cout << "析构线程池" << '\n';
        for(auto& iter : _threads) iter->Join(), delete iter;
        pthread_mutex_destroy(&_lock);
        pthread_cond_destroy(&_cond);
    }

private:
    std::vector<Thread*> _threads; //线程池
    int _num; //线程池大小
    std::queue<T> _task_queue; //任务列表
    pthread_mutex_t _lock; //任务列表锁
    pthread_cond_t _cond; //任务列表条件变量
};
```

```cpp
//LockGuard.hpp
#pragma once
#include <iostream>
#include <pthread.h>

//封装锁
class Mutex
{
public:
    Mutex(pthread_mutex_t* mtx)
        : _pmtx(mtx)
    {}
    
    void Lock()
    {
        pthread_mutex_lock(_pmtx);
    }
    
    void UnLock()
    {
        pthread_mutex_unlock(_pmtx);
    }
    
    ~Mutex()
    {}

private:
    pthread_mutex_t* _pmtx;
};

//智能锁（有点类似智能指针）
class LockGuard
{
public:
    LockGuard(pthread_mutex_t* mtx)
        : _mtx(mtx)
    {
        _mtx.Lock();
    }

    ~LockGuard()
    {
        _mtx.UnLock();
    }

private:
    Mutex _mtx;
};
```

```cpp
//Task.hpp
#pragma once
#include <functional>

class Task
{
    typedef std::function<int(int, int)> func_t; //函数包装
public:
    Task(){}

    Task(int x, int y, func_t func)
        : _x(x), _y(y), _func(func)
    {}

    int operator()() //仿函数
    {
        return _func(_x, _y);
    }

public:
    int _x; //操作数 x
    int _y; //操作数 y
    func_t _func;
};
```

```cpp
//log.hpp
#pragma once
#include <iostream>
#include <string>

#include <cstdio>
#include <cstdarg>
#include <ctime>

//日志级别
#define DEBUG 0 //调式
#define NORMAL 1 //正常
#define WARNING 2 //警告
#define ERROR 3 //错误
#define FATAL 4 //致命

const char* gLevelMap[] = {
    "DEBUG", //debug 模式
    "NORMAL", //正常
    "WARNING", //警告
    "ERROR", //错误
    "FATAL" //严重错误
};

//日志功能主要有：日志等级+发送时间+日志内容/自定义日志内容+Other（代码行数+运行用户）
void LogMessage(int level, const char *format, ...)
{
#ifndef DEBUG_SHOW
    if (level == DEBUG) return;
#endif
    //日志标准部分 
    char stdBuffer[1024];
    time_t timestamp = time(nullptr); 
    snprintf(stdBuffer, sizeof stdBuffer, "[%s][%d]", gLevelMap[level], timestamp);

    //日志自定义部分
    char logBuffer[1024];

    va_list args; //声明可变参数列表
    va_start(args, format); //初始化可变参数列表
    vsnprintf(logBuffer, sizeof logBuffer, format, args); //int vsnprintf(char *str, size_t size, const char *format, va_list ap); 是一个可变参数函数，将格式化的字符串输出到缓冲区中
    va_end(args); //清理可变参数列表

    printf("%s %s\n", stdBuffer, logBuffer);
}
```

```cpp
//testMain.
#include <iostream>
#include <ctime>
#include <cstdlib>
#include <unistd.h>
#include "threadPool.hpp"
#include "task.hpp"
#include "log.hpp"

int main()
{
    //种下随机种子
    srand((unsigned long)time(nullptr) ^ getpid());

    //创建线程池
    std::cout << "--thread Pool--" << '\n';
    ThreadPool<Task>* tp = new ThreadPool<Task>();
    tp->Run();

    //生产-消费过程
    while (true) 
    {
        //主线程承担生产的过程（可能需要一定的时间）
        int x = rand() % 100 + 1;
        usleep(1000);
        int y = rand() % 30 + 1;

        //制作任务
        Task t(x, y, [](int x, int y)->int {
            return x + y;
        });
        LogMessage(NORMAL, "%s:%d+%d=?", "completion of the production:", x, y);

        //推送任务
        tp->PushTask(t);
        sleep(1);
    }
    return 0;
}
```

```makefile
# makefile
pool:testMain.cc
	g++ -o $@ $^ -std=c++11 -lpthread

.PHONY:clean
clean:
	rm -f pool
```

我们写的线程池可以做一个优化：

![image-20240101131356588](./assets/image-20240101131356588.png)