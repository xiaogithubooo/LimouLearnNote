>   前要：本节内容主要是管道和共享内存块，而最后的 `POSIX` 只是简单提及一下，会在以后的内容中逐渐补充...

# 1.进程通信

## 1.1.进程通信目的

进程间通信（`IPC`）的目的在于：

1.   **数据传输**：将进程的数据发送给另一个进程
2.   **资源共享**：多个进程之间共享某种资源
3.   **通知事件**：一个进程需要向另一个进程或者一组进程发送消息，通知发生了某种事件（如：进程终止时要通知父进程）
4.   **进程控制**：有些进程希望完全控制另一个进程的执行（如：`Debug` 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

由于进程是具有独立性的（具有各自的进程地址空间），因此两进程之间想要交互数据的难度比较大，需要有一个媒介（让不同的进程看到一个相同的资源），也就是看到同一份内存空间。利用同一份内存空间，进程间就可进行数据交互。

## 1.2.进程通信发展

进程之间的通信从古老的管道一直发展到 `System V` 进程通讯和 `POSIX` 进程间通信。

| 管道 Pipe   | System V IPC       | POSIX IPC |
| -------------- | :------------------ | --------- |
| 匿名管道 `pipe` | `System V` 消息队列 | 消息队列  |
| 命名管道       | `System V` 共享内存 | 共享内存  |
|                | `System V` 信号量   | 信号量    |
|                |                    | 互斥量    |
|                |                    | 条件变量  |
|                |                    | 读写锁    |

# 2.管道 Pipe

管道的来源很早（但是并没有被 `Linux` 抛弃，相反使用得还挺多），源自于 `Unix` 中的进程通信。把“一个进程”连接到“另一个进程”的”一个数据流“称为”一个管道“。

![image-20240127153036258](./assets/image-20240127153036258.png)

管道是 `Linux` 中是原生提供的，作用很类似现实生活中的管道，都是进行“传输”的作用。不过这个管道 **只允许单向通行**（也叫“半双工”，这样设计比较简单，需要双向就创建两个管道文件即可，还有一叫通信方式叫做“全双工”通信），传送进程需要的资源。而为了保持进程之间的独立性，管道需要由操作系统（内核）来维护。

而管道本质是一个特殊文件，可以被多个进程以文件的形式被进程们看到，但是普通的文件有很大的区别。

由于多进程产生的数据大部分是临时数据，因此进程之间通过内存中的管道文件来通信是内存级别的通信，不会写入到磁盘（这样很低效）。

另外，管道一般用于本地主机中的进程间通信。

>   补充：该设计方案和现实中水管管道十分类似，就有了“管道”这一称呼。

## 2.1.匿名管道

创建匿名管道的接口描述：

```c++
//创建匿名管道接口的函数声明
#include <unistd.h>
int pipe(int fd[2]);
//fd 是用户传入的空数组，用来存储获得的文件描述符，f[0] 表示管道读端，f[1] 表示管道写端
//成功返回 0，失败返回错误代码
```

父进程先使用 `pipe()` 创建一个管道文件设置好读端和写端，这种管道文件是直接在父子进程之间创建的，具有匿名性（只局限在父子进程间通信），因此也被称为 **匿名管道**。

### 2.1.1.匿名管道图解

![image-20231005104313622](./assets/image-20231005104313622.png)

然后父进程再创建子进程子进程同样也设置好了读写端（需要注意子进程是独立的，因此也有自己的文件描述符表 `fd_array[]`，但是父进程内 `fd_array[]` 的数据会拷贝到子进程的 `fd_array[]`）。

<img src="./assets/image-20231004213142577.png" alt="image-20231004213142577" style="zoom:80%;" />

然后构建单向通信信道，父进程写入，子进程读取，关闭对于进程无用的读端/写端（但是其实不关闭也是可以的，只是为了严谨和防御编程）。

<img src="./assets/image-20231004230933508.png" alt="image-20231004230933508" style="zoom:67%;" />

这样两个进程就可以进行通信了。

也就是说，管道是通过：

1.   进程 `PCB` 在创建子进程的浅拷贝的操作
2.   对文件操作的复用

来达到看到同一份内存空间的目的...

### 2.1.2.匿名管道应用

```c++
//使用匿名管道（父进程写，子进程读）
#include <iostream>
#include <string>

#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <cassert>
#include <cstdio>
#include <cstring>
#include <cstdlib>

using namespace std;

int main()
{
    //1.创建管道
    int pipefd[2] = { 0 }; //这里的数组数据最后会被子进程拷贝了，所以也看得到
    int n = pipe(pipefd);
    assert(n != -1), (void)n; //检查是否创建成功，并且消除警告，因为这个返回值n只是检查是否成功，在release模式下assert()会失效，导致没人使用 n 从而引起报警
    
    //2.创建进程
    pid_t id = fork();
    assert(id != -1);
    
    //3.创建信道
    if(id == 0) //子进程入口
    {
        close(pipefd[1]); //关闭子进程的写端，保留子进程读端
        char buffer[1024];
        while (true)
        {
            ssize_t s = read(pipefd[0], buffer, sizeof(buffer) - 1); //读取管道数据
            if(s > 0) //读成功
            {
                sleep(1); //这里加上这一句的目的是想查看，父进程写完字符串 "exit" 后，比子进程读取先关闭了写端，则子进程是否会进行正常读取
                cout << "读取到的字符个数:" << s << endl;
                buffer[s] = 0; //添加 '\0' 因为系统调用不靠该字符结尾
                cout << "[" << getpid() << ":child get a message]" << ", Father sad:[" << buffer << "]" << endl;
            }
            //一旦管道文件不存在数据，子进程读完后就会陷入阻塞状态...
        }
        exit(0);
    }
    
    close(pipefd[0]); //关闭父进程读端，保留父进程的写端
    
    string message;
    int count = 0; //统计消息条数
    char send_buffer[1024];
    while (true)
    {
        cin >> message;
        
        snprintf(send_buffer, sizeof(send_buffer), "%s:%d", message.c_str(), ++count); //写到缓冲区
        write(pipefd[1], send_buffer, strlen(send_buffer));

        if (message == "exit")
        {
            close(pipefd[0]); //检测父进程提前关闭写端的现象
            break;
        }
    }
    cout << "父进程跳出循环，准备接受子进程中..." << endl;
    pid_t ret = waitpid(id, nullptr, 0); //等待子进程
    assert(ret < 0), (void)ret; //消除警告

    return 0;
}
```

>   注意：您可能会对上述代码产生疑惑，附件进程传递数据时，为何不用一个全局的 `buffer[]` 呢？这样子进程直接拷贝父进程的数据，不就完成了通信么？
>
>   这样做肯定是不对的，因为有写时拷贝技术的存在，在进程中通信传输的数据并不是固定不变的（我们上述的代码就是不固定的，会根据用户不同的输入让父进程向匿名管道写入不同内容的数据，再让子进程进行读取），如果数据发生变化，就会导致发生写时拷贝，导致出现信息不一致性问题。

在我们写的代码的运行结果可以注意到，如果用户输入 `"exit"`，则父进程将 `pipdfd[1]`（也就是写入端）关闭，子进程在读取完毕后，就会直接进入阻塞状态。

实际上，只要管道文件内有数据，子进程就会一直读数据，只要管道文件内还有空间，父进程就会一直写数据（注意匿名管道文件是有空间上限的）。

而使用匿名管道，其实就提供了访问控制的一种手段，操作系统在管道内做了关于互斥和同步的特殊处理：

-   **在匿名管道文件不为空也不为满时**，只要管道文件内有数据，子进程就会一直读数据，只要管道文件内还有空间，父进程就会一直写数据，输入长度和读写次数上没有严格的限制

-   **在匿名管道文件为空时**

    (1)`O_NONBLOCK` 禁用时，读端必须等待匿名管道文件被写入（阻塞状态），直到有数据可读为止

    (2)`O_NONBLOCK` 启用时，`read` 调用将立即返回，返回值为 -1，同时设置 `errno` 为 `EAGAIN`，表示非阻塞且当前没有数据可读

-   **而匿名管道文件写满时**

    (1)`O_NONBLOCK` 禁用时，写端必须等待匿名管道文件被读取（阻塞状态），直到有空间可写为止

    (2)`O_NONBLOCK` 启用时，`write` 调用将立即返回，返回值为 `-1`，同时设置 `errno` 为 `EAGAIN`，表示非阻塞且当前没有空间可写

>   补充：这里的 `O_NONBLOCK` 其实是 `open()` 的 `flags` 参数的一个可选项，而匿名管道可以通过 `fcntl()` 对相应的文件描述符进行设置。
>
>   ```cpp
>   //fcntl() 接口声明
>   #include <fcntl.h>
>   int fcntl(int fd, int cmd, ... /* arg */);
>   
>   //int flags = fcntl(fd, F_GETFL, 0);
>   //flags |= O_NONBLOCK;
>   //fcntl(fd, F_SETFL, flags)
>   ```

您还可以去尝试一下设置了 `O_NONBLOCK` 的情况。

而匿名管道文件在父子进程同时退出时，管道文件就被自动释放（引用计数为 `0`），也就是匿名管道文件同生命周期随进程结束。

如果父进程和多个子进程有管道的连接，这些子进程也被称为“进程池”（和内存池有些类似），我们可以写一个类似这样的代码。

```c++
//尝试编写一个简单的进程池
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <functional>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <cassert>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
using namespace std;
#define PROCESS_NUM 5

//等待读取函数
int waitCommand(int waitFd, bool& quit);

//使用包装类 using func = std::function<void()>定义一个函数类型，或者使用函数指针
typedef function<void()> func;

//各个任务声明
void readSQL();         //查询数据库
void execuleUrl();      //解析地址
void cal();             //加密任务
void mathCalculate();   //数学计算

vector<func> callbacks;                                  //存储若干回调函数的顺序表
void load();                                             //填充若干任务（函数）
unordered_map<int, string> desc;                         //创建哈希表
void show();                                             //查看任务
int handlerSize();                                       //查看任务数量
void sendAndWakeup(pid_t who, int fd, uint32_t command); //布置任务

//任务处理逻辑
int main()
{
    //0.装载任务
    load();

    //1.构造进程池
    vector<pair<pid_t, int>> slots;
    for(int i = 0; i < PROCESS_NUM; i++)
    {
        //1.1.创建管道
        int pipefd[2] = {0};
        int n = pipe(pipefd);
        assert(n >= 0);
        (void)n;

        //1.2.创建进程
        pid_t id = fork();
        assert(id != -1);
        if(id == 0) //子进程
        {
            close(pipefd[1]);//子进程的管道文件关闭写端
            while(true)
            {
                bool quit = false;
                int command = waitCommand(pipefd[0], quit);//如果父进程不写就进入阻塞
                if(quit)
                    break;
                if(command >= 0 && command < handlerSize())
                {
                    callbacks[command]();//调用对应的方法
                }
                else
                {
                    cout << "非法command:" << command << endl;
                }
            }
            exit(1);
        }
        //父进程
        close(pipefd[0]); //关闭父进程的读端，由父进程进行写入管道，通知其他进程
        slots.push_back(pair<pid_t, int>(id, pipefd[1])); //子进程 id 和各管道写标识符建立键值对
    }

    //2.父进程派发任务（这就相当于单机版的负载均衡）
    srand(((unsigned long)time(nullptr)) ^ getpid() ^ 114514L); //让数据源更加随机
    while(true)
    {
        int n = 0;
        int command = 0;
        cout << "--------------------------------" << endl;
        cout << "1.show functions  2.send command" << endl;
        cout << "--------------------------------" << endl;
        cout << "<Please Select>:";
        cin >> n;
        if(n == 1)
        {
            show();
        }
        else if(n == 2)
        {
            cout << "<Enter Your Command>:";
            //选择任务
            cin >> command;
            //随机选择进程
            int choice = rand() % slots.size();
            //布置任务（给指定的进程 id 和对应管道的读端，以及命令序号）
            sendAndWakeup(slots[choice].first, slots[choice].second, command);
        }
        else
        {
            //assert(false); //断死意外情况，供调试使用
        }
    }
    
    //3.关闭fd，结束所有进程
    for(const auto slot : slots)
    {
        close(slot.second); //父进程关闭掉所有的写端
    }
    for(const auto& solt : slots)
    {
        waitpid(solt.first, nullptr, 0); //回收所有子进程信息
    }
    return 0;
}

int waitCommand(int waitFd, bool& quit)
{
    /* 子进程等待读取 */
    uint32_t command = 0; //四字节缓冲区
    ssize_t s = read(waitFd, &command, sizeof(command)); //从读端读给command
    if(s == 0) //已经关闭了文件描述符
    {
        quit = true;
        return -1;
    }
    assert(s == sizeof(uint32_t)); //保证读取正确
    return command;
}

//任务表
void readSQL()
{
    sleep(3);
    cout << "process[" << getgid() << "] 执行了访问数据库的任务" << endl;
}
void execuleUrl()
{
    sleep(3);
    cout << "process[" << getgid() << "] 执行了解析URL地址的任务" << endl;
}
void cal()
{
    sleep(3);
    cout << "process[" << getgid() << "] 执行了加密的任务" << endl;
}
void mathCalculate()
{
    sleep(3);
    cout << "process[" << getgid() << "] 执行了数学计算的任务" << endl;
}

void load()
{
    /* 转载任务，插入键值对（key 和函数指针） */
    desc.insert({callbacks.size(), "readSQL:读取数据库"});
    callbacks.push_back(readSQL);

    desc.insert({callbacks.size(), "execuleUrl:解析URL"});
    callbacks.push_back(execuleUrl);

    desc.insert({callbacks.size(), "cal:加密"});
    callbacks.push_back(cal);

    desc.insert({callbacks.size(), "mathCalculate:数学计算"});
    callbacks.push_back(mathCalculate);
}

void show()
{
    /* 查看可执行的任务列表 */
    for(const auto &iter : desc)
    {
        cout << iter.first << "\t" << iter.second << endl;
    }
}

int handlerSize()
{
    /* 返回任务数量 */
    return callbacks.size();
}

void sendAndWakeup(pid_t who, int fd, uint32_t command)
{
    /* 父进程布置任务 */
    write(fd, &command, sizeof(command));//向管道输入数据
    cout << "call process" << who << "execute" << desc[command] << "through" << fd << endl;
}
```

通过上述的代码，我们可以进一步理解 `|` 这个符号的内部原理，但是不够，为什么？因为管道符号还适用于两个没有血缘关系的进程间，而我们上述有关管道代码都是基于父子进程下的匿名管道，只适有父子血缘关系的父子进程间通信。

>   补充：根据上述管道的原理，我们可以在之前模拟实现的 `MyShell` 中实现一下管道符号...

总结起来的话，匿名管道的特点如下：

1.   **匿名管道仅能近亲通信**：匿名管道只能用于具有共同祖先的进程（具有亲缘关系的进程）之间进行通信，通常一个匿名管道由一个父进程创建（兄弟进程之间也可以直接通过匿名管道直接通信）
2.   **匿名管道提供流式服务**：匿名管道可以用来在两个进程之间建立一个 **单向的、顺序的、字节流** 的通信通道（传递的是字节流，而不是消息边界，这使得匿名管道适用于传递连续的数据流，但不保证消息的完整性）
3.   **匿名管道可以自动释放**：匿名管道一般父子进程都退出时，管道就会被释放，所以管道的生命周期随进程
4.   **匿名管道支持同步互斥**：内核会自动对管道操作进行同步与互斥工作（无需我们加锁，加锁的问题我们以后再谈）
5.   **匿名管道具有半双工性**：匿名管道是半双工的，数据只能向一个方向流动，若是需要双向通信时（全双工），就需要建立起两个管道（也算是代码的一种复用）

>   补充：消息边界是指在进程间通信（`IPC`）中，消息的起始和结束位置。消息边界是用来区分不同消息的标志。在某些通信机制中，消息是以边界为单位进行传递的，即一个完整的消息从开始到结束是一个独立的单元。
>
>   有两种主要的通信模型：流模型和消息模型。
>
>   1.  **流模型**：流模型是一种基于字节流的通信方式，数据以连续的字节流形式传递，没有消息边界的概念。在流模型中，发送方不会将消息的边界明确传递给接收方，而是将数据连续地写入流，接收方需要自己解析数据以还原消息的边界，特别适用于需要实时传递数据的场景，并且实现相对简单。
>   2.  **消息模型**：消息模型是一种基于消息为单位的通信方式，消息在传递过程中是独立的单元，有明确的起始和结束。在消息模型中，发送方将消息作为一个整体发送，接收方可以按照消息边界来接收和处理消息。
>
>   而我们学的匿名管道就是基于流模型的，也就是一种流服务方案。

## 2.2.有名管道

上面的管道时匿名的内存级文件，只能用于父子进程间通行，没有办法用在无血缘关系的进程之间通信。但实际上，即便是两个无血缘关系的进程，其通信原理也是让两个进程看到同一份内存空间，这种方式就是 **有名管道**。

`Linux` 内有一种文件很特殊，存储在磁盘上，有自己的路径和名字，可以被打开，但是永远不会把数据刷新到磁盘中，双方经常就可以通过该管道文件的路径查看到同一份资源。

创建有名管道文件的命令行指令为 `mkfifo <filename>`，创建出来后使用 `ls` 可以查看到该文件的标志为 `p` （即：管道文件），或者也可以使用系统接口来创建有名管道。

```c++
//创建有名管道接口的函数声明
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char* filename, mode_t mode);
```

我们可以尝试做有名管道的命令操作：

```bash
# 第一个 bash 窗口
$ pwd
/limou/file

$ mkfifo pipe # 创建有名管道，名字为 pipe

$ ll
total 0
prw-rw-r-- 1 limou limou 0 Oct  7 12:52 pipe
    
$ echo "hello" > pipe # 输入数据
```

```bash
# 第二个 bash 窗口
$ pwd
/limou

$ cat < ./file/pipe # 获取数据
hello
```

或者使用接口直接编写代码：

```c++
//头文件
#ifndef _COMM_H_
#define _COMM_H_

#include <iostream>
#include <string>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>
using namespace std;

string ipcPath = "./fifo.ipc";//管道文件路径
#define MOOD 0666//设置管道文件初始权限
#define SIZE 128//设置缓冲大小

#endif
```

```c++
//服务端
#include "comm.hpp"
int main()
{
    //1.创建管道文件
    if(mkfifo(ipcPath.c_str(), MOOD) < 0)
    {
        perror("mkfifo() wrong!");
        exit(1);
    }

    //2.正常文件操作
    int fd = open(ipcPath.c_str(), O_RDONLY);
    if(fd < 0)
    {
        perror("open() wrong!");
        exit(2);
    }
    
    //3.编写通信代码
    char buffer[SIZE];
    while(SIZE)
    {
        memset(buffer, '\0', sizeof(buffer));
        ssize_t s = read(fd, buffer, sizeof(buffer) - 1);
        if(s > 0)
        {
            cout << "client say: " << buffer << endl;
        }
        else if(s == 0)
        {
            cerr << "read end of file!" << endl;
        }
        else
        {
            perror("read() wrong!");
        }
    }
    //4.关闭管道文件
    close(fd);
    //5.删除管道文件
    unlink(ipcPath.c_str());

    return 0;
}
```

```c++
//客户端
#include "comm.hpp"
int main()
{
    //1.获取管道文件
    int fd = open(ipcPath.c_str(), O_WRONLY);
    if(fd < 0)
    {
        perror("open() wrong!");
        exit(1);
    }
    //2.通信过程
    string buffer;
    while(true)
    {
        cout << "please enter message line:" << endl;
        getline(cin, buffer);
        write(fd, buffer.c_str(), buffer.size());
    }

    return 0;
}
```

```c++
//makefile 文件
.PHONY:all
all:client server

client:client.cc
	g++ -o $@ $^ -std=c++11

server:server.cc
    g++ -o $@ $^ -std=c++11

.PHONY:clean
clean:
    rm -f client server、
```

# 3.System V IPC

`System V`（通常缩写为 `SysV`）是一个 `Unix` 操作系统的家族，以及相应的一系列标准和版本。`System V` 操作系统最初由 `AT&T`（美国电话电报公司）开发，后来成为 `UNIX` 操作系统的主要分支之一。`SysV` 在 `Unix` 的发展历史中发挥了重要作用，特别是在 `20` 世纪 `80` 年代和 `90` 年代。

以下是 `System V` 的主要特征和方面：

1. **标准和规范：** `System V` 引入了一系列标准和规范，以定义操作系统的行为和接口。其中最著名的是 `System V Interface Definition`（`SVID`），该定义在一定程度上规范了 `System V` 操作系统的 `API` 和用户界面

2. **进程管理：** `System V` 引入了一些新的进程管理概念，如 `init` 进程，以及使用 `init.d` 目录中的脚本启动和停止系统服务

3. **IPC（进程间通信）：** `System V` 提供了一套 `IPC` 机制，包括消息队列、信号量和共享内存，用于进程之间的通信

4. **文件系统布局：** `System V` 规定了一些文件系统的布局和目录结构，包括 `/etc` 和 `/var` 等

5. **系统初始化：** `System V` 引入了系统初始化过程的一些标准，如运行级别（`runlevels`）的概念，用于指定系统启动时运行的服务和进程。

6. **系统调用：** `System V` 操作系统有一套特定的系统调用，提供对底层系统功能的访问

值得注意的是，虽然 `System V` 是一个 `Unix` 操作系统家族，但在 `Unix` 历史上有其他分支和变种，如 `BSD（Berkeley Software Distribution）` 和其他商业版本。在某些情况下，不同的 `Unix` 版本可能采用了不同的设计和实现，导致了 `Unix` 家族的多样性。

## 3.1.共享内存原理

`System V` 共享内存是 `System V IPC`（进程间通信）机制的一部分（我们也只提及这一部分的内容），用于在不同进程之间共享内存段。`System V IPC` 是 `System V` 操作系统引入的一套进程间通信机制，包括消息队列、信号量和共享内存。

`System V` 共享内存一般偏向于本地服务器通信，但是用得较少，最大的原因是接口风格不太统一，以及其他方案的优越性...

我们主要理解 `System V` 中共享内存的原理。而不得不承认的是，共享内存区是较快的 `IPC` 形式。每个进程的进程地址空间的共享区中，都映射到同一份内存空间中，那么这些进程间的数据传递就不再涉及到内核（或者说：不再通过执行进入内核的系统调用来传递彼此的数据），直接就在内存中进行数据交互。

共享区在每一个进程的进程地址空间的堆栈之间。

而共享区映射的共享内存是操作系统提供的，不单独属于某一个进程，因此共享内存也不需要进程单独维护，此时操作系统就应该对共享区进行管理，首先就需要对其进行描述，该描述包含了共享内存的属性：

```c++
//共享内存区的结构描述
/* Obsolete, used only for backwards compatibility and libc5 compiles */
struct shmid_ds {
	struct ipc_perm		shm_perm;	/* 操作权限 */
	int			shm_segsz;	/* 段的大小 (字节) */
	__kernel_old_time_t	shm_atime;	/* 最后一次附加时间 */
	__kernel_old_time_t	shm_dtime;	/* 最后一次分离时间 */
	__kernel_old_time_t	shm_ctime;	/* 最后一次变更时间 */
	__kernel_ipc_pid_t	shm_cpid;	/* 创建者的的进程ID */
	__kernel_ipc_pid_t	shm_lpid;	/* 最后一个操作者的进程ID */
	unsigned short		shm_nattch;	/* 当前附加的数量 */
	unsigned short 		shm_unused;	/* 兼容性 */
	void 			*shm_unused2;	/* 未使用的字段 - 由DIPC使用 */
	void			*shm_unused3;	/* 未使用的字段 */
};
```

也就是说“共享区 = 共享内存块 + 对应共享内存的内核数据结构”，一旦需要使用共享内存时，操作系统先用上述数据结构进行申请，然后将共享内存交给每个进程中的进程地址空间的共享区映射。

## 3.2.共享内存接口

### 3.2.1.共享内存创建

而创建共享内存的接口是：

```c++
//共享内存创建接口
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
//key 是共享内存使用的键值，使用同一个 key 的进程就可以看到同一个共享内存，使用 ftok() 来创建，只有系统才可以直接知道
//size 是共享内存的大小
//shmflg 是操作标记为，主要有两个选项：IPC_CREAT(创建新的共享内存)、IPC_EXCL(创建新的共享内存时如果已存在则返回错误，一般不会单独使用，会和IPC_CREAT共用，保证共享内存全新)
//返回值是共享内存的用户层标识符，类似 fd，虽然有区别，但也是提供给用户操作的（操作共享内存的标识符）
```

### 3.2.2.共享内存销毁

共享内存不会随进程结束销毁，在命令行中可以使用 `ipcs -m` 查看，使用 `ipcrm -m <shmid>` 释放，其生命周期随内核（除非重启才可以自动释放），或者在代码中使用下面接口：

```cpp
//共享内存销毁接口
#include <sys/ipc.h>
#include <sys/shm.h>
int shmctl(int shmid, int cmd, struct shmid_ds* buf);
//shmid 是使用 shmget() 创建共享内存后返回的 id 值
//cmd 是对共享内存做不同的操作方案，常用的有：IPC_STAT(获取共享内存的属性)、IPC_SET(设置共享内存的属性)、IPC_RMID(标志共享内存是被释放的)等
//buf 是共享内存对应的数据结构，如果只需要释放共享内存设置为 nullptr 即可
//失败返回 -1，成功返回 0 
```

### 3.2.3.共享内存挂接

而申请成功后还需要建立共享内存和进程之间的映射关系，也就是使用接口 `shmat()`，如果需要取消这个映射就使用 `shmdt()`：

```c++
//共享内存挂接接口
#include <sys/ipc.h>
#include <sys/shm.h>
void* shmat(int shmid, const void* shmaddr, int shmflg);//使用 ipcs -m 还可以看到共享内存的 nattach 映射个数（和进程的连接个数）
//shmid 就是使用 shmget() 得到的 shmid
//shmaddr 将共享内存挂接到确定的虚拟地址，但是不推荐使用，除非有特殊用途，设为 nullptr 让操作系统自己去操作即可
//shmflg 就是挂接的方式，例如：只读等，这里我们只使用 0，即默认情况
//挂接成功返回挂接成功后共享内存的虚拟地址，失败则返回 -1，该接口还挺像 malloc()的，因此使用共享内存只需要使用返回的虚拟地址即可（注意返回的共享内存的起始虚拟地址，而其空间大小是我们一开始就设定好的，因此我们可以通过偏移量访问共享内存内每一块地址）

int shmdt(const void* shmaddr);
//除去挂载，成功则返回0，失败返回-1
```

`key` 是内核级别的共享内存 `ID`，`shmid` 是用户层的共享内存 `ID`，供用户结合接口来使用。

而共享内存是属于用户空间，而不是内核空间。双方进程如果需要通信，直接就可以进行内存级的读写即可。而我们之前学的 `pipe` 和 `fifo` 都需要通过系统接口 `read()` 和 `write()` 来进行通信，这是因为文件是内核级别结构。而共享内存是在用户空间堆栈之间的，可以是直接使用，无需使用任何接口。

`````cpp
//comm.hpp
#ifndef _COMM_H_
#define _COMM_H_

#include <iostream>
#include <string>
#include <cstdio>
#include <cassert>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>

#define PATH_NAME "/home/ljp"
#define PROJ_ID 0x666
#define SHM_SIZE 4096
//共享内存的大小最好是页(PAGE:4096)的整数倍，
//不过不是的话问题也不大，因为操作系统申请共享内存是按页的倍数申请的，
//如果不是整数倍的话，有可能造成共享内存空间浪费

using namespace std;
#endif
`````

```cpp
//shmServer.cpp
#include "comm.hpp"
string TransToHex(key_t k)
{
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "0x%x", k);
    return buffer;
}
int main()
{
    //1.创建共同的key
    key_t k = ftok(PATH_NAME, PROJ_ID);
    cout << TransToHex(k) << endl;
    assert(k != -1);
    //2.创建共享内存
    int shmid = shmget(k, SHM_SIZE, IPC_CREAT | IPC_EXCL | 0666);
    //注意共享内存不会随进程结束销毁，
    //可以使用ipcs -m查看，使用ipcrm -m <shmid>释放
    //注意最后的0666是设置共享内存的权限，这和文件类似

    assert(shmid != -1);
    //3.挂接共享内存
    char* shmaddr = (char*)shmat(shmid, nullptr, 0);
    assert(shmaddr != nullptr);
    //4.撰写通信逻辑
    for(;;)   
    {
        printf("%s\n", shmaddr);
        sleep(1);
    }

    //5.断接共享内存（从自己的地址空间中，默认清为全0）
    int n = shmdt(shmaddr);
    assert(n != -1);(void)n;

    //6.释放共享内存
    n = shmctl(shmid, IPC_RMID, nullptr);//这里的IPC_RMID很霸道，无论有多少个进程和共享内存挂接都会释放共享内存
    assert(n != -1);(void)n;
    return 0;
}
```

```cpp
//shmClient.cpp
#include "comm.hpp"
int main()
{
    //1.创建共同的key
    key_t k = ftok(PATH_NAME, PROJ_ID);
    cout << k << endl;
    assert(k != -1);
    //2.获得共享内存
    int shmid = shmget(k, SHM_SIZE, 0);
    assert(shmid != -1);
    //3.挂接共享内存
    char* shmaddr = (char*)shmat(shmid, nullptr, 0);
    assert(shmaddr != nullptr);
    //4.撰写通信逻辑（将共享内存当作一个存储char的数组）
    char a = 'a';
    for(; a <= 'z'; a++)
    {
        snprintf(shmaddr, SHM_SIZE - 1, "Hello, I am server. My pid: %d, inc = %c\n", getpid(), a);
        sleep(2);
    }
    //5.断接共享内存
    int n = shmdt(shmaddr);
    assert(n != 1);
    return 0;
}
```

共享内存的通信是所有的 `IPC` 中速度最快的，因为不需要过多的将数据进行多次拷贝。

需要注意的是共享内存不提供访问控制（写入方无需理会对方是否已经读取，读取方无需理会对方是否已经写入），这点在以后学到多进程的时候就可以体会到（共享内存缺乏访问控制，就有可能会引发并发问题）。

但是我们可以进行手动访问控制，也就是使用管道来实现。

```cpp
//待补充...
```

## 3.3.共享内存控制

待补充...

## 3.4.共享内存消息队列

待补充...

## 3.5.共享内存信号量

待补充...

# 4.POSIX IPC

`POSIX`（`Portable Operating System Interface`）是一组操作系统接口标准，旨在提高不同操作系统之间的可移植性。`POSIX` 定义了一套 `API` 和服务，以便在各种类 `Unix` 系统上编写可移植的应用程序（`POSIX` 偏向网络服务器通信，用得较多）。

以下是一些常见的 `POSIX` 接口和服务：

1.  **文件系统操作：**
    *   `open`、`close`、`read`、`write`：打开、关闭、读取和写入文件
    *   `mkdir`、`rmdir`：创建和删除目录
    *   `chdir`、`getcwd`：更改和获取当前工作目录
    
2.  **进程控制：**
    *   `fork`、`exec`：创建新进程和执行新程序
    *   `wait`、`waitpid`：等待子进程的结束
    *   `exit`：退出当前进程
    
3.  **信号处理：**
    *   `signal`、`sigaction`：捕获和处理信号
    
4.  **线程控制：**
    *   `pthread_create`、`pthread_join`：创建和等待线程
    
5.  **进程间通信：**
    *   `pipe`、`mkfifo`：创建管道和命名管道
    
        `msgget`、`msgsnd`、`msgrcv`：消息队列的操作
    
    *   `sem_open`、`sem_wait`、`sem_post`：信号量的操作。
    
    *   `shmget`、`shmat`、`shmdt`：共享内存的操作
    
6.  **用户和组管理：**
    *   `getuid`、`getgid`：获取用户和组标识
    *   `setuid`、`setgid`：设置用户和组标识
    
7.  **时间和时钟：**
    *   `time`、`clock`：获取当前时间和时钟时间
    *   `sleep`、`nanosleep`：睡眠一定的时间
    
8.  **网络和套接字：**
    *   `socket`、`bind`、`listen`、`accept`：创建和管理网络套接字

有一些我之前有提及过，还有一些我会在后续内容中逐步展开...
