**叠甲：以下文章主要是依靠我的实际编码学习中总结出来的经验之谈，求逻辑自洽，不能百分百保证正确，有错误、未定义、不合适的内容请尽情指出！**

[TOC]

>   概要：这一部分的内容是前面的指令实操和后续原理学习的过渡知识，可以简单了解一下。我们前面了解的大部分是如何使用一个 `Linux` 操作系统的问题，但是这一章过度后，我就会带您了解比较深甚至到达操作系统内核的知识。

>   资料：部分参考王道的 [王道计算机考研操作系统体系结构(上)](https://www.bilibili.com/video/BV1YE411D7nH/?p=8&share_source=copy_web&vd_source=4772b64d7a3cb1873f14bc0153c4de68) 和 [王道计算机考研操作系统体系结构(下)](https://www.bilibili.com/video/BV1YE411D7nH/?p=9&share_source=copy_web&vd_source=4772b64d7a3cb1873f14bc0153c4de68) 这两段视频。

---

# 1.冯诺依曼计算机体系

关于冯·诺伊曼系统，在这里我只是简单讲一讲，更加详细的内容可以看我的计算机组成系列。常见的笔记本、台式机，不常见的服务器、工作站，大部分都遵守“冯·诺依曼体系”或和其类似的结构，因此该计算机体系就是现代计算机制作的一种哲学指导。 

## 1.1.早期冯诺依曼体系

<img src="./assets/eebd8d83-c34a-4a15-bfcf-707b387a71d4.png" title="" alt="eebd8d83-c34a-4a15-bfcf-707b387a71d4" style="zoom:50%;">

## 1.2.现代冯诺依曼体系

<img src="./assets/1f4e1aa7-1cf4-483c-aa5f-17e78d4c1eff.png" title="" alt="1f4e1aa7-1cf4-483c-aa5f-17e78d4c1eff" style="zoom:50%;">

> 注释 `1`：实线为数据传输线，虚线为控制线。
>
> 注释 `2`：这里的存储器指的是内存，因此个人觉得这个存储器不太严谨，但是碍于很多教科书都是如此书写，只能得续用。
>
> 注释 `3`：磁盘设备其实反倒是可以理解为输出设备，因为文件数据是会写到磁盘内部的……同理磁盘也可以作为输入设备使用。
>
> 注释 `4`：控制器的作用是响应外部事件，比如：拷贝数据到内存，实际上控制器做的很多事情都是把一个数据移动到某个位置。
>
> 注释 `5`：输入设备到内存的步骤为 `input`，内存到输出设备的步骤为 `output`，也就是 `I/O` 的过程，因此程序要运行，也就必须要加载到内存中。 
>
> 注释 `6`：实际上很多的硬件设备都是具有存储数据能力的，只不过是存储量的大小不一罢了。而所谓的硬件之间进行交流，也就是利用各个硬件中的存储空间，来进行数据的拷贝/迁移。
>
> 注释 `7`：`SSD` 是固态硬盘，比磁盘的读写速度快，但是价格也比普通的磁盘要贵，因此有很多企业还会购买大量的磁盘来使用，减少成本（一般存储效率高的存储硬件要更贵）。
>
> 注释 `8`：现代很多的 `CPU` 只能对内存进行读写，不能直接和外设（输入输出设备）进行数据交流。根据“木桶效应”，由于速度最慢的就是 `CPU` 和外设直接数据交互，导致整机效率降低（所以 `CPU` 一般为了高效，一般只和内存打交道）。
>
> 注释 `9`：内存可以理解为大的缓存空间。

# 2.操作系统的内核结构

内核中保留操作系统最核心的功能，内核代码必然需要实现的主要功能如下图。

```mermaid
graph LR
操作系统内核 --> 时钟管理 & 中断管理 & 原语管理 & 资源管理
时钟管理 & 中断管理 & 原语管理 --> 微内核
微内核 & 资源管理 --> 宏内核
```

>   补充：内核的代码需要处于内核态才能运行（关于内核态和用户态和进程地址空间有关，后续进行讲解），因此微内核的系统请求内核态切换的次数会比大内核较多。不过这也意味着宏内核虽然性能不错，但代码耦合度高，较难维护。

>   补充：上述是最简单的一种内核分类方式，不过您还可以稍微了解一下一些其他的细分知识。
>
>   -   **内核分层化**：在内核设计的时候，把内核设计为分层结构，这样做的主要目的是可以随时替换分层便于维护，并且便于调试。但有时存在无法明确界限、跨层调用效率低下、接口设计不合理的问题。
>   -   **内核模块化**：简单来说就是 `内核=主模块+可加载内核模块`，这样做的目的和分层类似，可以随时替换模块，方便维护代码，并且效率会高一些。但是模块的依赖如果过重有可能导致调试困难、模块接口定义未必合理的问题。

# 3.补充操作系统的术语





那么 `OS` 的“管理”具体的结构是怎么样的呢？下面有一张图您可以简单看一下。

<span style="text-emphasis:filled red;">下面这张图有点错误，需要修改一下，待补充...</span>

<img title="" src="./assets/239064a6-4e2b-4af1-b740-1904708bac1a.png" alt="239064a6-4e2b-4af1-b740-1904708bac1a" style="zoom:67%;">

> 补充 `1`：系统调用和库函数的概念
>
> 1. 在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。
>
> 2. 系统调用在使用上功能比较基础，对用户的使用要求比较高，开发者可以对部分系统调用进行适度的封装，从而形成了库（例如 `C` 库）。有了库，就有利于上层用户或者开发者进行调用开发，也就是通过库来间接调用系统调用。
>
> 3. 需要注意系统调用的运行过程是在内核态中完成的，操作系统不允许用户直接访问内核，也就是说用户运行态不满足访问内核的权限
>
>     >   用户态和内核态是指操作系统中的两种不同的运行模式，其中：
>     >
>     >   1.   用户态是指进程在执行自己的代码时所处的非特权模式
>     >   2.   内核态是指进程需要执行特权代码时所处的特权模式
>     >
>     >   在用户态下，进程只能访问自己的地址空间和所分配的资源，例如磁盘文件、网络端口等，无法直接访问系统资源或进行特权操作，例如修改内存映射表、修改硬件设备配置等。此外，在用户态下，进程只有一部分 `CPU` 指令集和系统调用可以使用，不能直接访问操作系统内核的数据结构和函数。
>     >
>     >   当进程需要进行特权操作或访问受保护的内核资源时，例如进行文件读写、网络通信、进程管理等，就需要通过系统调用（`System Call`）向操作系统提出请求。这时进程会从用户态切换到内核态，操作系统会为其执行相应的特权操作，并返回结果给进程。在内核态下，进程可以访问操作系统内核的所有资源和功能，包括修改内存、访问硬件资源等。
>     >
>     >   总之，用户态和内核态的主要区别在于进程所处的权限和可用指令集。在用户态下，进程只能访问自己的资源，不能直接访问系统资源或进行特权操作，而在内核态下，进程具有访问操作系统内核的所有权限和功能。操作系统通过切换进程的运行模式来限制或扩展进程的访问权限，以保证系统的安全性和稳定性。
>
> 补充 `2`：`Linux` 内核内部有很多驱动程序，基本都是用 `C` 语言写的，也有少部分使用汇编（这部分连偏向底层的 `C` 都没有办法书写）。

上面这张图您可能只知道表面，无法知道更加深层次的细节，但是在以后的学习中，您就会逐渐体到这张图的意义。

而操作系统除了在底层对这四者进行管理，也需要和上层用户进行交互，方便用户借操作系统之手来操作底层硬件。因此就需要对外暴露简单易用的接口（这是相对于硬件来说简单的...），根据使用接口场景我简单分为了以下三类接口。

```mermaid
graph LR
jk("接口")
gui("图形接口") -->|"根据 GUI 接口构建"| txrj("图形化软件")
mljk("命令接口") --> ljjk["联机命令接口/交互式接口(也就是命令行的指令)"] & tjjk["脱机命令接口/批处理接口(也就是编写好的脚本)"]
cxjk["系统接口"]
jk --> gui & mljk & cxjk
```



## 

## 2.7.OS 的发展

```mermaid
graph LR
    A[操作系统的发展] 
    A --> B[单用户单任务]
    A --> C[批处理系统]
    A --> D[多道程序设计]
    A --> E[分时系统]
    A --> F["实时系统\n(硬实时操作系统/软实时操作系统)"]
    A --> G[网络操作系统]
    A --> H[分布式操作系统]
    A --> I[嵌入式操作系统]

    B --> B1[只能同时运行一个任务，用户独占计算机资源]
    C --> C1[任务批量执行，减少CPU空闲时间，提高效率]
    D --> D1[多个任务同时进入内存，CPU多路复用，提高资源利用率]
    E --> E1[多个用户同时交互使用计算机，时间片轮转，提高响应速度]
    F --> F1[任务必须在严格时间限制内完成，应用于工业控制等领域]
    G --> G1[通过网络互联计算机，提供网络资源共享和通信功能]
    H --> H1[多个计算机协同工作，统一管理和调度，提高资源利用和可靠性]
    I --> I1[专用系统，通常资源受限，应用于家电、汽车等设备]
```

## 2.8.OS 的引导

[引导程序可以再看一下](https://www.bilibili.com/video/BV1YE411D7nH?p=10&spm_id_from=pageDriver&vd_source=c92c89dbfcf9cc30c48086469621f35b)

![image-20240609114903669](./assets/image-20240609114903669.png)

其实就是一个开机过程...

![image-20240609115115220](./assets/image-20240609115115220.png)

## 2.9.OS 的虚拟

![image-20240609115311454](./assets/image-20240609115311454.png)

![image-20240609120025149](./assets/image-20240609120025149.png)
