>   前要：在 `TCP/IP` 协议中，用 `源IP + 源PORT + 目的IP + 目的PORT + 协议号` 五元组就可以确定两进程之间的通信（可以使用 `netstat -nltp` 来查看），下面是 `netstat` 命令的常用参数（有些需要 `sudo`）为 `nltp/nlup`：
>
>   1.  `-n`：拒接显示别名的进程，则使用数字格式显示地址和端口号，而不进行 `DNS` 解析
>   2.  `-l`：仅显示正在侦听的端口
>   3.  `-t`：显示 `TCP` 连接
>   4.  `-u`：显示 `UDP` 连接
>   5.  `-p`：显示建立相关链接的程序名
>   6.  `-a`：显示所有连接和侦听端口（不加这个参数的话，默认不显示 `LISTEN` 相关）
>
>   另外还有一个指令 `pidof 服务名称` 得到对应 `pid`，再利用管道结合 `xargs kill -9` 即可杀死该命令（`xargs` 可以将标志输入转化为命令行参数交给命令行，类似还有 `ls | xargs touch` 来更新所有文件的改动时间）。

# 1.细谈端口号

1.  **系统端口（Well-Known Ports）**：`0` 到 `1023`，这些端口号通常用于一些常见的服务，比如：
    *   SSH: 22 端口
    *   HTTP: 80 端口
    *   HTTPS: 443 端口
    *   ftp: 21 端口
    *   Telnet: 23 端口
    *   SMTP: 25 端口
    *   POP3: 110 端口
    *   IMAP: 143 端口
    *   DNS: 53 端口
    *   SMB: 445 端口
    *   NFS: 204 端口
2.  **注册端口（Registered Ports）**：`1024` 到 `49151`，这些端口号用于用户定义的服务或应用程序，需要经过 `IANA` 注册。
3.  **动态和/或私有端口（Dynamic and/or Private Ports）**：`49152` 到 `65535`，这些端口号用于客户端和服务端之间的动态分配，通常不固定于特定的应用程序或服务。

>   补充：可以使用 `cat /etc/services` 查看这些端口号。

# 2.传输层两大协议

从应用层往下开始的传输层会更加原生，应用层的用户直接使用接口完成对应的服务（例如字符传输），而传输层上下都有协议，因此必须解决两个问题：

-   如何分离
-   如何交付

## 2.1.UDP 协议

![image-20240403095838090](./assets/image-20240403095838090.png)

上层传递要作为自己的有效载荷，传递给下层要加上报头。而下层传递要作为自己的报文，传递给上层要去除报头。

`UDP(User Datagram Protocol)` 的报头就是固定长度的 `8` 字节信息，如果采用固定的报头，可以方便后续把报头和有效载荷分离，进而提取报头的有效属性（这里也就是为什么 `uint_16`）。而长度的设定就可以让 `UDP` 具有将一个报文完整读取，也就是 `UDP` 是面向数据报的。

报头、报文究竟是什么？

```cpp
//报头
struct udp_hdr
{
	uint32_t src_port:16;  
	uint32_t dst_port:16;  
	uint32_t udp_len:16;  
	uint32_t udp_check:16;  
};
```

操作系统在内核层时，创建一个内存空间存储 `udp_hdr` 的实例化对象，而添加报头实际上就是把报头实例化对象拷贝到报文中，这就是封装报头，整体作为 `UDP` 报文，假设这个整体依靠一个 `void* start` 来指向。而报头解析实际上就是强制类型转化 `(struct udp_hdr*)start->...`，只要拿到报头指针，根据固定的字节长度，就可以移动指针到报文部分，而报头内又有报文长度信息，就可以截取到整个报头，从内核拷贝给用户就可以进行交付。

大量的报文就需要被管理，就会提到 `skb`，这个我暂时不考虑。

>   注意：位段这种东西可移植性可能不太友好，上述只是简单原理阐述，内核实现的实际情况会可能会非常复杂。

`UDP` 的不可靠（不是缺点）在于，如果 `UDP` 的数据包丢弃了、校验失败了也不关心、不重传，但是代码维护必然简单、开发效率高。并且不会对报文拆分，怎么发就必须怎么收，也就是面向数据报。

如何理解 `sendto/recvfrom/write/read/recv/send` 等 `IO` 接口呢？实际上不是直接在网络中读写，这些函数实际是拷贝函数，是数据的搬运工（通过缓冲区，如果有的话）。至于什么时候发、发多少、出错了怎么办...就是传输层（或者说内核）所关心的。

但是 `UDP` 不太需要发送缓冲区，调用 `sendto()` 的时候会直接交给内核，在往下层通过网路发送出去。但是 `UDP` 具有接受缓冲区，但是这个缓冲区不保证收到的 `UDP` 报文的顺序和发送 `UDP` 报文的数据一致，有可能导致乱序，这也是一种不可靠性。

全双工只要互相不影响接受缓冲区就行。

`UDP` 的大小其实有点小，`UDP` 长度限制的原因。

基于 `UDP` 协议的应用层协议有很多：

基于 `UDP` 协议的应用层协议有很多，以下是其中一些常见的：

-   **NFS(Network File System)**：是一种网络分布式文件系统
-   **TFTP(Trivial File Transfer Protocol)**：`TFTP` 是一个简单的文件传输协议，通常用于在局域网内传输小文件
-   **DHCP(Dynamic Host Configuration Protocol)**：`DHCP` 协议用于动态分配 `IP` 地址和其他网络配置参数
-   **BOOTP(Bootstrap Protocol)**：是另一个基于 `UDP` 的应用层协议。它用于在网络启动过程中为计算机分配IP地址和其他配置信息
-   **DNS(Domain Name System)**：`DNS` 协议用于域名解析，将域名映射到 `IP` 地址
-   **SNMP(Simple Network Management Protocol)**：`SNMP` 协议用于网络设备的监控和管理

## 2.2.TCP 协议

`TCP(Transmission Control Protocol)` 结构如下。

![image-20240403122019717](./assets/image-20240403122019717.png)

如何分离、如何交付？`TCP` 报头是变长的，变长的数据在选项里，由 `4` 位首部长度来决定，但是有单位，是 `4` 字节，也就是 `4*15=60` 字节，也就是 `[20, 60]` 个字节，因此首部范围就是 `[5, 15]==[0101, 1111]`。

提取 `20` 字节，进一步获取首部长度 `*4-20` 查看是否得到 `0`，是 `0` 就 `done`，否则就是选项的长度，读取选项的字节数据即可，自此读完了整个报头，剩下的就是报文数据。

这就是解包的过程，而封装的过程和之前的类似。并且 `TCP` 没有关于报文长度的大小，只有报文长度的大小，这是因为面向字节流的特性原因（保证数据完整性需要应用层来保证）。

而报头实际上就是一个数据结构。

那么 `TCP` 的可靠性怎么理解？不可靠的原因是什么？两台计算机之间的中间设备过多、距离过长，导致数据丢包。

网络中不存在百分百可靠（最新数据的发送无法保证可靠性 ），但是在局部可以做到，只要旧发送消息可以接受到匹配的回应就可以保证百分百可靠（回答了就可以保证对方一定接受到了）。

而这个确认应答的机制由序号和确认序号来完成。

客户端可能向服务端发送多个报文，就有发送顺序的问题，发送的顺序不一定是接受的顺序，但是客户端如何确定哪一个应答对应哪一个请求呢？

每一个报文一定是携带了完整的报头。

而这个 `TCP` 报文的发送会携带序号，填充 `32` 位序号，发送回来的时候在确认序号中 `+1`，这样请求和应答就需要一一对应。确认序号对应的数字，表示之前收到的报文已经全部收到了，下次发送就应该从此时的序列号开始发送。允许部分确认丢失，或者不给应答。

为什么搞两个序号呢？是因为 `TCP` 是全双工的，服务端有可能既想给对方确认，又想给对方发消息（发回消息本身就是一种应答）。

而乱序问题也不用担心，`TCP` 的每次发送，都会携带序号，只需要进行排序就行，就可以保证按需到达。

序号的作用有两个：一个是确认应答，一个是按序到达。

保留 `6` 位留作扩充准备，暂时不提。

`16` 位窗口大小呢？`TCP` 是存在接受缓冲区和发送缓冲区的。

`TCP` 叫做传输控制协议，就是因为在进行 `IO` 操纵的时候就是当初拷贝到缓冲区，然后 `TCP` 协议自行进行控制的。

这样就有两对接受和发送缓冲区，此时就可以支持全双工通信的原因。















