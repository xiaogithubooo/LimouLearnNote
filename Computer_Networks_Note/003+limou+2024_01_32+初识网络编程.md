# 1.端口号

理解源 `IP` 地址和目的 `IP` 地址：

-   **源 IP 地址（Source IP Address）**：这是指发起通信的设备的 `IP` 地址。在网络通信中，每个设备都被分配一个唯一的 `IP` 地址，用于标识其在网络上的位置。

-   **目的 IP 地址（Destination IP Address）**：这是指接收通信的设备的 `IP` 地址。它告诉网络中的路由器或交换机将数据包发送到哪个设备。

**端口号（Port）** 是传输层协议（如 `TCP` 或 `UDP`）中的一个概念，用于标识一个特定的进程或服务。它是一个 `16` 位的整数，取值范围是 `0-65535`。端口号告诉操作系统，接收到的数据包应该被交给哪个进程或服务处理。`IP` 地址和端口号的组合可以唯一标识网络上的某一台主机的某一个进程。

端口号和进程 `ID` 都是用来 **唯一标识** 一个进程的。在网络通信中，端口号是用于标识不同服务或应用程序的，而进程 `ID` 是操作系统内部用于标识运行中的进程的。

但是端口号是在网络通信中使用的标识，而进程 `ID` 是操作系统内部使用的标识。一个进程可以同时绑定多个端口号，以便提供多个不同的服务，但是一个端口号不能被多个进程 `ID` 绑定。而取两种说法主要是为了将进程范畴和网络范畴进行解耦。

>   补充：如果你有一个使用 `IP` 地址和端口号的通信场景，比如 `QQ` 消息的发送，源 `IP` 地址是发送方的 `IP` 地址，目的 `IP` 地址是接收方的 `IP` 地址，而端口号则用于区分不同的服务或程序，确保消息到达正确的应用程序或进程。

这样，用户主机和服务主机内的通信，也就是客户端进程和服务端进程之间的进程通信，这就是网络通信的本质。数据在主机间转发仅仅是基本的手段，更为重要的是将数据交给双方主机中对应的进程，也就是将进程和一台主机的特定端口号来关联。

`IP地址 + 端口号` 就标识了全网内唯一的一个进程，两份这样的“数据对”：

-   套接字：`SRC_IP+SRC_PORT`
-   套接字：`DST_IP+ log.hpp (0)Searching DST_PORT`

两份套接字再进行关联就建立了客户端和服务端的连接，其后续的编程也就是 **套接字编程**。

而端口又涉及到 `TCP` 协议和 `UDP` 协议，这两种协议都在传输层被使用。

## 1.1.简单理解 UDP 协议

**传输层协议**：该协议在传输层中被使用

**无连接**：不用在代码中刻意建立连接，是直接发送的（类似给某人写信）

**不可靠传输**：在网络不可靠的情况下，有可能出现丢包和乱序的问题（但在网络中依旧被采纳），使用于实时性要求较高的应用

**面向数据报**：待补充...

## 1.2.简单理解 TCP 协议

**传输层协议**：该协议在传输层中被使用

**有连接**：需要在代码中建立连接（类似给某人打电话）

**可靠传输**：适用于需要可靠数据传输的应用，但可靠的编码代价有可能会让应用缺失实时性，并且更加复杂

**面向字节流**：待补充...

>   补充：一般实时性不强的应用会优先使用 `TCP`，有些应用还支持用户自定义选择。

# 2.网络字节序

内存中的多字节数据相对于内存地址有大小端之分，磁盘文件中的多字节数据相对于文件中的偏 移地址也有大端小端之分，而网络数据流同样也有大端小端之分。

发送主机通常将发送缓冲区中的数据按内存地址 **从低到高的顺序发出**，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是 **按内存地址从低到高的顺序保存**，因此网络数据流的地址应规定：

-   先发出的数据是低地址，后发出的数据是高地址
-   `TCP/IP` 协议规定, 网络数据流应采用大端字节序，即低地址高字节
-   不管主机是大端机还是小端机，都按照 `TCP/IP` 规定的网络字节序来发送/接收数据
-   如果当前发送主机为小端，就需要先将数据转成大端，否则忽略转化直接发送即可

为使网络程序具有可移植性, 使同样的 `C` 代码在大端和小端计算机上编译后都能正常运行, 可以调用以下库函数做网络 字节序和主机字节序的转换。

1.  **`htons` 和 `ntohs`：**

    ```cpp
    uint16_t htons(uint16_t hostshort);
    uint16_t ntohs(uint16_t netshort);
    ```

    将 `16` 位主机字节序的整数转换为网络字节序

    将 `16` 位网络字节序的整数转换为主机字节序

2.  **`htonl` 和 `ntohl`：**

    ```cpp
    uint32_t htonl(uint32_t hostlong);
    uint32_t ntohl(uint32_t netlong);
    ```

    与 `htons` 和 `ntohs` 类似，用于 `32` 位整数。

>   补充：`h` 表示 `host`，而 `n` 表示 `network`。

# 3.socket 编程

## 3.1.套接字编程分类

`socket` 被翻译为“套接字”。

这套接口的标准是基于 `POSIX` 的，常见的 `socket` 分类主要有：

1.   **域间 socket：** 常见于本地通信，和命名管道通信很是类似。
2.   **原始 socket：** 通常指的是在网络层（`OSI` 模型的第三层）直接操作数据包的一种套接字。使用原始套接字，需要特殊的权限，程序可以发送和接收未封装的数据包，而不被协议栈处理，这使得程序可以更底层地控制网络数据的处理（但是这样的操作可能对网络和系统造成风险）。
3.   **网络 socket：** 通常用于描述一般的网络编程中的套接字。常见的网络 `socket` 包括 `TCP socket` 和 `UDP socket`，它们分别基于 `TCP` 和 `UDP` 传输协议，是应用层与传输层之间的接口。

上述三种应用场景，理论上应该是有三种接口，但是 `Linxu` 上统一使用同种接口，而我们重点学习网络套接字。

其中参数 `sockaddr` 结构如下：

![image-20240131202821642](./assets/image-20240131202821642.png)

根据地址类型判断是哪一种 `socket` 通信。

## 3.2.套接字数据结构

## 3.3.套接字编程应用

```cpp
//套接字编程常见 API
#include <sys/types.h>
#include <sys/socket.h>

//socket 编程 API
//创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)
int socket(int domain,
           int type,
           int protocol);
//1.domain：套接字域，指明将来创建的套接字类型，常见类型如下：
	//(1)AF_UNIX、AF_LOCAL：本地通信
    //(2)AF_INET：网络通信(IPv4)，一般用这个
//2.type：通信类型，指明通信类型，文件和管道是流式类型，UDP 是面向数据报的，也就是无需建立连接，独立发送数据，一般填 SOCK_DGRAM 用户数据报
//3.protocol：协议类别，基本上前面两个参数填好了这个就固定了，填 0 即可

//成功的时候返回一个套接字（类似文件描述符），失败返回负值并且设置 errno

//绑定套接字 (TCP/UDP, 服务器)
int bind(int socket,
         const struct sockaddr *address,
         socklen_t address_len);
//可以将用户指定的 ip 和 port 在内核中进行强关联，使用结构体 sockaddr_in 的时候还需要额外加多两个头文件 <netinet/in.h> <arpa/inet.h>，该结构体需要设置好 sin_port=port 和 sin_addr.s_addr=ip，设置之前可以先使用 void bzero(void*s, size_t n) 把指定的空间进行清零（该库函数的头文件为 <strings.h>）
//1.socke：直接填入获取到的 port
//2.address：填入使用接口 inet_addr(const char* cp, struct in_addr* inp) 转化的 ip，该接口需要包含头文件 <sys/socket.h> <netinet/in.h> <arpa/inet.h>
//3.address_len：传入的对象结构体的字节长度（sizeod）

//成功返回 0，失败返回负值并且设置 error

//开始监听 socket (TCP, 服务器)
int listen(int socket,
           int backlog);

//接收请求 (TCP, 服务器)
int accept(int socket,
           struct sockaddr* address,
           socklen_t* address_len);

//建立连接 (TCP, 客户端)
int connect(int sockfd, 
            const struct sockaddr *addr,
            socklen_t addrlen);

ssize_t recvfrom(int sockfd, void *buf, size_t len,
                 int flags,
                 struct sockaddr* src_addr,
                 socklen_t* addrlen);
//该函数用于接受发送端的数据
//1.sockfd：本程序申请到的套接字
//2.buf、len：buf 指向读取缓冲区，len 是读取缓冲区的大小
//3.flag：表示调用操作的可选标志，常用的标志有 MSG_CONFIRM、MSG_DONTWAIT、MSG_ERRQUEUE 等，不用设置为 0 即可
//4.src_addr（输出型参数）：表示用于存储发送端地址信息的结构体 sockaddr 的指针，如果不需要知道发送端地址则可以传入 NULL
//5.addrlen（输出型参数）：对于输入参数，表示指定 src_addr 缓冲区的长度，对于输出参数，表示返回 src_addr 结构体的实际长度
    
//最后两个参数会得到发送端的套接字
//读取失败返回 -1
    
ssize_t sendto(int sockfd, const void* buf, size_t len,
               int flags, 
               const sockaddr* dest_addr,
               socklen_t addrlen);
//写回发送端
```

