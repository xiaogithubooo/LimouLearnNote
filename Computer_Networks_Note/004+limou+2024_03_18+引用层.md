>   前要：程序员在网络程序上编写满足日常需求的网络程序基本都是在应用层编写的（包括我们之前编写的套接字编程）。
>
>   我们之前读写数据都是按照字符串的方式来发送和接收的，那如果是具有 `结构化的数据` 怎么办呢？哪个时候就需要客户端和服务端规定传输数据的规格直接进行传输（这也就是为什么读写接口不直接使用类型为 `char*` 的缓冲区而是使用 `void*` 的原因），但是这种做法拓展性很差，很容易失效。
>
>   而如果我们先使用结构来定义交互的信息，但按照某个规则转化为字符串，接受数据时把字符串转化为结构体。而这个过程，就是所谓 `序列化(多变一)` 和 `反序列化(一变多)` 的概念。
>
>   假设我们需要实现一个网络计算器，就需要：
>
>   ```cpp
>   typedef struct Request {
>       int a;
>       int b;
>       char op;
>   } Request;
>   
>   Request req = { 10, 20, '+' };
>   ```
>
>   将 `102, 20, '+'` 转化为 `"10 20 +"`，通过网络把字节流传输到另外一段，当然这是一种理想情况，如果制定协议的双方明确各种大小端和对齐规则，很可能直接就传递一个结构数据，在另一端直接进行解析。
>
>   但是，这种做法只适合较为底层的协议，这些协议封装的很好，几步无需担心出错的问题。
>
>   而我们自己写的应用程序代码会经常改动需求，导致容易出错，因此就会采取序列化核反序列化的做法，这种做法相当于加了一层软件层，把应用和网络进行解耦。
>
>   而更进一步，也可以认为协议定制的时候，需要用到的字段也是协议的一部分。协议是一种约定，但是这种表述太抽象，具体到代码中就是提前定制好字段的内容，字段的相关解析工作...

