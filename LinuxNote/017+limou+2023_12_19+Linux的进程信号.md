>   注意：首先需要提醒一个事情，信号量和本节提及的进程信号没有任何关系，请区分对待。

# 1.信号概念

## 1.1.生活中的信号

我们在生活中通过体验现实，记忆了一些信号，并且知道根据信号来做出对应的动作。

-   我们的大脑可以识别出信号，知道后执行对应的动作
-   如果没有特定信号，我们也知道该继续做什么
-   收到信号后，不一定就要立刻执行，需要先被临时记住

## 1.2.进程中的信号

那什么是 `Linux` 信号呢？其本质是一种通知机制，由用户或者操作系统发送给进程，因此进程是接受信号的载体，因此要谈信号，就离不开进程的基础。进程要处理信号，就必须要由识别信号的能力，然后进行处理，这套识别机制由程序员编写。

而进程接受到的信号是随机的，在信号没有产生之前，进程依旧在做自己的任务。而进程忙碌的任务很可能很重要，进程此时无法根据信号做出改变，除非信号更加重要，因此信号也就有优先级的区分，也可以被存储起来。

信号的产生对于进程而言是异步的，关于异步的概念，双方并没有在互相等待（若有一方会进行等待就是同步）。

有了这些铺垫，我们再来细细学习信号的内容。



# 2.信号处理

信号处理有几个常见的处理逻辑：

1.   默认处理：进程默认自带的处理信号的方式，由程序写好的逻辑
2.   忽略处理：有些信号对进程有害或者进程没有对应处理逻辑的，就需要忽略该信号
3.   自定义处理：自定义捕捉某些信号

# 3.信号分类

在操作系统中可以使用 `kill -l` 看到关于信号的列表，并且有对应的解释说明：

```cmd
# 查看系统的信号
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2     
```

其中 `[1, 31]` 为普通信号，最为常用，后面 `[34, 64]` 为实时信号，比较少用，除非是某些特殊的行业。

而查看特定信号的详细描述则可以使用指令 `man 7 signal` 来查看

```cmd
# 查看特定信号的详细描述
Signal     Value     Action   Comment
──────────────────────────────────────────────────────────────────────
SIGHUP        1       Term    Hangup detected on controlling terminal
                             or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction
SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                             readers
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
SIGCHLD   20,17,18    Ign     Child stopped or terminated
SIGCONT   19,18,25    Cont    Continue if stopped
SIGSTOP   17,19,23    Stop    Stop process
SIGTSTP   18,20,24    Stop    Stop typed at terminal
SIGTTIN   21,21,26    Stop    Terminal input for background process
SIGTTOU   22,22,27    Stop    Terminal output for background process

The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
```

有些时候多个值可以表示同一个信号，`Action` 是信号对应的处理动作（也就是默认从忽略行为，大部分都是终止）。`[ctrl+z]` 实际就是向进程发送了 `2` 号信号。

这里有几个问题需要我们思考：

1.   如何理解信号被进程保存起来呢？信号不就是一些值么，进程要保存一个数据那还不简单，只要内部要可以保存进程信号的相关数据结构就可以。而使用位图来保存，就再合适不过了（可以去`task_struct{/*...*/};`里去找找）。
2.   如何理解信号被发送呢？而由于这是修改内存级别的数据结构，只有操作系统自己才有资格进行改动，因此我们自己发送信号亦或者是其他的信号，最后都是由操作系统向目标进程发/写信号（修改`task_struct{/*...*/};`指定的位图结构），也只有操作系统有这个权力，我们只不过是借助操作系统的“手”罢。
3.   如何理解组合键`[ctrl+z]`变成信号呢？键盘工作原理是中断机制，操作系统识别到组合键后，根据进程列表，找到前台运行的进程，然后写入（发送）对应信号到进程内部的位图结构中，而至于信号什么时候被进程处理，就交给进程衡量。

# 2.信号产生

## 2.1.通过终端按键产生信号



## 2.2.通过系统调用产生信号



## 2.3.通过软件条件产生信号



## 2.4.通过硬件异常产生信号



# 3.信号捕捉

# 4.信号阻塞