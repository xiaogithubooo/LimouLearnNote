# 1.进程创建

在`Linux`中，`fork()`可以从已经存在的进程中创建一个新进程，新进程为子进程，原进程为父进程。

```c
#include <unistd.h>//需要包含的头文件
pid_t fork(void);
//返回值：子进程中返回0，父进程返回子进程id，出错返回-1
```

具体的使用如下：

```c
#include <stdio.h>
#include <unistd.h>
int main()
{
    printf("我是父进程\n");
    pid_t id = fork();
    if (id < 0)
    {
        printf("创建子进程失败 n");
        return 1;
    }
    else if (id == 0)
    {
        // 子进程
        while(1)
        {
            printf("我是子进程: pid: %d，ppid: %d\n", getpid(), getppid());
            sleep(1);
        }
    }
    else 
    {
        //父进程
        while(1)
        {
            printf("我是父进程: pid: %d，ppid: %d\n", getpid(), getppid());
            sleep(1);
        }
    }
    return 0;
}
```

`fork()`使得系统多了一个进程，父进程调用`fork()`后，当控制转移到内核中的`fork()`代码后，内核做了：

1. 分配新的内存块和内核数据结构给自己从

2. 将父进程部分数据结构内容拷贝到子进程中

3. 添加子进程搭配系统进程列表中

4. `fork()`返回，开始调度器调度

子进程没有自己的代码和数据，所以子进程只能使用父进程的代码和数据。

1. 而对于代码：都是不可写的，只可读，所以父子共享（共享所有的代码）没有问题

2. 而对于数据：不能直接共享，有可能需要隔离开，避免互相影响（隔离是通过页表来实现的）但是不需要对“不会访问”或者“只做读取”的数据拷贝，但是操作系统并没有立刻进行拷贝（因为有可能给了子进程，而子进程页也暂时用不到），而是使用了“写时拷贝”技术实现父子间数据分离，也就是写入的时候才进行拷贝，提高效率（这个分离类似深浅拷贝）。

因为进程有可能会被中断（可能没有执行完）下次继续执行的时候就需要知道从哪行代码继续开始，这个时候就需要`PC`（`pointer code`）指针（也就是`EIP`寄存器）类记录当前进程的执行位置。

所以子进程虽然可以看到`fork()`之前的代码，但是可以从创建开始从`fork()`开始，因此不会出现父进程创建子进程，子进程创建子子进程...这种死循环情况。

# 2.进程终止

## 2.1.进程终止的情况

在以下情况：

1. 代码运行完毕，结果正确

2. 代码运行完毕，结果错误

3. 代码异常终止，程序崩溃

需要强行让进程终止（释放进程申请的相关内核数据和对应的代码和数据），本质就是释放系统资源（主要是内存资源还有`CPU`资源）。

## 2.2.进程终止的信息

进程退出码我们是有了，但是只有一串数字，这是无法进行错误探究的，所以我们需要将错误码/退出码转化为包含错误信息字符串的方案（例如使用`strerror()`来转化错误码为信息字符串）。

并且我们也可以自己设计一套退出方案。

我们也可以去打印一下系统的退出码有哪些。

## 2.3.进程终止的方法

### 2.3.1.正常终止

`main`函数的返回值叫做进程退出码，除了`0`还可以是其他值。

可以使用其他值（例如：`return 10`）试试，然后通过`echo $?`可以查看最近一次进程返回的退出码。

```bash
$ ll
total 0

$ vim test.c
$ cat test.c
#include <stdio.h>
int main()
{
    const char* s = "Hello, I am limou~\n";
    printf("%s", s);
    return 10;
}

$ gcc test.c
$ ./a.out
Hello, I am limou~

$ echo $?
10
```

因此实际上在代码中正常终止进程的方法有：

1. 从`main()`的`return`语句返回（这也是为什么`C`语言代码运行成功后返回`0`的原因）。而`return`对于`mian()`是进程终止，但是对于其他被`main()`调用的子函数来说只是函数的返回值。

2. 在代码中手动调用`exit()`，引起正常进程终止，头文件是`<stdlib.h>`，该函数在代码的任何地方语义都是一样的（都是终止进程，不同于`return`语句，因此一般推荐使用这个函数终止进程）

3. 使用`_exit()`，上面的`exit()`是`C`语言提供的，而实际上还有一个系统接口方案`_exit()/_Exit()`，头文件为`<unistd.h>`。虽然也是终止进程的，但是和`exit()`也还有一些差别

> 补充：`exit()`的会刷新缓冲区数据，但是`_exit()`不会刷新，也就是说`C`提供的`exit()`多了一些“动作”（执行用户的权力函数、冲刷缓冲、关闭流等），然后才终止进程。而在实际开发上，我们更加推荐使用`exit()`。
> 
> 而在这个缓冲区在哪里呢？但是我们可以肯定：缓冲区一定不在操作系统内部。如果由操作系统内部维护的话，那么`_exit()`也可以刷新，这个缓冲区是`C`标准库维护的。

### 2.3.2.异常退出

使用快捷键`[ctrl+c]`来终止信号。

# 3.进程等待

## 3.1.进程等待的目的

如果子进程退出，父进程不再理会，就有可能造成僵尸进程，使用`kill -9`也无法去除（因为这个进程已经“死”了）。此时进程占用着资源，造成内存泄露。

因此父进程给子进程派遣任务后，需要知道子进程的运行结果，说否正确、是否退出。

这个时候父进程就通过进程等待的方式，回收子进程资源，获取子进程退出信息。

## 3.2.进程等待的方法

1. `wait()`

```c
#include<s ys/types.h>  
#include<sys/wait.h>  
pid_t wait(int*status);  
//返回值：  
    //返回被等待进程pid，失败返回-1

//参数：  
    //输出型参数，获取子进程退出状态，不关心则可以设置成为NULL
```

父进程调用`wait()`后，处于阻塞状态，等待子进程变成“僵尸”状态，回收子进程资源。

2. `waitpid()`

```c
pid_ t waitpid(pid_t pid, int *status, int options);  
//返回值：  
    //1.当正常返回的时候waitpid返回收集到的子进程的进程ID；
    //2.如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0（也就是调用该函数成功，但是子进程并未全部退出）；
    //3.如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在； 

//参数：  
    //1.pid：
        //1.1.Pid=-1，表示等待任一个子进程，与wait等效（有可能存在多个子进程的情况）
        //1.2.Pid>0，等待其进程ID与pid相等的子进程
        //1.3.pid=0，TODO
    //2.status:  
        //2.1.WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）  
        //2.2.WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）  
    //3.options:
        //设置父进程处于阻塞状态等待回收子进程则设置为0，该参数默认为0
        //设置非阻塞等待则使用WNOHANG若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID
```

> 注意：这两函数有相同的地方，`wait(NULL) <=> waitpid(-1, NULL, 0) `

需要注意的是`status`输出型参数是按照`32`比特位的方式整体使用的，我们只了解低的`16`位就可以。其中：

1. 次低`8`位表示退出状态（使用`(status>>8) & 0xFF`获取。通过返回码判断程序是否正确）

2. 低`7`位表示进程收到的信号（使用`status & 0x7F`获取。信号`0`表示程序正常运行，非`0`为奔溃。通过信号判断是否异常）

3. 还有`1`个比特位是`core dump`标志，这个我们之后再来谈

因此我们需要对输出做一定位操作，才能得到子进程使用`exit()`返回的退出码。

程序（更准确来说是进程）奔溃或异常退出的本质是：操作系统`kill`掉了您的进程（这和信号有关，操作通过信号来`kill`）。

另外，进程异常也不单单是内部代码的问题，也有可能受到外部影响（比如：子进程被我们自己使用`kill -9`信号杀掉了，此时退出码没有任何意义）。

`wait()/waitpid()`本质是读取了子进程的`task_struct`内部的进程退出结果信号，这点可以从内核的源代码中查看到存在字段`int exit_code, exit_signal`。

而这个两个函数是“系统调用”的一种，当然有权限访问`PCB`结构体内部的这一字段。

操作系统层面的内存泄露是不会自动释放的，这和用户使用`malloc()`有些不同。

只有子进程退出的时候，父进程才会使用上述的两个函数后面的代码，此时父进程还活着（处于阻塞状态）。因此这此时的子进程具有一定的顺序性。

但是父进程处于阻塞状态时（进程阻塞的本质是进程阻塞再系统函数的内部，后面的代码不再执行，条件满足的时候父进程才会唤醒，继续在`waitpid()`中向后执行）有些浪费资源，因此我们可以可以使用`options=WNOHANG`来使父进程和未结束的子进程一起运行。

# 4.进程替换

## 4.1.进程替换概念

之前我们是父进程创建子进程，子进程共享父进程的代码，那有没有办法做到子进程单独使用自己的程序呢？可以使用程序替换就可以做到。

程序替换是通过特定的接口，加载磁盘上的一个权限的程序（代码和数据），加载到调用进程的进程地址空间中。也就是说，子进程往往要调用一种`exec`函数来执行另一个程序。当进程调用该函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用`exec()`并不创建新进程，所以调用`exec`前后的进程`id`没有改变。

## 4.2.进程替换函数

`exec`系列函数本质是加载程序的函数（加载器）。

```c++
#include <unistd.h>

int execl(const char *path, const char *arg, ...);

int execv(const char *path, char *const argv[]);

int execlp(const char *file, const char *arg, ...);

int execvp(const char *file, char *const argv[]);

int execle(const char *path, const char *arg, ..., char *const envp[]);
```

### 4.2.1.execl()

`path`是程序的路径，`arg`和可变参数列表传入命令行参数，并且要以`NULL`结尾表示命令结束。

一旦`execl()`调用成功，后续的代码就会被替换（实际上前面的代码也会被替换，但是前面的代码先运行了）

如果调用`execl()`后失败，依旧会继续执行后面的代码，而不会进行替换。

`execl()`调用成功是不会有返回值的，因为被替换前的代码已经全部被替换了，也不需要返回值了。

因此不需要判断返回值类查看是否成功替换，失败就直接在`execl()`后使用`exit()`退出即可。

如果没有子进程，就必须替换父进程，此时就会影响父进程（子进程存在的意义就在此，父进程像包工头：揽活，子进程就像工人：干活）。

在加载新程序之前，父子进程的数据和代码关系：代码共享、数据写时拷贝。加载新程序后，实际上也是一种数据写入，那么代码需不需要写时拷贝，将父子的代码隔离？是的，必须要分离。因此在进程替换这一环节，数据和代码都是进行写时拷贝。

### 4.2.2.execv()

可以把`execl()`中的`l`看作`list`理解，把`execv()`中的`v`看作`vector`理解。因此两个函数只是传参方式有些许不同，其他都一样。

### 4.2.3.execlp()

这个`p`就是指`path`，会在环境变量中查找程序名字进行替换

### 4.2.4.execvp()

这个函数就是`execv()`和`execlp()`的结合版本，但是会多出一些信息（`inode`）。

### 4.2.5.execle()

可以向目标进程传递环境变量。

无论是什么变成语言最后都会变成进程，因此上述的函数可以做到调用其他语言的进程。

另外，上述函数都不是严格意义上的系统接口，真正的系统接口是`execve(const char* filename, char* const argv[], char* const envp[]);`，上述六个函数都是调用这个系统接口的派生函数。

# 5.简易shell

利用我们当前的知识可以撰写一个简单的`shell`外壳程序。

```c
//myshell.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#define NUM 1024
#define SIZE 32
#define SEP " "
char cmd_line[NUM];//保存完整命令字符串
char* g_argv[SIZE];//保存打散后的命令字符串
int main()
{
    while(1)
    {
        //1.打印提示信息
        printf("[user@myshell]$ ");
        fflush(stdout);
        memset(cmd_line, '\0', sizeof(cmd_line));
        //2.获取user的输入
        if(fgets(cmd_line, sizeof(cmd_line), stdin) == NULL)
        {
            //出错处理
            continue;
        }
        cmd_line[strlen(cmd_line) - 1] = '\0';
        //3.命令行字符解析
        //虽然可以自己写一个算法解析，但是我们可以一些现有的接口
        g_argv[0] = strtok(cmd_line, SEP);//第一次调用需要传入原始字符串

        int index = 1;
        if(strcmp(g_argv[0], "ls") == 0)
        {
            g_argv[index++] = "--color=auto";
        }
        while(g_argv[index++] = strtok(NULL, SEP));//第二次还想要解析原始字符串，就需要传入NULL
        //4.TODO                                                
        //需要判断命令，如果是cd这样的命令不能使用子进程
        if(strcmp(g_argv[0], "cd") == 0)       
        {   
            printf("下面功能让父进程来\n");
            //更改路径的命令
            if(g_argv[1] != NULL) chdir(g_argv[1]);
            continue;
        }  
        //5.fork()
        pid_t id = fork();
        if(id == 0)//child
        {
            printf("子进程run：\n");
            execvp(g_argv[0], g_argv);
            exit(1);
        }
        //father
        int status;
        pid_t ret = waitpid(id, &status, 0);
        if(ret > 0) printf("exit code: %d\n", WEXITSTATUS(status));
    }
    return 0;
}
```
