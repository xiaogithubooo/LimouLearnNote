# 1.进程通信认知

## 1.1.进程通信目的

1.   **数据传输**：将进程的数据发送给另一个进程
2.   **资源共享**：多个进程之间共享某种资源
3.   **通知事件**：一个进程需要向另一个进程或者一组进程发送消息，通知发生了某种事件（如：进程终止时要通知父进程）
4.   **进程控制**：有些进程希望完全控制另一个进程的执行（如：`Debug`进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

由于进程是具有独立性的，因此两者想要交互数据的难度比较大，需要有一个媒介（让不同的进程看到一个相同的资源），也就是内存空间。利用内存空间，进程之间就可以交互数据。

## 1.2.进程通信发展

进程之间的通信从古老的管道一直发展到`System V`进程通讯和`POSIX`进程间通信。

| 管道           | System V IPC       | POSIX IPC |
| -------------- | ------------------ | --------- |
| 匿名管道`pipe` | `System V`消息队列 | 消息队列  |
| 命名管道       | `System V`共享内存 | 共享内存  |
|                | `System V`信号量   | 信号量    |
|                |                    | 互斥量    |
|                |                    | 条件变量  |
|                |                    | 读写锁    |

# 2.管道

管道的来源很早（但是并没有被抛弃，相反使用得还挺多），源于`Unix`中的进程通信。把“一个进程”连接到“另一个进程”的”一个数据流“称为”一个管道“。这个管道的作用很类似现实生活中的管道，都是进行”传输“的作用。不过这个管道只可以单向通行，传送进程需要的资源。而为了保持进程之间的独立性，管道需要由操作系统（内核）来管理。

管道本质一个文件，可以被多个进程以文件的形式被进程们看到，但是管道是很特殊的文件，和普通的文件还是有很大的区别的。

管道是`Linux`中是原生提供的。

由于进程之间通过内存中的管道文件来通信是内存级别的通信，不会写入到磁盘（这样很低效），多进程产生的数据大部分是临时数据。

## 2.1.匿名管道

创建匿名管道的接口描述：

```c++
#include <unistd.h>
int pipe(int fd[2]);
//fd是文件描述符数组，用来存储获得的文件描述符，f[0]表示管道读端，f[1]表示管道写端
//成功返回0，失败返回错误代码
```

<img src="./assets/image-20231004213142577.png" alt="image-20231004213142577" style="zoom:80%;" />

我们可以尝试使用该接口来从键盘读取数据，写入管道，然后写到屏幕，不过需要根据实际情况来控制两个进程，关闭一些不必要的文件（下面图演示父进程写入管道文件，并且交给子进程读取数据的过程）控制写入和读取（但是其实不关闭也是可以的，只是为了严谨和防御编程）。

<img src="./assets/image-20231004230933508.png" alt="image-20231004230933508" style="zoom:67%;" />

```c++
```



```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
int main()
{
    int fds[2];//该数组存储文件描述符
    char buf[100];//充当缓冲区
    int len;
    
    if (pipe(fds) == -1)//创建管道文件
        perror("make pipe"), exit(1);
    
    //read from stdin
    while (fgets(buf, 100, stdin))//从键盘获取输入
    {
        len = strlen(buf);
        //write into pipe
        if (write(fds[1], buf, len) != len)//写到屏幕上
        {
            perror("write to pipe");
            break;
        }
        memset(buf, 0x00, sizeof(buf));

        //read from pipe
        if ((len = read(fds[0], buf, 100)) == -1)
        {
            perror("read from pipe");
            break;
        }

        //write to stdout
        if (write(1, buf, len) != len)
        {
            perror("write to stdout");
            break;
        }
    }
    return 0;
}
```

## 2.2.命名管道

# 3.System V

偏向本地服务器通信，用得较少。

# 4.POSIX

偏向网络服务器通信，用得较多。

