1.环境变量概念
==========

首先要知道几个事实：

1.   `Linux`里面使用的命令行指令，也是经过代码编写产生的可执行文件。而在`Linux`下的任何文件路径都可以使用这些指令，那能不能让我们自己编写的代码也这样呢？答案是可以，不过需要使用环境变量。
2.   在编译`C/C++`代码的时候，我们是不知道链接时期需要的的动态静态库在哪里的，都是照样可以链接成功，生成可执行程序，原因也是有相关环境变量帮助编译器进行查看。

环境变量是指在操作系统中用来指定操作系统运行环境的一些参数（类似语言的全局变量），环境变量通常具有某些特殊用途，在系统中通常具有全局的特性。  

下面是一些常见的环境变量：

1. `PATH`：指定命令的搜索路径

2. `HOME`：指定用户的主工作目录（指令`cd ~`就是根据`HOME`变量来进行确认的）

3. `SHELL`：当前`Shell`，其值通常为`/bin/bash`。

4. `HISTSIZE`：其值为设置shell历史记录大小的变量（使用`history`指令可以查看`HISTSIZE`条历史指令）

5. `LS_COLORS`：环境变量是用于设置`ls`命令在终端中显示不同文件类型和属性时的颜色的变量。通过指定不同文件类型和属性对应的颜色码，可以使文件在终端中以不同的颜色进行区分和显示

6. `LOGNAME`：记录登录的用户名

7. `PWD`：保存当前的路径

`Linux`中的环境变量有很多，基本都是独立工作的，各有各的功能（在`Windows`操作系统里也是有环境变量的）。  

# 2.环境变量查看

使用命令`echo $NAME`即可查看对应变量的情况，注意需要带上`$`符号。

```bash
$ which pwd
/usr/bin/pwd

$ echo $PATH
...:/usr/bin:... #这里可以找到pwd可执行文件的所在地，还有其他的地址，使用“:”进行分割
```

还可以使用命令`env`来查看当前系统的所有环境变量（`set`命令则是显示本地定义的`shell`变量和环境变量），这里输出结果有很多，可以看到所有的环境变量及其值。

# 3.环境变量修改

如果我们想要实现我们自己编写的可执行程序和`Linux`内置指令一样的使用效果，有两种方法：

1.   把您自己写的可执行程序放进`PATH`环境变量中的文件路径下，这样就可以像使用`Linux`指令一样使用自己编写的可执行程序（一般放在`/usr/bin`下比较多，这种行为叫做“给系统安装程序”，但是这种做法不建议，有可能污染操作系统）。

2.   还有一种方法是使用命令`export <环境变量>=$<环境变量>:新值`配置`PATH`环境变量，这样操作不会污染到系统的文件。如果使用命令`unset 某环境变量`可以清除某个环境变量，如果使用`unset PATH`后就会发现其他的`Linux`指令都无法使用了，不过不用担心，下次登录还是会恢复默认的`PATH`值的，这是因为系统再重新登录的时候，会重新读取保存环境变量的文件。

>   注意：一般情况下，在`Linux`命令行中修改环境变量只适用于本次会话（本次登录），一旦退出登录就无效了，不过如果修改的是保存环境变量的文件就会永久有效。

# 4.环境变量组织

每个程序都会收到一张环境表，环境表是一个字符指针数组，每个指针指向一个以`\0`结尾的环境变量字符串，并且最后一个元素指向`NULL`，这样做就可以将所有环境变量组织起来。

因此我们编写代码的时候可以使用以下的`main()`接口来接受和操作运行程序时使用的选项和环境变量：

```cpp
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[], char* env[])
{
    if(strcmp(argv[argc - 1], "-order") == 0)
    {
        printf("---------\n");
        for(int i = 0; env[i]; i++)
        {
            printf("%s\n", env[i]);
        }
        printf("---------\n");
    }
    return 0;
}
```

# 5.环境变量接口

在上面的代码中，`main`函数可以带上三个参数，第三参数实际上就是有关环境变量的参数（前两个数选项个数和选项字符数组）：

```c
int mian(int argc, char * argv[], char * env[])
{}
```

这里的`env`数组也就对应上面提到的由环境变量构成的`char*`类型数组。

除了这种方法还可以使用`unistd.h`内定义的`environ[]`全局数组来获取环境变量的值。

但是最常用的是使用`stdlib.h`的`getenv()`函数，可以根据参数来获取对应的环境变量值（其参数是想获取环境变量的变量名字符串）。

> 补充`1`：一般`main`函数的环境变量参数是又父进程继承过来的，父进程也是从它自己的父进程获取的，因此环境变量最终在`bash`进程获取，而所有进程的父进程是当前`bash`。这也就是环境变量之所以具有全局属性的本质原因，而`env[]`参数也是依靠父进程传参的。
>
> 这种父子传递关系，您可以在`bash`下自己创建一个自定义的环境变量，然后使用`C`语言库内的`getenv()`函数读取环境变量来验证。
>
> 补充`2`：实际上对应环境变量这样的“全局变量”，还有一个“局部变量”，即：`shell`变量，就是直接在`bash`定义一个变量，这个变量可以使用`set`命令查看，但是没有办法在`C`代码中使用`getenv()`获取。
>
> `shell`变量实际上最常用的场景是在`shell`脚本里，这个`shell`脚本我们以后再提及。
