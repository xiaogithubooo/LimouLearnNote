# 1.thread 线程库

## 1.1.thread 库的简介

不同平台的线程创建都是不一样的，`C++` 有必要为了适应不同平台，而制作一个线程库来适应各个平台。

## 1.2.thread 库的使用

这里我给 `thread` 类大致的成员变量、成员函数、非成员重载，我将在后面详细介绍使用方法和一些细节：

```cpp
//thread 头文件（内含 thread 类和 this_thread 命名空间）
class thread
{
public:
    //1.构造函数
    thread();
    //2.析构函数
    ~thread();
    //3.赋值重载
    operator= ();
    //4.获取进程 ID
    get_id();
	//5.检查是否可接合
    joinable();
    //6.加入线程
    join();
    //7.删除进程
    detach();
    //8.交换进程
    swap();
    //9.获取本地句柄
    native_handle();
    //10.检测硬件并发
    [static] hardware_concurrency();
};

namespace this_thread
{
    //1.获取本进程的 id
    get_id();
    //2.本进程主动转让时间片
    yield();
    //3.
    sleep_until();
    sleep_for();
}
```

>   补充：上述类只是伪代码，更加详细的说明和描述您可以去 [cplusplus-string](https://legacy.cplusplus.com/reference/thread/thread/) 上查询...

`noexcept` 明确函数不会抛出异常。

`C++` 将线程作为对象来看。

线程对象不允许拷贝构造，但是允许移动构造。

线程对象的 `id` 是自定义类型。

```cpp
//创建多线程
#include <iostream>
#include <vector>
#include <thread>
using namespace std;

void Print(int n)
{
	for (int i = 0; i < n; ++i)
	{
		cout << this_thread::get_id() << " 结果:" << i << '\n';
		this_thread::sleep_for(chrono::milliseconds(100)); //休眠 100 微秒再输出
	}		
}

int main()
{
	vector<thread> threads;
	for (int i = 0; i < 3; i++)
	{
		threads.push_back(thread(Print, 10)); //注意这里只能使用移动构造（线程对象不允许拷贝），因此从这里
	}

	for (int i = 0; i < 3; i++)
	{
		threads[i].join();
	}

	return 0;
}

/* 输出结果
略...
*/
```

暂无...

# 2.mutex 互斥锁库

## 2.1.mutex 类的简介

## 2.2.mutex 类的使用

这里我给 `thread` 类大致的成员变量、成员函数、非成员重载，我将在后面详细介绍使用方法和一些细节：

```cpp
class mutex
{
    //1.构造函数
    mutex();
    //2.阻塞式的加锁
    lock()
    //3.非阻塞式的加锁
    try_lock();
    //4.解锁
    unlock();
    //5.获取线程的操作系统级句柄
    native_handle();
};
```

锁也不允许拷贝。

```cpp
//多线程内使用全局锁
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
using namespace std;

mutex mtx;
void Print(int n) //C++ 这里关于线程的函数调用，传参是执行的都是拷贝行为（貌似会忽略左右值引用，这点很怪异，以后研究一下，但是换成其他引用参数确实也有这样奇怪的行为）
{
	for (int i = 0; i < n; ++i)
	{
		mtx.lock();
		cout << this_thread::get_id() << " 结果:" << i << '\n';
		mtx.unlock();
		this_thread::sleep_for(chrono::milliseconds(10)); //休眠 10 微秒再输出
	}
}

int main()
{
	vector<thread> threads;
	mutex mtx;
	for (int i = 0; i < 3; i++)
	{
		threads.push_back(thread(Print, 10)); //注意这里只能使用匿名线程对象的移动构造（线程对象不允许拷贝）
	}

	for (int i = 0; i < 3; i++)
	{
		threads[i].join();
	}

	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//多线程内使用局部锁（错误写法）
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
using namespace std;

void Print(int n, mutex& mtx) //C++ 这里关于线程的函数调用，传参是执行的都是拷贝行为（貌似会忽略左右值引用，这点很怪异，以后研究一下，但是换成其他引用参数确实也有这样奇怪的行为）
{
	for (int i = 0; i < n; ++i)
	{
		mtx.lock();
		cout << this_thread::get_id() << " 结果:" << i << '\n';
		mtx.unlock();
		this_thread::sleep_for(chrono::milliseconds(10)); //休眠 10 微秒再输出
	}
}

int main()
{
	vector<thread> threads;
	mutex mtx;
	for (int i = 0; i < 3; i++)
	{
		threads.push_back(thread(Print, 10, mtx)); //注意这里只能使用匿名线程对象的移动构造（线程对象不允许拷贝）
	}

	for (int i = 0; i < 3; i++)
	{
		threads[i].join();
	}

	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//多线程内使用局部锁（正确写法）
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <functional> //std::ref(val)，强制接受方变成 val 的左值引用
using namespace std;

void Print(int n, mutex& mtx) //C++ 这里关于线程的函数调用，传参是执行的都是拷贝行为（貌似会忽略左右值引用，这点很怪异，以后研究一下，但是换成其他引用参数确实也有这样奇怪的行为）
{
	for (int i = 0; i < n; ++i)
	{
		mtx.lock();
		cout << this_thread::get_id() << " 结果:" << i << '\n';
		mtx.unlock();
		this_thread::sleep_for(chrono::milliseconds(10)); //休眠 10 微秒再输出
	}
}

int main()
{
	vector<thread> threads;
	mutex mtx;
	for (int i = 0; i < 3; i++)
	{
		threads.push_back(thread(Print, 10, ref(mtx))); //注意这里只能使用匿名线程对象的移动构造（线程对象不允许拷贝），并且使用 ref() 避免锁传给 thread 的构造函数时被识别成了传值（有可能是 bug?）
	}

	for (int i = 0; i < 3; i++)
	{
		threads[i].join();
	}

	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//多线程内使用局部锁（lambda 表达式写法）
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <functional> //std::ref(val)，强制接受方变成 val 的左值引用
using namespace std;

int main()
{
	vector<thread> threads;
	mutex mtx;
	int n = 10;

	for (int i = 0; i < 3; i++)
	{
		threads.push_back(
			thread(
				[&]() { //使用 lambda 表达式
					for (int i = 0; i < n; ++i)
					{
						mtx.lock();
						cout << this_thread::get_id() << " 结果:" << i << '\n';
						mtx.unlock();
						this_thread::sleep_for(chrono::milliseconds(10)); //休眠 10 微秒再输出
					}
				}
			)
		); //注意这里只能使用匿名线程对象的移动构造（线程对象不允许拷贝），并且使用 lambda 表达式避免传参
	}

	for (int i = 0; i < 3; i++)
	{
		threads[i].join();
	}

	return 0;
}

/* 输出结果
略...
*/
```



智能锁：

```cpp
//多线程加锁下出现异常
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic> //微小的操作可以不加锁，直接使用原子操作即可
using namespace std;

int main()
{
	int m = 5;
	int n = 5;
	vector<thread> threads(m);
	mutex mtx;
	for (int i = 0; i < m; ++i)
	{
		threads[i] = thread(
			[&]() {
				for (int i = 0; i < n; ++i)
				{
					mtx.lock();
					try {
						cout << this_thread::get_id() << ":" << i << endl;
						this_thread::sleep_for(chrono::milliseconds(100));
					}
					catch (...) { //短暂捕捉
						mtx.unlock();
						throw; //重新抛出
					}

					mtx.unlock();
				}
			}
		);
	}


	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//多线程加智能锁下出现异常
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic> //微小的操作可以不加锁，直接使用原子操作即可
using namespace std;

class LockGuard
{
public:
	LockGuard(mutex& lock)
		: _lock(lock)
	{
		_lock.lock();
		cout << "加锁:" << this_thread::get_id() << endl;
	}
	~LockGuard()
	{
		cout << "解锁:" << this_thread::get_id() << endl;
		_lock.unlock();
	}
private:
	mutex& _lock; //这里必须写一个 &，代表该变量在初始化列表中被定义为外部变量的引用（注意这里只是声明）
}; 

int main()
{
	int m = 5;
	int n = 5; 
	vector<thread> threads(m);
	mutex mtx;
	for (int i = 0; i < m; ++i)
	{
		threads[i] = thread(
			[&]() {
				for (int i = 0; i < n; ++i)
				{
					LockGuard Lock(mtx);
					cout << this_thread::get_id() << ":" << i << endl;
					this_thread::sleep_for(chrono::milliseconds(100));
				}
			}
		);
	}

	for (auto& e : threads)
	{
		e.join();
	}

	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//多线程加智能锁下出现异常（使用库内的智能锁）
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic> //微小的操作可以不加锁，直接使用原子操作即可
using namespace std;

int main()
{
	int m = 5;
	int n = 5; 
	vector<thread> threads(m);
	mutex mtx;
	for (int i = 0; i < m; ++i)
	{
		threads[i] = thread(
			[&]() {
				for (int i = 0; i < n; ++i)
				{
					lock_guard<mutex> Lock(mtx);
					cout << this_thread::get_id() << ":" << i << endl;
					this_thread::sleep_for(chrono::milliseconds(100));
				}
			}
		);
	}

	for (auto& e : threads)
	{
		e.join();
	}

	return 0;
}

/* 输出结果
略...
*/
```

暂无...



# 3.atomic 原子库

## 3.1.atomic 库的简介

```cpp
class atomic
{
	//1.构造函数
    atomic();
    //2.赋值重载
    operator= ();
    
    is_lock_free();
    store();
    load();
    operator T();
    exchange();
    compare_exchange_weak();
    compare_exchange_strong();

    fetch_add();
    fetch_sub();
    fetch_and();
    fetch_or();
    fetch_xor();
    operator++();
    operator--();
    atomic::operator()
};
```

## 3.2.atomic 库的使用

`CAS` 操作（无锁操作）

```cpp
//多线程内使用局部锁避免不同步
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <functional> //std::ref(val)，强制接受方变成 val 的左值引用
using namespace std;

int main()
{
    vector<thread> threads;
    mutex mtx;
    int threadNum = 5;
    int target = 100;
    int time = 10;
    int add = 0;

    for (int i = 0; i < threadNum; i++)
    {
        threads.push_back(
            thread( //注意这里只能使用匿名线程对象的移动构造（线程对象不允许拷贝），并且使用 lambda 表达式避免传参
                [&]() { //使用 lambda 表达式
                    while (true)
                    {
                        mtx.lock();
                        if (add < target)
                        {
                            ++add;
                        }
                        else
                        {
                            mtx.unlock();
                            break;
                        }
                        cout << " add = " << add << "  id:" << this_thread::get_id() << endl;
                        mtx.unlock();
                        this_thread::sleep_for(chrono::milliseconds(time)); //休眠 10 微秒再输出
                    }
                }
            )
        );
    }

    for (auto& e : threads) e.join();

    return 0;
}

/* 输出结果
略...
*/
```

```cpp
//多线程内使用原子操作
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic> //微小的操作可以不加锁，直接使用原子操作即可
using namespace std;

int main()
{
	vector<thread> threads;
	mutex mtx;
	int threadNum = 5;
	int target = 100;
	int time = 10;
	atomic<int> add = 0;

	for (int i = 0; i < threadNum; i++)
	{
		threads.push_back(
			thread( //注意这里只能使用匿名线程对象的移动构造（线程对象不允许拷贝），并且使用 lambda 表达式避免传参
				[&]() { //使用 lambda 表达式
					while (true)
					{
						if (add < target)
						{
							++add; //这里是原子操作返回寄存器时判断是否需要覆盖（这里是对 ++ 进行了重载）
						}
						else
						{
							break;
						}
						cout << " add = " << add << endl;
						this_thread::sleep_for(chrono::milliseconds(time)); //休眠 10 微秒再输出
					}
				}
			)
		);
	}

	for (auto& e : threads) e.join();

	return 0;
}

/* 输出结果
略...
*/
```



# 4.condition_variable  条件变量库

## 4.1.condition_variable 库的简介

```cpp
class condition_variable
{
    //1.构造函数
    condition_variable();
    //2.析构函数
    ~condition_variable();
    //3.等待函数
    wait();
    wait_for();
    wait_until();
    //4.通知函数
    notify_one();
    notify_all();
};
```

## 4.2.condition_variable 库的使用

```cpp
//一个线程打印奇数，一个线程打印偶数（方式一：使用自旋锁，但不算特别好的方案）
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
using namespace std;

int main()
{
	int i = 0;

	int n = 100;
	thread t1([&]() {
		while (i < n)
		{
			while (i % 2 != 0)
			{
				this_thread::yield(); //让出时间片，自旋锁
			}

			cout << this_thread::get_id() << ":" << i << endl;
			i += 1;
		}
	});

	thread t2([&]() {
		while (i < n)
		{
			while (i % 2 == 0)
			{
				this_thread::yield(); //让出时间片，自旋锁
			}

			cout << this_thread::get_id() << ":" << i << endl;
			i += 1;
		}
	});

	t1.join();
	t2.join();
	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//一个线程打印奇数，一个线程打印偶数（方式二：直接使用锁，一种错误的写法）
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
using namespace std;

int main()
{
	int i = 0;
	int n = 100;
	mutex mtx;
	thread t1([&]() {
		while (i < n)
		{
			mtx.lock();
			cout << this_thread::get_id() << ":" << i << endl;
			i += 1;
			mtx.unlock();
		}
	});

	thread t2([&]() {
		while (i < n)
		{
			mtx.lock();
			cout << this_thread::get_id() << ":" << i << endl;
			i += 1;
			mtx.unlock();
		}
	});

	t1.join();
	t2.join();
	return 0;
}

/* 输出结果
略...
*/
```

```cpp
//一个线程打印奇数，一个线程打印偶数（方式三：使用条件变量，正确写法）
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int main()
{
	int i = 0;
	int n = 100;
	mutex mtx;
	condition_variable cv; //条件变量
	bool ready = true;

	thread t1([&]() {
		while (i < n)
		{
			unique_lock<mutex> lock(mtx);

			cv.wait(lock, [&](){ return !ready; }); //返回值为 false 就会一直等待，并且在那之前先解锁
			cout << this_thread::get_id() << ":" << i << endl;
			i += 1;

			ready = true;
			cv.notify_one(); //唤醒其他线程
		}
	});

	thread t2([&]() {
		while (i < n)
		{
			unique_lock<mutex> lock(mtx);
			
			cv.wait(lock, [&](){ return ready; }); //返回值为 false 就会一直等待，并且在那之前先解锁
			cout << this_thread::get_id() << ":" << i << endl; 
			i += 1;

			ready = false;
			cv.notify_one(); //唤醒其他线程
		}
	});

	t1.join();
	t2.join();
	return 0;
}
```

