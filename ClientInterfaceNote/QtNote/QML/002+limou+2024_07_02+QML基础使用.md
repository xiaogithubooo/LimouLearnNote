# 1.创建 QML 项目

使用版本还有构建过程，待补充...

# 2.基本的组件

下面介绍基本组件的同时，还会提到一些常见的概念，一边使用一边归纳总结。

## 2.1.主窗口(Window)

```cpp
// 使用 Window 的例子
import QtQuick 2.15 // 导入相关模块
import QtQuick.Window 2.15

Window {
    id: window // 设置组件的 id 值
    width: 640 // 设置宽度
    height: 480 // 设置高度
    visible: true // 设置组件是否可见
    title: qsTr("Hello World") // 设置窗口标题
    x: 100 // 组件左上角位置设置为父组件（这里是整个屏幕）原点的 x 轴 100 处
    y: 150 // 组件左上角位置设置为父组件（这里是整个屏幕）原点的 y 轴 200 处
    minimumWidth: 50 // 设置组件的最小宽度
    minimumHeight: 50 // 设置组件的最小高度
    maximumWidth: 800 // 设置组件的最大宽度
    maximumHeight: 800 // 设置组件的最大高度
    opacity: 0.8 // 取值为 [0, 1]
    property int value: 0 // 一个自定义的属性

    /* 尝试定义一个信号槽
    signal mySig() // 定义一个信号
    onMySig: { // 使用 "on" + "信号名" 定义触发事件(这里这个事件可以随时触发)
        // 以后提及
    }
    */

    // 对于组件的大部分属性（包括自定义属性）都会自动生成 "on" + "属性" + "Changed" 这个改动槽, 并且在属性值改动时自动触发对应的信号
    onWidthChanged: {
        console.log(window.width);
        window.value += 1; // 顺便修改自定义属性的内部值
    }

    onValueChanged: { // 当自定义属性 value 发生修改时打印对应的值
        console.log(window.value);
    }
}

```

## 2.2.按钮(Button)

```cpp
// 使用 Button 的例子
import QtQuick 2.15
import QtQuick.Window 2.15
import QtQuick.Controls 2.15

Window {
    id: window
    width: 640
    height: 480
    visible: true
    title: qsTr("Hello World")
    x: 100
    y: 150
        
    Button { // 一个按钮控件
        id: but1
        width: 100
        height: 100
        x: 0
        y: 0
        // focus: true // 置为 true 就可以显示获得焦点, 默认鼠标点击按钮后按钮就会得到焦点
        background: Rectangle { // background 属性定义了按钮的背景内容(这里设置为一个矩形组件), 后面会提及
            border.color: but1.focus ? "blue" : "black" // 设置矩形的边框样式(这里是获取到焦点就显示蓝色, 否则为黑色)
            border.width: 5 // 设置边框的向内宽度
        }
        onClicked: { // 当按钮被按下时触发日志输出
            console.log("but1 clicked!")
        }
        Keys.onRightPressed: { // 设置键位, 点击右方向键可以让另外一个按钮获得焦点
            but2.focus = true;
        }
    }
    
    Button {
        id: but2
        width: 100
        height: 100
        x: 110
        y: 0
        background: Rectangle {
            border.color: but2.focus ? "blue" : "black"
            border.width: 5
        }
        onClicked: {
            console.log("but2 clicked!")
        }
        Keys.onLeftPressed: {
            but1.focus = true;
        }
    }
}

```

## 2.3.矩形(Rectangle)

```cpp
// 使用 Rectangle 的例子
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Window 2.15

Window {
    visible: true
    width: 640
    height: 480
    title: "Rotated Rectangle with Gradient"

    Rectangle {
        width: 200
        height: 100
        border.color: "blue"
        border.width: 2 // 设置向内宽度
        radius: 25 // 圆角半径为 25 像素
        rotation: 45 // 旋转角度为 45 度
        anchors.centerIn: parent // 设置处于父元素中心位置
        gradient: Gradient { // 设置渐变色
            GradientStop { position: 0.0; color: "lightsteelblue" }
            GradientStop { position: 1.0; color: "steelblue" }
        }

        // 设置鼠标输入区域
        MouseArea {
            anchors.fill: parent // 设置区域充满父元素
            onClicked: { // 主要在区域内点击鼠标救会打印日志
                console.log("Clicked rotated gradient rectangle");
            }
        }

        // 设置矩形内的文本
        Text {
            text: "Rotated Gradient Rectangle"
            color: "white"
            anchors.centerIn: parent
            font.pixelSize: 20 // 设置文字大小
            font.bold: true // 设置文字粗体
        }
    }

    Rectangle {
        width: 200
        height: 100
        color: "lightgreen"
        border.color: "green"
        anchors.top: parent.top
        anchors.centerIn: parent
        z: 1 // 默认所有组件一开始处于 0 图层

        Text {
            text: "Non-rotated Rectangle"
            color: "green"
            anchors.centerIn: parent
            font.pixelSize: 20
            font.bold: true
        }
    }
}

```

## 2.4.按钮(Button)



## 2.5.区域(...Area)



## 2.6.多选项(CheckBox)



## 2.7.文本(Text)



## 2.8.中继器(Repeater)



## 2.9.列表视图(ListView)



## 2.10.焦点尺寸(FocusScope)



# 3.自定义组件

```cpp
// 创建自定义的组件
import QtQuick 2.15

Rectangle {
    id: borderRect
    visible: true
    color: "red"
    property int myTopMargin: 10
    property int myBottomMargin: 10
    property int myLeftMargin: 10
    property int myRightMargin: 10

    Rectangle {
        id: innerRect
        visible: true
        color: "blue"
        anchors.fill: parent
        anchors.topMargin: borderRect.myTopMargin
        anchors.bottomMargin: borderRect.myBottomMargin
        anchors.leftMargin: borderRect.myLeftMargin
        anchors.rightMargin: borderRect.myRightMargin
    }
}

```

```cpp
// 使用自定义的组件
import QtQuick 2.15
import QtQuick.Window 2.15
import QtQuick.Controls 2.15

Window {
    id: win
    width: 640
    height: 480
    visible: true
    title: qsTr("Hello World")
    x: 100
    y: 150

    MyRectangle {
        id: myret
        width: 200
        height: 200
        myTopMargin: 10
        myBottomMargin: 20
        myLeftMargin: 30
        myRightMargin: 40
        x: 10
        y: 15
    }
}

```

>   补充：自定义属性 `property` 的相关使用。
>
>   

# 4.状态切换和动画

使用 `states` 和 `state` 可以在 `QML` 中创建不同的界面状态，并在这些状态之间进行切换。并且也有相当多的组件可以设置动画效果，包括数值改动时动画效果（`NumberAnimation`）、颜色改动时的动画效果（`ColorAnimation`）。甚至还有循环动画队列（`SequentialAnimation` ）、预加载动画（`Behavior`）...

```cpp
// 设置按钮动画效果
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Window 2.15

Window {
    id: root;
    visible: true;
    width: 640;
    height: 480;
    title: "States Example";

    Rectangle {
        id: rect;
        width: 200;
        height: 200;
        anchors.centerIn: parent
        color: "lightblue";
        radius: 10;
        states: [ // 设置展开和收缩状态
            State {
                name: "expanded"; // 展开状态
                PropertyChanges {
                    target: rect; // 明确指出哪个对象的属性会在状态变化或过渡动画中被修改
                    width: 400;
                    height: 400;
                    color: "lightgreen";
                    radius: 20;
                    y: 100;
                }
            },
            State {
                name: "collapsed"; // 收缩状态
                PropertyChanges {
                    target: rect; // 明确指出哪个对象的属性会在状态变化或过渡动画中被修改
                    width: 200;
                    height: 200;
                    color: "lightblue";
                    radius: 10;
                }
            }
        ]
        state: "collapsed"; // 默认设置为收缩状态
        transitions: [ // 设置转场动画效果
            Transition {
                from: "collapsed"; // 起始状态
                to: "expanded"; // 目的状态
                reversible: true; // 设置动画平滑过渡的过程是可逆的
                /* 后续根据需要改为动画的属性进行对应的关注和时间设置... */
                // 设置颜色动画
                ColorAnimation {
                    property: "color"; // 单个属性
                    duration: 100; // 动画持续时间
                }
                // 设置数值动画
                NumberAnimation {
                    properties: "width,height,radius"; // 众多属性
                    duration: 100; // 动画持续时间
                }
            }
        ]

        // 设置文字组件
        Text {
            text: rect.state === "collapsed" ? "Click to Expand" : "Click to Collapse";
            anchors.centerIn: parent;
            font.pixelSize: 20;
            color: "white";
        }

        // 设置鼠标输入区域
        MouseArea {
            anchors.fill: parent;
            onClicked: { // 当鼠标点击矩形时发送状态切换
                rect.state = rect.state === "collapsed" ? "expanded" : "collapsed"; // 这里的三等号用于比较两个值及其类型是否都相等
            }
        }
    }
}

```

# 5.代码调试

在创建组件时会自动发送生命周期信号，在销毁组件的时候会自动发送 `Destruction` 信号。这两个生命周期信号特别适合用来调试打印，您使用 `Component.onCompleted: {}` 和 `Component.onDestruction: {}` 即可。

```cpp
// 利用生命周期信号进行调试
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Window 2.15

Window {
    visible: true
    width: 640
    height: 480

    Rectangle {
        id: parentRect
        width: 200
        height: 200
        color: "lightblue"
        anchors.centerIn: parent

        Rectangle {
            id: childRect
            width: 100
            height: 100
            color: "red"
            anchors.centerIn: parent

            visible: false // 初始状态隐藏子级 Rectangle

            Component.onCompleted: { // 子矩形被创建时触发
                console.log("Child rectangle completed creation.")
            }

            Component.onDestruction: { // 子矩形被销毁时触发
                console.log("Child rectangle is being destroyed.")
            }
        }

        MouseArea {
            anchors.fill: parent
            onClicked: {
                // 切换子级 Rectangle 的可见性
                childRect.visible = !childRect.visible;
                if (childRect.visible) {
                    console.log("Child rectangle shown.");
                } else {
                    console.log("Child rectangle hidden.");
                }
            }
        }
    }
}

```

当然，这种使用还是 `Component` 中比较粗浅的用法。

# 6.部件和加载器

-   `Loader` 用来动态加载其他 `QML` 组件，允许在运行时根据需要加载不同的 `QML` 文件或组件，并将它们作为子项添加到界面中。
-   `Component` 用来定义可重用的组件，它通常与 `Loader` 结合使用，以便在需要时动态加载和显示特定的 `QML` 组件，因此在创建成功时不会立刻显示出来。

```cpp
// 页面 1 的代码
import QtQuick 2.15

Rectangle {
    width: 400
    height: 300
    color: "lightblue"

    Text {
        text: "Page 1"
        font.pixelSize: 24
        anchors.centerIn: parent
    }
}

```

```cpp
// 页面 2 的代码
import QtQuick 2.15

Rectangle {
    width: 400
    height: 300
    color: "lightgreen"

    Text {
        text: "Page 2"
        font.pixelSize: 24
        anchors.centerIn: parent
    }
}

```

```cpp
// 随机动态切换不同的页面
import QtQuick 2.15
import QtQuick.Controls 2.15

Window {
    visible: true
    width: 400
    height: 300
    title: "Dynamic Component Loading"

    // 声明页面 1
    Component {
        id: pageComponent1 // 定义默认加载的组件
        Page1 { // 装入 Page1 组件
            Component.onCompleted: { // 设置创建时的回调
                console.log("create~", width, height);
            }
            Component.onDestruction: { // 设置销毁时的回调
                console.log("destroy~", width, height);
            }
        }
    }

    // 声明页面 2
    Component {
        id: pageComponent2 // 定义备选的组件
        Page2 { // 装入 Page2 组件
            Component.onCompleted: { // 设置创建时的回调
                console.log("create~", width, height);
            }
            Component.onDestruction: { // 设置销毁时的回调
                console.log("destroy~", width, height);
            }
        }
    }

    // 加载器
    Loader {
        id: pageLoader
        anchors.fill: parent // Loader 占据整个父窗口的大小
        sourceComponent: pageComponent1 // 默认先加载 pageComponent 中定义的组件
        /* 另外一种等价写法是 source: "/file_path" */
        onStatusChanged: { // 状态发送改变就被触发
            console.log("status: ", status);
        }
    }

    // 根据条件切换加载的组件
    function loadPage(condition) {
        if (condition === "page2") {
            pageLoader.sourceComponent = pageComponent2;
        } else {
            pageLoader.sourceComponent = pageComponent1;
        }
    }

    // 模拟条件变化, 实际项目中这里可能是动态绑定到数据模型或其他条件变化的地方
    Timer {
        interval: 2000; // 每 2 秒变化一次条件
        running: true;
        repeat: true;
        onTriggered: {
            var condition = Math.random() > 0.5 ? "page2" : "page1";
            loadPage(condition); // 调用回调函数
        }
    }

    // 设置销毁按钮
    Button {
        width: 50;
        height: 50;
        onClicked: {
            pageLoader.sourceComponent = null;
        }
    }
}

```

不过这种动态创建出来的组件有时是有些修改困惑的，由于无法确定加载时间，因此希望修改被加载组件的某些特性时，就不能直接进行加载了。例如在下面这个例子中，我尝试使用了三种方式来修改动态加载组件的属性，其中只有最后一种是成功的。

```cpp
// 修改动态加载组件的属性
import QtQuick 2.15
import QtQuick.Controls 2.15

Window {
    width: 800
    height: 600
    visible: true
    title: "Dynamic Component Loading"

    // 声明矩形
    Component {
        id: comp
        Rectangle {
            id: rect
            width: 50
            height: 50
            color: "lightblue"
            Component.onCompleted: {
                console.log("create: ", width, height);
            }
            Component.onDestruction: {
                console.log("destroy: ", width, height);
            }
        }
    }

    // 加载器
    Loader {
        id: loader
        sourceComponent: comp // 默认先加载 pageComponent 中定义的组件
    }

    // 设置销毁按钮
    Button {
        width: 50;
        height: 50;
        y: 50;
        onClicked: {
            /* 错误写法: rect.width += 50; */
            /* 错误写法: comp.rect.width += 50; */
            loader.item.width += 50; // 虽然不知道加载了什么...但我们知道一定有一个 item, 这是一个异步的属性
        }
    }
}

```

并且 `Loader.source=.../Loader.sourceComponent=...` 是直接无法加载图片文件的（并且返回一个状态 `3`，也就是错误状态码），只能加载 `.qml` 文件。这个原因是因为图片之类的资源文件很可能非常大，但又没必要一次性加载再进行渲染，这样对于界面渲染来说太慢了（会被图片的渲染速度拖累到）。因此必须把图片加载的过程变成异步加载，因此就需要使用异步属性来加载图片。

# 7.信号槽



# 8.QML 和 Cpp 交互



# 打包