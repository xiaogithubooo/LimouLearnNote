# 1.面向过程和面向对象

关于这两者，待补充...

# 2.类

## 2.1.类的描述

类描述一系列的对象，而一个类的声明如下：

```java
//定义类的语法形式
[类修饰符] class 类名 {
    //一些属性/成员变量...
    //一些方法/成员方法...
}
```

类和 `C` 语言的结构体很类似，但是又多了很多特性，最大的不同就是允许在类中加入方法（方法可以简单理解为函数）。

关于类，我们需要注意下面几点：

1.   一般一个 `Java` 文件内部只会存在一个类（也就是一一对应，但是我们在学习过程中可以放在一个文件中）

2.   `main()` 方法所在的类一般要使用 `public` 修饰（`Eclipse` 默认会在 `public` 修饰的类中寻找 `main()` 方法）

3.   如果一个类有 `public` 修饰，那么请不要直接手动修改这个类的类名（我们可以通过开发工具修改，这样才会让所有使用该类名的代码都进行同步修改）

     ![recording](./assets/recording-1705387018151-4.gif)

## 2.2.类的实例化

通过类描述这张“图纸”，可以通过 `new` 来实例化出多个对象。

虽然一个 `Java` 文件内部只会存在一个类，但我们可以尝试写到一起试试：

```cpp
//main.java
//类描述和对象创建

//描述对象的 Person 类
class Person {
    //成员变量
    public String name; //名字
    public int age; //年龄

    //成员方法
    public String GetName() { //获取名字
        return name;
    }
    public int GetAge() { //获取年龄
        return age;
    }
}

//主类的主函数
public class Main {
    public static void main(String[] args) {
        Person per = new Person(); //使用 new 语法创建（实例化对象）
        per.name = "limou3434";
        per.age = 18;

        System.out.println("姓名:" + per.GetName());
        System.out.println("年龄:" + per.GetAge());
    }
}

/* 输出结果
姓名:limou3434
年龄:18
*/
```

再换成一个类一个文件的方式写，在同一个 `Java` 项目中有如下两份文件：

```java
//Person.java
//Person 类
class Person {
    //成员变量
    public String name; //名字
    public int age; //年龄

    //成员方法
    public String GetName() { //获取名字
        return name;
    }
    public int GetAge() { //获取年龄
        return age;
    }
}
```

```java
//Main.java
//Main 类
//主类内使用 Person 对象
public class Main {
    public static void main(String[] args) {
        Person per = new Person(); //使用 new 语法创建
        per.name = "limou3434";
        per.age = 18;

        System.out.println("姓名:" + per.GetName());
        System.out.println("年龄:" + per.GetAge());
    }
}
```

上述的内部成员如果我们自己没有初始化，`Java` 也是会自己初始化的（内置类型为零值，引用类型为 `null`，`boolean` 为 `false`，`char` 为 `\u0000`）。

>   补充：对象内部是不存储方法的，只有在使用方法时才会在栈上开辟空间，而成员变量都存储在堆空间上。

## 2.3.this 引用

### 2.3.1.this.成员变量

`this` 引用来源于 `C++` 的 `this` 指针，两者有所区别，但是很是类似，首先我们来看一个奇怪的现象：

```java
//没问题的代码
class Data {
    public int _year;
    public int _month;
    public int _day;

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);
        day1.Print();

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
        day2.Print();
    }
}

/* 输出结果
2024 1 21
2023 2 23
*/
```

而下面代码中的 `SetData()` 如果是在 `C++` 中有可以运行，但在 `Java` 会出现问题，`Java` 会认为是局部变量自己给自己赋值（根本不会影响成员变量的取值），因此打印的还是 `Java` 给变量的默认初始值。

```java
//有问题的代码
class Data {
    public int year;
    public int month;
    public int day;

    public void SetData(int year, int month, int day) {
        year = year;
        month = month;
        day = day;
    }

    public void Print() {
        System.out.println(year + " " + month + " " + day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);
        day1.Print();

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
        day2.Print();

        //Java 怎么知道使用 SetData() 后初始化的是 day1 的内部成员而不是 day2 的内部成员呢？
        //答案是使用了 this 引用
    }
}

/* 输出结果
0 0 0
0 0 0
*/
```

但是如果我们使用 `this` 引用就可以指明赋值关系就不会出现问题。

```java
//使用 this 引用
class Data {
    public int year;
    public int month;
    public int day;

    public void SetData(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public void Print() {
        System.out.println(year + " " + month + " " + day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);
        day1.Print();

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
        day2.Print();
    }
}

/* 输出结果
2024 1 21
2023 2 23
*/
```

而这个 `this` 引用实际上就是调用方法的哪个对象，方法被哪个对象调用了，`this` 就引用的哪个对象。

第一个代码中，`Java` 会自动识别类内成员，给其加上 `this.`，而第二个代码中，由于形参的影响，`Java` 无法识别哪一个是成员变量，干脆都理解为局部变量，交给用户使用 `this` 去指定（但是 `C++` 可以识别出这种特殊情况，但仍旧不推荐这么书写）。

另外，这也能解释为什么使用 `SetData()` 和 `Print()` 可以明确对哪一个具体的对象做操作，每一个方法的第一个参数实际上就是 `this`，这是 `Java` 自动传递的，我们无需给函数传递，只需要在函数内使用即可。

此外我们需要注意，`this` 引用只能在方法定义内被使用，且只能引用当前对象，不能再引用其他对象。

>   注意：我们一般建议将 `this` 明确写上，不过度依赖 `Java` 的默认行为，避免造成误解。

### 2.3.2.this.成员方法

除了调用对象内的成员变量，还可以调用对象对应类内对应的成员方法（当然也可以不加 `this.`）。

```java
//使用 this.成员方法 来调用方法
class Data {
    public int _year;
    public int _month;
    public int _day;

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
    }
}

/* 输出结果
2024 1 21
2023 2 23
*/
```

### 2.3.3.this()

这个方法是结合构造方法来使用的，后面提及。

## 2.4.构造方法

我们在定义类的变量时，可以发现，即便我们没有定义类内部成员变量的初始值，`Java` 会帮助我们自动初始化，但是如果不是在类中，而是直接写在 `Main()` 中的局部变量没有进行初始化，代码可能连编译都无法通过。

```java
//编译通过的代码
class Data {
    public int _year;
    public int _month;
    public int _day;

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d = new Data();
        d.Print();
    }
}

/* 输出结果
0 0 0
*/
```

```java
//编译失败的代码
public class Main {
    public static void main(String[] args) {
        //Data d = new Data();
        //d.Print();

        int year;
        int month;
        int day;
        System.out.println(year + " " + month + " " + day); //报错
    }
}

/* 输出结果
java: 可能尚未初始化变量year
*/
```

那究竟是谁帮助我们对类内的成员变量进行了初始化呢？`Java`？是的，但是不够深层，准确来说，是类内默认的成员方法：**构造方法**，该方法没有返回值，方法名和类名一样。

默认的构造方法会给成员变量赋予初始值，而当我们撰写自定义的构造方法时，`Java` 就不会调用编译器提供的构造方法，而是调用我们自己自定义的构造方法。并且，构造方法只在实例化对象的时候才会被自动调用。

```java
//自定义构造方法
class Data {
    public int _year;
    public int _month;
    public int _day;

    Data() {
        System.out.println("不带参数的构造方法");
    }
    Data(int year, int month, int day) {
        System.out.println("带参数的构造方法");
        this._year = year;
        this._month = month;
        this._day = day;
    }

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d1 = new Data();
        d1.Print();

        Data d2 = new Data(2021, 1, 2);
        d2.Print();
        d2.SetData(2024, 10, 9);
    }
}

/* 输出结果
不带参数的构造方法
0 0 0
带参数的构造方法
2021 1 2
2024 10 9
*/
```

除此以外，还以一种初始化方法叫做 **就地初始化**，直接在类内成员变量进行初始化，这种方式适用于一些具有默认值的成员变量，但是不具备一般性（就地初始化的值会被添加到构造方法中）：

```java
//自定义构造方法
class Data {
    public int _year = 1000; //就地初始化
    public int _month = 1; //就地初始化
    public int _day = 1; //就地初始化

    Data() {
        System.out.println("不带参数的构造方法");
    }
    Data(int year, int month, int day) {
        System.out.println("带参数的构造方法");
        this._year = year;
        this._month = month;
        this._day = day;
    }

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d1 = new Data();
        d1.Print(); //由于我们把无参的构造方法自定义了，就不会调用之前 Java 定义的版本，因此就没有给成员变量进行初始化，导致无法打印

        Data d2 = new Data(2021, 1, 2);
        d2.Print();
        d2.SetData(2024, 10, 9);
    }
}

/* 输出结果
不带参数的构造方法
1000 1 1
带参数的构造方法
2021 1 2
2024 10 9
*/
```

而前面提及的 `this()`，这可以做到在一个构造方法内调用类内其他重载的构造函数（必须是在构造函数方法内的第一条语句，并且不能多次调用）。

```java
//使用 this()
class Data {
    public int _year = 0; //就地初始化
    public int _month = 0; //就地初始化
    public int _day = 0; //就地初始化

    Data() {
        this(2000, 1, 1);
        System.out.println("不带参数的构造方法");
    }
    Data(int year, int month, int day) {
        System.out.println("带参数的构造方法");
        this._year = year;
        this._month = month;
        this._day = day;
    }

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d = new Data();
        d.Print();
    }
}

/* 输出结果
带参数的构造方法
不带参数的构造方法
2000 1 1
*/
```

构造方法一般使用 `public`，只有在某些情况（单例模式）才会使用 `provate` 来修饰（下面会将这两个关键字的作用）。

>   补充：另外，构造函数实际上做的工作还有很多
>
>   1.   初始化分配的对象（也就是我们上面学的）
>   2.   为对象分配内存空间
>   3.   处理并发安全问题
>   4.   检测对象对应的类是否加载（若无则加载）
>
>   后续学习中将会逐步补充。

# 3.封装

面向对象的三个常见特性就是：封装、继承、多态，我们先来理解最容易理解的封装。

## 3.1.访问限定符

`Java` 主要通过类的访问权限来实现“封装”，将数据和封装数据的方法结合在一起，更符合人类对事物的认知，而访问权限用来控制方法或字段能否直接在类外使用：

| 范围       | private(私有) | default(默认的权限) | protected(继承内多用) | public(公有) |
| ---------- | ------------- | ------------------- | --------------------- | ------------ |
| 同包的同类 | yes           | yes                 | yes                   | yes          |
| 同包的异类 |               | yes                 | yes                   | yes          |
| 异包内子类 |               |                     | yes                   | yes          |
| 异包非子类 |               |                     |                       | yes          |

我们现在只需要了解 `private` 和 `public` 关键字的使用即可，一般来说，类内的成员变量使用 `private` 来修饰，而 `public` 多用于类方法（我们先熟悉 `public` 和 `private` 的用法）。

这里补充关于限定符的使用和  `C` 结构体的区别，待补充...

## 3.2.包的使用

在面向对象体系中，有一个软件包的概念，为了更好的管理类，把多个类收集在一起成为一组，就称为 **软件包**。而 `Java` 也引入了包的概念，包实质上是一种封装的体现，在一个工程中允许存在同名类，只要处于不同的包内即可。

### 3.2.1.包的导入

`Java` 存在很多的包，可以直接在代码中引入，也可以使用 `import` 语句来导入包。

```java
//代码中使用包
public class Main {
    public static void main(String[] args) {
        java.util.Date date = new java.util.Date(); // 代码中导入包内类的方法
        System.out.println(date.getTime()); // 返回一个时间戳
    }
}
```

```java
///使用 import 导入包
import java.util.Date;
public class Main {
    public static void main(String[] args) {
        Date date = new Date(); // 代码中导入包内类的方法
        System.out.println(date.getTime()); // 返回一个时间戳
    }
}
```

这里 `java.util.Date` 的 `java.util` 就是包， `Date` 就是包内的类，对应一个 `Java` 文件。

>   补充：如果使用 `*` 代替 `Date` 就可以看到 `java.util` 中的所有类，不过一般只推荐显示写一个类，否则有可能出现命名冲突的问题。
>
>   ```java
>   //不同包内同名称类冲突的问题
>   import java.util.*;
>   import java.sql.*;
>   public class Main {
>       public static void main(String[] args) {
>           // util 和 sql 中都存在一个 Date 这样的类，此时就会出现歧义，Java 不知道该使用哪一个类，编译出错
>           // Date date = new Date();
>           // System.out.println(date.getTime());
>       }
>   }
>   ```

另外，还可以使用 `import static` 导入包中静态的成员变量和成员方法。

```java
//使用静态导入
import static java.lang.Math.*;
public class Main {
    public static void main(String[] args) {
        double x = 3;
        double y = 4;

        double ret = sqrt(pow(x, 2) + pow(y, 2)); //计算 √(30^2 + 50^2)
        System.out.println(ret);
    }
}

/* 输出结果
5.0
*/
```

>   注意：`import` 和 `C/C++` 的 `#include` 不是同一种东西，`C/C++` 使用 `#include` 会在编译期间将整个头文件复制下来，再使用链接器链接。而 `Java` 的 `import` 仅仅是为了编写代码时更加方便，因此更类似 `C/C++` 的 `namespace` 和 `using` 的使用。

### 3.2.2.自定义包

```java
//描述对象的 Person 类
public class Person {
    // 描述对象的 Person 类
    // (1)成员变量
    public String name; // 名字
    public int age; // 年龄

    // (2)成员方法
    public String GetName() { //获取名字
        return name;
    }
    public int GetAge() { //获取年龄
        return age;
    }
}
```

对于上面类，如何成为一个供人使用的包呢？或者说，我们怎么自定义一个包呢？按照下面步骤来操作：

1.   要在类的最上方加上 `package 包名` 语句，一般使用公司域名的颠倒形式（`com.limou.blog`），包名尽量是唯一的

2.   在 `IDEA` 中右键 `src` 文件夹，在 `new` 中选择 `Package`，在弹出的对话框中输入包名

     ![image-20240226195912479](./assets/image-20240226195912479.png)

     ![image-20240226200021858](./assets/image-20240226200021858.png)

     ![image-20240226200040800](./assets/image-20240226200040800.png)

3.   右击包，选择 `New` 中的 `Java Class` 输入类名

     ![image-20240226201116752](./assets/image-20240226201116752.png)

     ![image-20240226201112699](./assets/image-20240226201112699.png)

4.   在新出现的 `java` 文件中粘贴代码即可

     ![image-20240226201524949](./assets/image-20240226201524949.png)

5.   在 `main()` 中调用即可

     ```java
     // 在主类的 main() 中正常调用
     import com.limou.blog.Person;
     // 主类的主函数
     public class Main {
         public static void main(String[] args) {
             Person per = new Person(); // 使用 new 语法创建（实例化对象）
             per.name = "limou3434";
             per.age = 18;
     
             System.out.println("姓名:" + per.GetName());
             System.out.println("年龄:" + per.GetAge());
         }
     }
     ```

### 3.2.3.包的访问权限控制

学习了包后，就可以进一步理解访问限定符的使用，让我们创建两个包，并且创建各自的类试一试。

```java
```



# 6.static 成员

# 7.代码块

## 7.1.普通代码块

## 7.2.构造块

## 7.3.静态块

## 7.4.同步代码块

# 8.内部类

# 9.对象打印



