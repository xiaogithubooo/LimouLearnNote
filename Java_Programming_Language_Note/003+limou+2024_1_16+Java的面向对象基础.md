# 1.面向过程和面向对象

关于这两者，待补充...

# 2.类

## 2.1.类的描述

类描述一系列的对象，而一个类的声明如下：

```java
//定义类的语法形式
[类修饰符] class 类名 {
    //一些属性/成员变量...
    //一些方法/成员方法...
}
```

类和 `C` 语言的结构体很类似，但是又多了很多特性，最大的不同就是允许在类中加入方法（方法可以简单理解为函数）。

关于类，我们需要注意下面几点：

1.   一般一个 `Java` 文件内部只会存在一个类

2.   `main()` 方法所在的类一般要使用 `public` 修饰（`Eclipse` 默认会在 `public` 修饰的类中寻找 `main()` 方法）

3.   如果一个类有 `public` 修饰，那么请不要轻易修改这个类的类名（我们可以通过开发工具修改）

     ![recording](./assets/recording-1705387018151-4.gif)

## 2.2.类的实例化

通过类描述这张“图纸”，可以实例化出多个对象。

虽然一个 `Java` 文件内部只会存在一个类，但我们可以尝试写到一起试试：

```cpp
//类描述和对象创建

//描述对象的 Person 类
class Person {
    //成员变量
    public String name; //名字
    public int age; //年龄

    //成员方法
    public String GetName() { //获取名字
        return name;
    }
    public int GetAge() { //获取年龄
        return age;
    }
}

public class Main {
    public static void main(String[] args) {
        Person per = new Person(); //使用 new 语法创建（实例化对象）
        per.name = "limou3434";
        per.age = 18;

        System.out.println("姓名:" + per.GetName());
        System.out.println("年龄:" + per.GetAge());
    }
}

/* 输出结果
姓名:limou3434
年龄:18
*/
```

再换成一个类一个文件的方式写，在同一个 `Java` 项目中有如下两份文件：

```java
//Person.java
//Person 类
class Person {
    //成员变量
    public String name; //名字
    public int age; //年龄

    //成员方法
    public String GetName() { //获取名字
        return name;
    }
    public int GetAge() { //获取年龄
        return age;
    }
}
```

```java
//Main.java
//Main 类
//主类内使用 Person 对象
public class Main {
    public static void main(String[] args) {
        Person per = new Person(); //使用 new 语法创建
        per.name = "limou3434";
        per.age = 18;

        System.out.println("姓名:" + per.GetName());
        System.out.println("年龄:" + per.GetAge());
    }
}
```

上述的内部成员如果我们自己没有初始化，`Java` 也是会自己初始化的（内置类型为零值，引用类型为 `null`，`boolean` 为 `false`，`char` 为 `\u0000`）。

>   补充：对象内部是不存储方法的，只有在使用方法时才会在栈上开辟空间，而成员变量都存储在堆空间上。

## 2.3.this 引用

### 2.3.1.this.成员变量

`this` 引用来源于 `C++` 的 `this` 指针，两者有所区别，但是很是类似，首先我们来看一个奇怪的现象：

```java
//没问题的代码
class Data {
    public int _year;
    public int _month;
    public int _day;

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);
        day1.Print();

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
        day2.Print();
    }
}

/* 输出结果
2024 1 21
2023 2 23
*/
```

而下面代码中的 `SetData()` 如果是在 `C++` 中有可以运行，但在 `Java` 会出现问题，`Java` 会认为是局部变量自己给自己赋值（根本不会影响成员变量的取值），因此打印的还是 `Java` 给变量的默认初始值。

```java
//有问题的代码
class Data {
    public int year;
    public int month;
    public int day;

    public void SetData(int year, int month, int day) {
        year = year;
        month = month;
        day = day;
    }

    public void Print() {
        System.out.println(year + " " + month + " " + day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);
        day1.Print();

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
        day2.Print();

        //Java 怎么知道使用 SetData() 后初始化的是 day1 的内部成员而不是 day2 的内部成员呢？
        //答案是使用了 this 引用
    }
}

/* 输出结果
0 0 0
0 0 0
*/
```

但是如果我们使用 `this` 引用就可以指明赋值关系就不会出现问题。

```java
//使用 this 引用
class Data {
    public int year;
    public int month;
    public int day;

    public void SetData(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public void Print() {
        System.out.println(year + " " + month + " " + day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);
        day1.Print();

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
        day2.Print();
    }
}

/* 输出结果
2024 1 21
2023 2 23
*/
```

而这个 `this` 引用实际上就是调用方法的哪个对象，方法被哪个对象调用了，`this` 就引用的哪个对象。

第一个代码中，`Java` 会自动识别类内成员，给其加上 `this.`，而第二个代码中，由于形参的影响，`Java` 无法识别哪一个是成员变量，干脆都理解为局部变量，交给用户使用 `this` 去指定。

另外，这也能解释为什么使用 `SetData()` 和 `Print()` 可以明确对哪一个具体的对象做操作，每一个方法的第一个参数实际上就是 `this`，这是 `Java` 自动传递的，我们无需给函数传递，只需要在函数内使用即可。

此外我们需要注意，`this` 引用只能在方法定义内被使用，且只能引用当前对象，不能再引用其他对象。

不过我们一般建议将 `this` 明确写上，不过度依赖 `Java` 的默认行为。

### 2.3.2.this.成员方法

除了调用对象内的成员变量，还可以调用对象对应类内对应的成员方法（当然也可以不加 `this.`）。

```java
//使用 this.成员方法 来调用方法
class Data {
    public int _year;
    public int _month;
    public int _day;

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data day1 = new Data();
        day1.SetData(2024, 1, 21);

        Data day2 = new Data();
        day2.SetData(2023, 2, 23);
    }
}

/* 输出结果
2024 1 21
2023 2 23
*/
```

### 2.3.3.this()

这个方法时结合构造方法来使用的，后面提及。

## 2.4.构造方法

我们在定义类的变量时，可以发现，即便我们没有定义类内部成员变量的初始值，`Java` 会帮助我们自动初始化，但是如果不是在类中，而是直接写在 `Main()` 中的局部变量没有进行初始化，代码可能连编译都无法通过。

```java
//编译通过的代码
class Data {
    public int _year;
    public int _month;
    public int _day;

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d = new Data();
        d.Print();
    }
}

/* 输出结果
0 0 0
*/
```

```java
//编译失败的代码
public class Main {
    public static void main(String[] args) {
        //Data d = new Data();
        //d.Print();

        int year;
        int month;
        int day;
        System.out.println(year + " " + month + " " + day); //报错
    }
}

/* 输出结果
java: 可能尚未初始化变量year
*/
```

那究竟是谁帮助我们对类内的成员变量进行了初始化呢？`Java`？是的，但是不够深层，准确来说，是类内默认的成员方法：**构造方法**，该方法没有返回值，方法名和类名一样。

默认的构造方法会给成员变量赋予初始值，而当我们撰写自定义的构造方法时，`Java` 就不会调用编译器提供的构造方法，而是调用我们自己自定义的构造方法。并且，构造方法只在实例化对象的时候才会被自动调用。

```java
//自定义构造方法
class Data {
    public int _year;
    public int _month;
    public int _day;

    Data() {
        System.out.println("不带参数的构造方法");
    }
    Data(int year, int month, int day) {
        System.out.println("带参数的构造方法");
        this._year = year;
        this._month = month;
        this._day = day;
    }

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d1 = new Data();
        d1.Print();

        Data d2 = new Data(2021, 1, 2);
        d2.Print();
        d2.SetData(2024, 10, 9);
    }
}

/* 输出结果
不带参数的构造方法
0 0 0
带参数的构造方法
2021 1 2
2024 10 9
*/
```

除此以外，还以一种初始化方法叫做 **就地初始化**，直接在类内成员变量进行初始化，这种方式适用于一些具有默认值的成员变量，但是不具备一般性（就地初始化的值会被添加到构造方法中）：

```java
//自定义构造方法
class Data {
    public int _year = 1000; //就地初始化
    public int _month = 1; //就地初始化
    public int _day = 1; //就地初始化

    Data() {
        System.out.println("不带参数的构造方法");
    }
    Data(int year, int month, int day) {
        System.out.println("带参数的构造方法");
        this._year = year;
        this._month = month;
        this._day = day;
    }

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d1 = new Data();
        d1.Print(); //由于我们把无参的构造方法自定义了，就不会调用之前 Java 定义的版本，因此就没有给成员变量进行初始化，导致无法打印

        Data d2 = new Data(2021, 1, 2);
        d2.Print();
        d2.SetData(2024, 10, 9);
    }
}

/* 输出结果
不带参数的构造方法
1000 1 1
带参数的构造方法
2021 1 2
2024 10 9
*/
```

而前面提及的 `this()`，这可以做到在一个构造方法内调用类内其他重载的构造函数（必须是在构造函数方法内的第一条语句，并且不能多次调用）。

```java
//使用 this()
class Data {
    public int _year = 0; //就地初始化
    public int _month = 0; //就地初始化
    public int _day = 0; //就地初始化

    Data() {
        this(2000, 1, 1);
        System.out.println("不带参数的构造方法");
    }
    Data(int year, int month, int day) {
        System.out.println("带参数的构造方法");
        this._year = year;
        this._month = month;
        this._day = day;
    }

    public void SetData(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
        this.Print(); //设定好值后就打印
    }

    public void Print() {
        System.out.println(_year + " " + _month + " " + _day);
    }
}

public class Main {
    public static void main(String[] args) {
        Data d = new Data();
        d.Print();
    }
}

/* 输出结果
带参数的构造方法
不带参数的构造方法
2000 1 1
*/
```

构造方法一般使用 `public`，只有在某些情况（单例模式）才会使用 `provate` 来修饰。

>   补充：另外，构造函数实际上做的工作还有很多
>
>   1.   检测对象对应的类是否加载（若无则加载）
>   2.   为对象分配内存空间
>   3.   处理并发安全问题
>   4.   初始化分配的对象（也就是我们上面学的）

# 3.封装

面向对象的三个常见特性就是：封装、继承、多态。

## 3.1.访问限定符

## 3.2.包

### 3.2.1.包的导入

>   补充：常见的包

### 3.2.2.自定义包

### 3.2.3.包的访问权限控制

# 6.static 成员

# 7.代码块

## 7.1.普通代码块

## 7.2.构造块

## 7.3.静态块

## 7.4.同步代码块

# 8.内部类

# 9.对象打印



