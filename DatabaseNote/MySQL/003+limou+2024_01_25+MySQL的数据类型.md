# 1.整型

| 数值类型                            | 字节 | 描述                                                         |
| ----------------------------------- | ---- | ------------------------------------------------------------ |
| `TINYINT[UNSIGNED]`                 | 1    | 很小的整数，默认有符号 <br/> `[-128,127]/[0,255]`            |
| `SMALLINT[UNSIGNED]`                | 2    | 较小的整数，默认有符号 <br/> `[-32768,32767]/[0,65535]`      |
| `MEDIUMINT[UNSIGNED]`               | 3    | 中等的整数，默认有符号 <br/> `[-8388608,8388607]/[0,16777215]` |
| `INT[UNSIGNED]`/`INTEGER[UNSIGNED]` | 4    | 标准的整数，默认有符号 <br/> `[-2147483648,2147483647]/[0,4294967295]` |
| `BIGINT[UNSIGNED]`                  | 8    | 较大的整数，默认有符号 <br> `[-9223372036854775808,9223372036854775807]/[0,18446744073709551615]` |

如果插入了超出对应字段合法范围的数据，`MySQL` 就会拒绝插入的行为，因此在 `MySQL` 看来，所有能插入的数据都是合法的，因此数据类型实际上就是一种约束（我们以后再来好好理解这个词，现在先简单了解一下），倒逼程序员进行正确的操作，保证数据插入的合法性。

# 2.二进制类型

| 二进制类型   | 描述                                                  |
| ------------ | ----------------------------------------------------- |
| `BIT(M)`     | 位类型，`M` 为指定位数，默认值为 `1`，范围为 `[1-64]` |
| `TINYBLOB`   | 很小的二进制数据                                      |
| `BLOB`       | 二进制大对象                                          |
| `MEDIUMBLOB` | 中等大小的二进制数据                                  |
| `LONGBLOB`   | 较大的二进制数据                                      |

`MySQL` 通常按照 `ASCII` 码值显示的，因此无法直接显示位类型的 `0/1` ，我们可以使用十进制来查看（例如 `select hex(bit_data) from table_name;`）。

而因此插入的一些二进制值达到 `ASCII` 的合法范围时，就会显示出对应的 `ASCII` 字符。

# 3.小数类型

| 小数类型                  | 字节 | 描述                                                         |
| ------------------------- | ---- | ------------------------------------------------------------ |
| `FLOAT[(M,D)][UNSIGNED]`  | 4    | 单精度浮点数，默认有符号，`M` 为显示长度，`D` 为小数位数/精度 |
| `DOUBLE[(M,D)][UNSIGNED]` |      | 双精度浮点数，默认有符号                                     |
| `DECIMAL(M,D)[UNSIGNED]`  |      | 定点数，适用于存储精确的小数，默认有符号                     |

浮点类型如果规定了小数点的位数，则显示的长度里包含小数点规定的位数（但是不包含小数点），例如插入 `10.0` 会显示 `10.00`，插入 `100.1` 会插入失败（实际插入的是 `100.10`）。

但是如果插入多余的小数位，会发生四舍五入的存储，例如插入 `10.016`，实际插入的值是 `10.02`。

因此也无法插入 `99.996`，但是允许插入 `99.9900001`。

一般浮点数的数值很大，一般不会关心一个浮点数的大小，用户只需要根据自己的需求设置显示位数和精度即可。

浮点类型可能存在较大的数据缺失问题，而定点数类型则可以尽可能规避这个问题（如果希望精度更高就需要使用 `decimal` 类型）。

# 4.文本类型

| 文本类型     | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| `CHAR(L)`    | 定长字符串，`L` 为存储长度，最大值为 `255`，单位是一个“字符” |
| `VARCHAR(L)` | 变长字符串，`L` 的最大值为 `65535` 个“字节”，但是其中有 `1~3` 个字节需要记录数据大小，因此有效字节数为 `65532`。在 `utf8` 中也就是最多 `65532/3=21844` 个字符（`*3`），在 `gbk` 中也就是 `65532/2=32766`（也就是说，具体字符个数和所用编码密切相关）。 |
| `BINARY`     | 定长二进制字符串                                             |
| `VARBINARY`  | 变长二进制字符串                                             |
| `TINYTEXT`   | 很小的文本数据                                               |
| `TEXT`       | 普通的文本数据                                               |
| `MEDIUMTEXT` | 中等的文本数据                                               |
| `LONGTEXT`   | 较大的文本数据                                               |

不定长的字符串可以会影响查询效率，但是空间利用率较高。在使用 `varchar` 类型是，上限就是 `L`，是“有多少用多少，不超过 `L`”，而定长的字符串是“就算只有这么多，也会占用 `L`”，两者的区别类似 `C/C++` 的 `char s[size]` 和 `std::string str` 的区别。

另外需要注意一个汉字字符也是一个字符，这点很特殊，即使一个中文汉字用多个字节表示，也依旧可以使用 `char(1)` 来表示（但是需要注意有时候会报字符集不匹配的错误）。

>   疑惑：关于 `VARCHAR(L)` 中的 `L` 是字符个数还是字节个数，貌似不同版本的 `MySQL` 是不一样的。

# 5.时间类型

| 时间类型    | 字节 | 描述                                                         |
| ----------- | ---- | ------------------------------------------------------------ |
| `DATE`      | 3    | 日期值，格式为 `yyyy-mm-dd`，对于时间精度只需要到天数时就使用该类型，需要程序员自己登记修改 |
| `DATETIME`  | 8    | 日期和时间值，格式为 `yyyy-mm-dd HH:ii:ss`，需要程序员自己登记修改 |
| `TIMESTAMP` | 4    | 时间戳，格式和 `DATETIME` 一样，该字段会自动填入（若使用 `UPDATE table_name set field_name='new_value'`  更新同一项的其他字段数据时，将会自动更新），因此时间戳经常被用于数据被更新的最近时间点，无需程序员自己登记修改 |
| `TIME`      |      | 时间                                                         |
| `YEAR`      |      | 年份                                                         |

# 6.复合类型

| 复合类型 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| `ENUM`   | 枚举（单选）。只是设定若干选项，最终在单元格中只存储了一个实际值，枚举值的大小范围为 `[1,65535]`，使用方法和 `C/C++` 的枚举体类似，枚举字段的数据只允许填入之前枚举出的所有值。并且，如果插入的数字是合法范围的值，也会转为为对应的枚举标识（如果忽略该字段会自动填入 `NULL`，使用 `0` 作为插入会导致非法操作） |
| `SET`    | 集合（多选）。和枚举不同，一个列可以拥有多个值，多个值作为一个字段数据插入的时候，整体看作一个字符串即可。并且我们还可以使用数字来插入数据，该数字为 `0001` 代表四个元素中的第一个元素，若为 `0101` 则代表四个元素中的第一、第三个元素（如果忽略该字段会自动填入 `NULL`，使用 `0` 作为插入会导致为空） |

使用 `FIND_IN_SET(SUB, STR_LIST)` 可以来查找集合中是否有某“一个”元素，若 `sub` 这个单一元素在 `str_list(不要在逗号后面加空格)`  集合中则返回其下标，若不存在则返回 `0`。

而如果我们直接使用 `where field_name='new_value'` 子句来查询集合时，采用的是严格匹配法，我们需要不严格匹配时，就需要使用上述 `find_in_set()` 的接口。

也就是使用 `SELECT * FROM table_name WHERE FIND_IN_SET(sub, STR_LIST)` 来查询，这样只要有一个元素存在于集合字段中，就可以被查询出来。

而如果希望包含多个元素，就需要使用 `AND` 来级联多个接口，也就是使用 `SELECT * FROM table_name WHERE FIND_IN_SET(sub_1, STR_LIST) AND FIND_IN_SET(sub_2, STR_LIST) AND ...` 

>   补充：`NULL` 和 `(空)` 是两种东西。

# 7.布尔类型

| 布尔类型 | 描述                   |
| -------- | ---------------------- |
| `BOOL`   | 使用 `0/1` 表示“真/假” |

使用起来较简单，略，待补充...





