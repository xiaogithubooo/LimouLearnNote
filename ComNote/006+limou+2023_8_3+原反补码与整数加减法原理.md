# 1.无符号整数在硬件内的表示

这个部分可以查看我的C语言文章，我的C语言系列文章有一节整数存储的相关文章，您可以去看一下……

对于`n bit`的二进制数，有以下的存储结论

1. 全部二进制都是数值位，没有符号位

2. 第`i`位的位权是$2^{i-1}$

3. `n bit`无符号整数表示的十进制整数的范围是$[0,2^{n - 1}]$，超出就会发生溢出

4. 最小数为全`0`二进制数，最大数为全`1`二进制数

# 2.无符号整数加法、减法的实现原理

## 2.1.无符号加法

对于计算机来说无符号整数的加法直接和人类进行手算是一样的，直接相加即可，无需做特殊处理。

## 2.2.无符号减法

对于计算机来说无符号的减法需要进行一些特殊处理：

1. `被减数`没有变化

2. `减数`全部`按位取反`，再`+1`取得补码

3. 改`-`为``+`转化为加法

这里举一个例子，对于`8bit`位的寄存器：`99 - 9 = 0110 0011 - 0000 1001 = 0110 0011 + 1111 0111 = (0001) 0101 1010 = 0101 1010 = 90`

# 3.有符号整数加法、减法的实现原理

一般使用最高位`bit`位使用数值表示`+/-`，即`0`表示`+`，`1`表示`-`。

而需要注意的是，`真值0`有两种表达方式，一个是`00(2)`另一个是`10(2)`，也就是所谓的`+0`和`-0`。

并且，补码的转化不涉及符号位。

实际上，无论有无符号，`操作数1`和`操作数2`统一使用补码然后进行加法再计算，再将结果返回原码则可得出正确结果。

> 补充：如果希望加快转化原码到补码的速度，可以从右往左找到第一个`1`，然后这个`1`左边的所有`数值位`按位取反，反过来补码转原码也一样。

# 4.正数和负数的补码关系

`B[补]`全部比特位（包括符号位）按位取反后末尾加`1`得到`-B[补]`，而`-B[补]`得到`B[补]`也是一样的步骤。

> 补充1：如果希望加快转化`B[补]`和`-B[补]`的速度，还可以从右往左找到第一个`1`，然后这个`1`左边的所有`比特位（包括符号位）`按位取反。
> 
> 补充2：如果是原码转补码也有类似的特性，`-24(10)=10011000(2)`的补码可以从右到左找第一个`1`，`1`的左边全部取反，不算符号位，因此得到`11101000`。

# 5.原反补码特性对比

补码的合法范围会多出一个负数，即所谓`-0`，这个数被看作非零数，并不是`0`。因此真值`0`对于补码来所只有一种表达方式（对于反码和原码都是两种）。

若假设目前有`8`个`bit`位的补码，则最小数应该是`1000 0000(2) = -128(10)`。

因此原码和反码的合法范围完全相同，但是补码会多出一个负数

> 注意：对于8`bit`的二进制，如果使用原码保存结果，则`(-64)+(-64)`会发生溢出，但使用补码不会。

# 6.移码

移码实在补码的基础上将符号位取反诞生的，移码只能表示整数。

移码对于真值`0`的表示也只有一种，表示的合法范围和补码一样，也是可以多表示一个负数。

移码会运用在浮点数的阶当中（以后讲）。

移码能从0开始和补码一一映射。 
