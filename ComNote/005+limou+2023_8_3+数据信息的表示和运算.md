[TOC]

数据表示可以方便计算机识别和使用，一般要考虑：数据类型、范围和精度、存储和处理代价、可移植性等。

# 1.整数

## 1.1.整数表示

[略]

## 1.2.整数加减法

关于原、反、补不再补充。

1.   无符号整数加法：两操作数直接`bit`位相加
     $$
     A + B
     $$

2.   无符号整数减法：将`-`交给减数构成`-减数`，式子变成加式，取$被减数_{补}$和$(-减数)_{补}$，然后全部`bit`位相加
     $$
     A - B = A_{取补} + (-B)_{取补}
     $$

3.   有符号整数加法：两操作数全部取补码，进行补码相加（即全部`bit`位相加）
     $$
     A + B = (A_{取补} + B_{取补})_{取原}
     $$

4.   有符号整数减法：两操作数全部取补码，进行补码相减（即将补码理解为无符号整数的相减，转化为无符号整数相减）
     $$
     A - B = (A_{取补} - B_{取补})_{取原}\\
     $$

> 补充`1`：如果希望加快转化$X_{补}$到$(-X)_{补}$的速度，可以从右往左找到第一个`1`，然后这个`1`左边的所有`比特位`（要包括符号位）按位取反即可。
>
> 补充`2`：如果希望加快转化$X_{原}$到$X_{补}$的速度，可以从右往左找到第一个`1`，然后这个`1`左边的所有`数值位`（不包括符号位）按位取反即可。
>
> 补充`3`：如果没有指明字长，写带符号位的二进制可以不用写多余的`0`，例如：`1000011`可以写成`1,11`
>
> 补充`4`：实际上，“无符号整数的减法运算的过程”和“补码减法的过程”是一样的。因为补码可以理解为无符号整数。由于这两个过程是一样的，因此可以让“无符号整数相减”和“补码相减”共用一个加法器。
>

## 1.3.原反补移码特性对比

| $(n + 1)\,bit的二进制序列$ | 合法范围                     | Max        | Min                                        | 真值$0$的表示                       |
| -------------------------- | ---------------------------- | ---------- | ------------------------------------------ | ----------------------------------- |
| 带符号整数原码             | $[-(2^{n} - 1),(2^{n} - 1)]$ | $0,111..1$ | $1,111..1$                                 | 有$\pm 0$                           |
| 带符号整数反码             | $[-(2^{n} - 1),(2^{n} - 1)]$ | $0,111..1$ | $1,111..1$                                 | 有$\pm 0$                           |
| 带符号整数补码             | $[-2^{n},(2^{n} - 1)]$       | $0,111..1$ | $1,000..0$该数无法在$n+1\,bit$内转变为原码 | 只有$0$，$-0$是有意义的，表示最小数 |
| 带符号整数                 | $[0,(2^{n+1} - 1)]$          | $1111..1$  | $0000..0$                                  | 只有$0$                             |

>   补充：判断溢出可以先转化为十进制再验证是否溢出

移码是在补码的基础上将其符号位取反诞生的，移码只能表示整数。移码对于真值`0`的表示也只有一种，表示的合法范围和补码一样，也是可以多表示一个负数，两者是一一对应的。真值转化为补码，然后转化为移码，将移码作为无符号整数理解，则可以更好对比大小。

移码会运用在浮点数的阶码当中（以后讲）。

>   补充： [-0]原码=1000 0000  [-0]反码=1111 1111  [-0]补码=0000 0000

# 2.小数

## 2.1.小数表示方法

### 2.1.1.定点小数

定点小数的小数点固定在符号位后面的某一位置，小数点位置的不同，会导致二进制的位权不一样，造成结果不同。

> 补充`1`：定点整数也就是带符号整数，默认小数点固定在最后的位置。
>
> 补充`2`：
>
> 1.   定点整数通常会在符号位后使用`,`隔离开符号位和数值位
> 2.   定点小数通常会在符号位后使用`.`来隔开符号位和数值位

如果我们需要对定点数进行比特位拓展，由于小数点的位置不同，为了保持位权不变：

1.   定点整数应该在符号位后面拓展比特位（例：$1,110 \to 1,[000]110$）
2.   定点小数应该在最末尾后面拓展比特位（例：$1.110 \to 1.110[000]$）

### 2.1.2.浮点小数

[略]

## 2.2.小数加减法

除了解读方法不一样，小数的加法和减法和整数都一样。

## 2.3.原反补特性对比

定点小数的原反补码以及有无符号相加和定点整数一样没有太大区别（定点小数没有移码的概念），不过需要注意的是，定点小数的补码也会多出一位，并且真值`0`也只有一种表达方式。

# 3.编码

## 3.1.BCD/8421码映射

`BCD`码（Binary-Coded Decimal）是一种用二进制数来编码十进制数字的方式。`BCD`码使用`4`位二进制数来表示一个十进制数的每一位。而`8421`码是`BCD`码的一种实例化：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

因此`132`可以表示为`0001 0011 0010`，其中`8421`码没有`1010~1111`的定义（也就是`10~15`）。那么如果进行计算`+`运算呢？

`5 + 8 = 13`就可以先直接`0101 + 1000 = 1101`，但是`BCD`码没有`1101`定义怎么办呢？可以在原二进制值`+6`来进行进位修正。即：`1101 + 0110 = 1 0011 = (13)10`。

>   补充：由于`BCD`码只使用了`4bit`位组中的10个定义，还剩下了6个定义没有被使用，因此如果我们修改映射方案就可以得到不同的编码规则。

## 3.2.余3码映射

在`8421`码的基础上，每个码值的定义都加上`0011`（十进制为3）

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

## 3.3.2412码映射

这种映射方案直接改变了权值，把`8421`对应的二进制权值修改为`2421`，因此码值的映射关系如下：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

但是这种编码方案有一个问题，比如`5`有两种表示方法`0101`和`1011`，因此我们还额外规定`0~4`的第一位二进制位是`0`，`5~9`的第一位二进制位是`1`，这样就可以使得定义变得唯一确定。







