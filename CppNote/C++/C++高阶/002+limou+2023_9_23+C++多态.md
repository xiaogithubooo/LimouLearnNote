# 1.多态概念

就是“多种形态”，完成某个方法的时候，使用不同的对象就会得出不同的结果。

# 2.多态的使用和方式

多态会使用一种虚函数的东西，关键字和虚继承是一样的，但是两者没有关系，只是公用了一个关键字`virtual`。

书写一个子类的虚函数，可以叫做“重写/覆盖”。

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    virtual void BuyTicket()
    {
        cout << "买票-全价" << endl;
    }
};
class Student : public Person
{
public:
    virtual void BuyTicket()
    {
        cout << "买票-半价" << endl;
    }
};
class Child : public Person
{
public:
    virtual void BuyTicket()
    {
        cout << "买票-免费" << endl;
    }
};
void Function(Person& p)//只能使用指针和引用去调用
{
    p.BuyTicket();
}
int main()
{
    Person p;
    Student s;
    Child c;
    Function(p);
    Function(s);
    Function(c);
    return 0;
}
```

这里使用多态的时候就产生了切片。这里要注意一个点，能使用指针和引用去调用！

1. 虚函数重写

2. 引用调用或者指针调用

但是在继承的时候，析构函数是很特殊的，是编译器自己调用，在

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person p;
    Student s;
    return 0;
}
//输出：
//~Student()
//~Person()
//~Person()
//没毛病，这里前两局都是在s内完成的，在s释放完自己的资源后，结尾为自动调用父类的资源
```

但是如果使用指针切片就会出现问题了：

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person* ptr1 = new Person;
    Person* ptr2 = new Student;
    delete ptr1;
    delete ptr2;
    return 0;
}
//输出：
//~Person()
//~Person()
//出现内存泄漏，Student的部分没有被释放
```

为什么呢，因为这里的析构函数不会调用上面的名称，而是统一改为`destructor()`构成父子隐藏，只会使用`ptr1->destructor()`和`ptr2->destructor()`，而由于`ptr2`都是父类类型的指针，因此只会调用父类的析构函数，这个时候就必须使用多态来重写了。

只需要这么修改即可：

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    virtual ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    virtual ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person* ptr1 = new Person;
    Person* ptr2 = new Student;
    delete ptr1;
    delete ptr2;
    return 0;
}
//输出：
//~Person()
//~Student()
//~Person()
```


