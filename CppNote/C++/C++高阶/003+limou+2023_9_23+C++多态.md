# 1.多态概念

就是“多种形态”，完成某个方法的时候，使用不同的对象就会得出不同的结果。

# 2.多态使用

多态会使用一种虚函数的东西，关键字和虚继承是一样的，但是两者没有关系，只是公用了一个关键字`virtual`。

书写一个子类的虚函数，可以叫做“重写/覆盖”。

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    virtual void BuyTicket()
    {
        cout << "买票-全价" << endl;
    }
};
class Student : public Person
{
public:
    virtual void BuyTicket()
    {
        cout << "买票-半价" << endl;
    }
};
class Child : public Person
{
public:
    virtual void BuyTicket()
    {
        cout << "买票-免费" << endl;
    }
};
void Function(Person& p)//只能使用指针和引用去调用
{
    p.BuyTicket();
}
int main()
{
    Person p;
    Student s;
    Child c;
    Function(p);
    Function(s);
    Function(c);
    return 0;
}
```

这里使用多态的时候就产生了切片。这里要注意一个点，能使用指针和引用去调用！

1. 虚函数重写

2. 引用调用或者指针调用

但是在继承的时候，析构函数是很特殊的，是编译器自己调用，在

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person p;
    Student s;
    return 0;
}
//输出：
//~Student()
//~Person()
//~Person()
//没毛病，这里前两局都是在s内完成的，在s释放完自己的资源后，结尾为自动调用父类的资源
```

但是如果使用指针切片就会出现问题了：

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person* ptr1 = new Person;
    Person* ptr2 = new Student;
    delete ptr1;
    delete ptr2;
    return 0;
}
//输出：
//~Person()
//~Person()
//出现内存泄漏，Student的部分没有被释放
```

为什么呢，因为这里的析构函数不会调用上面的名称，而是统一改为`destructor()`构成父子隐藏，只会使用`ptr1->destructor()`和`ptr2->destructor()`，而由于`ptr2`都是父类类型的指针，因此只会调用父类的析构函数，这个时候就必须使用多态来重写了。

只需要这么修改即可：

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    virtual ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    virtual ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person* ptr1 = new Person;
    Person* ptr2 = new Student;
    delete ptr1;
    delete ptr2;
    return 0;
}
//输出：
//~Person()
//~Student()
//~Person()
```

总结起来，多态的条件就是：

1. 虚函数必须要求函数签名完全相同（不过有时有些例外：返回值有时可以不同，不过必须是父子关系的指针或者引用）

2. 必须通过父类的对象指针或者对象引用来调用虚函数

3. 被调用的函数必须是虚函数

不满足多态看类型调用即可，是多态看是否继承，在父子对象间进行选择。

注意“隐藏”的体现在于子类调用从父类继承过来并且隐藏的函数，无法直接调用父类同名的函数。

有一种情况很特殊，父类里的函数就是虚函数，子类从父类继承该函数，因此子类的该函数也是虚函数，因此不需要写关键字也可以达成多态。

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    virtual ~Person()
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person
{
public:
    ~Student()
    {
        cout << "~Student()" << endl;
    }
};

int main()
{
    Person* ptr1 = new Person;
    Person* ptr2 = new Student;
    delete ptr1;
    delete ptr2;
    return 0;
}
```

这个也叫“接口继承”，只需要继承父类的虚函数成员之后重写这个函数即可，不需要关键字修饰。

这个接口目前猜测是为了子类继承父函数的虚析构函数后，哪怕不使用关键字都可以被调用，避免内存泄漏（因此也对析构函数做了统一命名的处理，满足这一特性）。

```c++
#include <iostream>
#include <string>
using namespace std;
class Person
{
public:
    virtual Person* BuyTicket()
    {
        cout << "全价" << endl;
        return this;
    }
};
class Student : public Person
{
public:
    virtual Student* BuyTicket()
    {
        cout << "半价" << endl;
        return this;
    }
};

int main()
{
    Person* ptr1 = new Person;
    Person* ptr2 = new Student;
    ptr1->BuyTicket();
    ptr2->BuyTicket();

    delete ptr1;
    delete ptr2;
    return 0;
}
```

这种例外就叫“协变”，也就是在多态的同时，函数返回值可以不同。并且只要具有父子关系的类即可，不局限于本类（并且也可以省略`virtual`关键字），但是协变的实际应用很少。

```c++
#include <iostream>
#include <string>
using namespace std;
class A
{
public:
    virtual void func(int val = 1)
    {
        std::cout << "A->" << val << std::endl;
    }
    virtual void test()
    {
        func();
     }
};
class B : public A
{
public:
    void func(int val = 0)
    {
        std::cout << "B->" << val << std::endl;
    }
    //1.从父类继承过来的test(A* const this)
    //2.满足多态接收this的时候就是用父类指针接收不同类型的对象
};
int main()
{
    B* p = new B;
    p->test();
    //3.调用了子类中从父类中继承的test()，内部继承的func继承了缺省值
    return 0;
}
```

上面这个代码就凸显了“重写实现”

```c++
#include <iostream>
#include <string>
using namespace std;
class A
{
public:
    virtual void func(int val = 1)
    {
        std::cout << "A->" << val << std::endl;
    }
};
class B : public A
{
public:
    void func(int val = 0)//3.正常调用这个函数
    {
        std::cout << "B->" << val << std::endl;
    }
    virtual void test()//1.这里的this指针的类型是B*，不是父类指针，不满足多态
    {
        func();
    }
};
int main()
{
    B* p = new B;
    p->test();//2.调用B内的test()函数
    return 0;

}//只有多态的时候才会考虑接口继承
```

普通函数的继承是一种实现继承，如果子类继承了父类函数，那么就可以使用该函数。而虚函数的继承是一种实现继承，目的是为了重写，达成多态，继承的是接口，如果不实现多态就不要写成虚函数。

> 补充：两个有关虚函数的关键字
> 
> 1. `final`：修饰虚函数，表示该函数不能被重写，加在函数名后面
> 
> 2. `override`：检查子类的虚函数是否重写了父类的某个虚函数，没有重写就编译报错，也是写在函数名字的后面（但是是在子类写）

# 3.重载、重写/覆盖、重定义/隐藏的区别

...

# 4.抽象类

在虚函数的后面加上`=0`那么这个函数就会变成纯虚函数，包含纯虚函数的类也叫抽象类（接口类），抽象类不能实例出对象。

抽象类强制子类重写。

# 5.多态原理

使用虚函数的类会多一个`_vfptr`虚函数表指针成员，指向一个虚函数指针数组。

实际这就是多态的原理，虚函数为什么和指针类型无关，而是指针指向的类型有关呢？

父类对象的虚表存储父类虚函数，子类对象的虚表存储子类虚函数。

在汇编代码的时候就可以看出。

重写是语言层面，覆盖是原理层面（覆盖率虚函数表内的指针成员）。

为什么不直接存在对象内？有可能有多个虚函数。

虚函数表在编译时就会提前准备好。

并且虚函数谁先声明谁的下标就越前。

那为什么直接对象切片不可以使用多态呢？表面看是规定，本质是内部虚表指针成员不会被拷贝（调用拷贝构造函数没有办法拷贝虚表，只能拷贝别的成员）因此不会有多态。

也就是说多态依赖于虚函数表/虚函数表指针。

虚函数存在虚表？不对的，虚函数和普通函数一样存储方式，但是虚表留有虚函数的指针。


