之前我们学习的模板能达到泛型的原因是：使用了“泛型的类型”，但是很明显我们经过前面的“造轮子”，会很明显发现泛型可能不仅仅是类型的问题，例如：“适配器”的使用，实际上就是一种泛型。

之前我们学习的模板能达到泛型的原因是：使用了“泛型的类型”，但是很明显我们经过前面的“造轮子”，会很明显发现泛型可能不仅仅是类型的问题，例如：“适配器”的使用，实际上就是一种泛型。

之前我们学习的模板能达到泛型的原因是：使用了“泛型的类型”，但是很明显我们经过前面的“造轮子”，会很明显发现泛型可能不仅仅是类型的问题，例如：“适配器”的使用，实际上就是一种泛型。

因此对于泛型的理解我们不能仅限于类型。

由此我们将以`C++`新手的身份来开始学习。

# 1.非类型模板

模板除了类型模板，还有非类型模板。

1. 类型模板：出现在模板的参数列表中，跟在`class`或者`typname`后的参数类型名称

2. 非类型模板：使用一个常量作为类的一个参数，在模板类/模板函数中可以将该参数作为常量来使用

```c++
#include <iostream>
using namespace std;
#define NUM 10

template<class T>
class Data
{
public:
    //...
private:
    T _arr[NUM];
};
int main()
{
    Data<int> a1;//无法修改初始化大小，只能手动调整#define的值，和之前的typedef的问题类似
    Data<double> a2;
}
```

这个时候就可以使用非类型模板参数，这个参数是一个常量，更加准确来说是：不可被修改的整形常量（包括布尔类型）。

```c++
#include <iostream>
using namespace std;
//#define NUM 10

template<class T, size_t N = 50>
class Data
{
public:
    //...
private:
    T _arr[N];
};
int main()
{
    Data<int, 10> a1;//无法修改初始化大小，只能手动调整#define的值
    Data<double, 20> a2;
}
```

您可能会疑惑：为什么不可以初始化先使用`new`开辟固定的空间，等到后续操作进行扩容操作呢？

注意这里只是利用这个例子来简述语法特性，并不是实际的用途（在后续“位图”等知识中有很大的价值）。

除了使用这个常量，还可以将这个常量作为一个标识数字来使用，不过这一点我们后续再来提及。

这里非类型模板参数也可以使用缺省值。

另外函数模板也可以使用这一特性。

```c++
#include <iostream>
using namespace std;
//#define NUM 10

template<class T, size_t N = 50>
class Data
{
public:
    //...
public:
    T _arr[N];
};
template<class T, long NUM = 50>//演示了其他整形
void function(T& i)
{
    i = NUM;
}

int main()
{
    Data<int, 10> a1;
    Data<int, 100> a2;
    int i = 0;
    function<int, 200>(i);//演示了函数修改非类型模板参数
    cout << i << endl;
}
```

不过`C++ 11`搞了一个新的容器：静态数组`array`，其类模板就是使用了这个非类型模板参数。

```c++
#include <iostream>
#include <array>
using namespace std;
int main()
{
    array<int, 10>arr;
    for (auto &i : arr)
      {
            i = 10;
      }
    for (auto i : arr)
    {
        cout << i << " ";
    }
    cout << endl;
    return 0;
}
```

可惜静态数组不会进行初始化（吐槽：`std::array`当参数传递仍然要把数组长度传过去，挺搞笑的...），但是支持范围`for`，并且越界检查比较严格（传统数组是抽查，但是静态数组是读写越界全面检查，避免代码崩溃），嘛...感觉优势不够大（大不了使用`vector`，这也可以查找越界，还可以使用列表初始化）所以推广并不高。这个容器有点强迫症统一`STL`风格的感觉，类似`deque`在`list`和`vector`的感觉，静态数组就是传统数组和`vector`之间。

# 2.模板特化

通常模板可以实现和类型无关的代码，但是有一些特殊的类型可能会得到一些错误的/不符合预期的结果，因此有了“模板特化”这个概念。

## 2.1.类模板特化

### 2.1.1.全特化

```c++
#include <iostream>
using namespace std;
template<class T1, class T2>
class Data
{
public:
    Data()
    {
        cout << "Data<T1, T2>" << endl;
    }
private:
    T1 _d1;
    T2 _d2;
};

template<>//全特化
class Data<int, char>
{
public:
    Data()
    { 
        cout << "Data<int, char>" << endl;
    }
private:
    int _d1;
    char _d2;
};
void TestVector()
{
    Data<int, int> d1;
    Data<int, char> d2;
}
```

### 2.1.2.偏特化

```c++
#include <iostream>
using namespace std;
template<class T1, class T2>
class Data
{
public:
    Data() { cout << "Data<T1, T2>" << endl; }
private:
    T1 _d1;
    T2 _d2;
};

//1.部分类模板参数特化
template <class T1>
class Data<T1, int>
{
public:
    Data() { cout << "Data<T1, int>" << endl; }
private:
    T1 _d1;
    int _d2;
};

//2.1.对两个参数进行进一步限制，偏特化为指针类型
template <typename T1, typename T2>
class Data <T1*, T2*>
{
public:
    Data() { cout << "Data<T1*, T2*>" << endl; }
private:
    T1 _d1;
    T2 _d2;
};

//2.2.对两个参数进行进一步限制，偏特化为引用类型
template <typename T1, typename T2>
class Data <T1&, T2&>
{
public:
    Data(const T1& d1, const T2& d2)
        : _d1(d1)
        , _d2(d2)
    {
        cout << "Data<T1&, T2&>" << endl;
    }
private:
    const T1& _d1;
    const T2& _d2;
};
void test2()
{
    Data<double, int> d1;//调用特化的int版本
    Data<int, double> d2;//调用基础的模板
    Data<int*, int*> d3;//调用特化的指针版本
    Data<int&, int&> d4(1, 2);//调用特化的指针版本
}
```

偏特化会使得特化更加强大。

## 2.2.函数模板特化

```c++
//函数模板
template<class T>
bool Less(T left, T right)
{
    return left < right;
}
//对Less函数模板进行特化
template<>
bool Less<Date*>(Date* left, Date* right)
{
    return *left < *right; 
} 
int main()
{
    cout << Less(1, 2) << endl;
    Date d1(2022, 7, 7);
    Date d2(2022, 7, 8);
    cout << Less(d1, d2) << endl;
    Date* p1 = &d1; Date* p2 = &d2;
    cout << Less(p1, p2) << endl;//调用特化之后的版本，而不走模板生成了
    return 0;
}
```

> 注意：区分好“匹配”和“特化”和“实例化”。这个实例化还能个性定制标准库中的类模板，自己进行特化。而且特化不是全新的模板，不可以单独存在。

实际上特化更加适合类模板一些。

# 3.模板分离解析

这一点凸显在函数的声明定义的分离上。

假设有下面三个文件：

```c++
#pragma once
//function.h内声明
#include <iostream>
template<class T>
T Add(const T& left, const T& right);

int NoTemplateAdd(const int& left, const int& right);
```

```c++
//function.cpp内定义
template<class T>
T Add(const T& left, const T& right)
{
    return left + right;
}

int NoTemplateAdd(const int& left, const int& right)
{
    return left + right;
}
```

```c++
//main.cpp内包含头文件并且定义
#include "function.h"
int main()
{
    std::cout << Add(1, 2);//链接错误
    std::cout << Add(1.0, 2.0);//链接错误
    std::cout << NoTemplateAdd(1, 2);//成功调用
    return 0;
}
```

可以发现函数模板没有办法声明和定义分离在两个文件中，会显示链接错误。

让我们来分析一下这里面的原因：在`function.cpp`编译生成`function.obj`，编译器没有看到`ADD`函数模板的实例化，因此没有生成具体的加法函数，而需要被编译才能具有地址。

因此后续链接的时候就会报错（这里还能再写详细一些）。

如果一定要分离，要么进行显示实例化（有缺陷），要么在一个翻译单元里分离（即：干脆直接写在`.hpp`内，更加推荐）。

> 补充：模板的总结
> 
> 1. 优点：模板复用了代码节省了资源，可以更快迭代开发，`STL`也应运而生。并且增强了代码的灵活性。
> 
> 2. 缺点：会出现代码膨胀问题，导致编译时间变成。并且类模板编译出错的时候，错误信息会显得比较凌乱，不容易定位错误。

