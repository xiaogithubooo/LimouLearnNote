关于反向迭代器，我们可以复制正向迭代器的代码，稍微修改即可，但是`C++`为了效率，使用`萃取`这一技巧，但是我们只提及一点，不完全讲完，等待后期补充。

以前我们在写双向循环链表的时候以为`rend()`指向的就是头节点，然后`rbegin()`指向的是最后一个节点，这样子的话，一直`rbegin()++`到遇到头节点就停下。

但是实际上在`C++`为了最求对称，实现的是：`rbegin()`指向头节点，`rend()`指向第一个有效数据节点，并且直接`*rebgin()`的底层是`*(rbegin()+1)`，然后一直`rbegin()++`到

也就是说`end()==rbegin()`和`begin()==rend()`

<img src="./assets/3d1dd073-b679-4849-9548-9e886b2f2692.png" title="" alt="3d1dd073-b679-4849-9548-9e886b2f2692" style="zoom:50%;">

#pragma once
namespace limou
{
    template<typename Iterator, class Ref, class Ptr>
    struct ReverseIterator
    {
        typedef ReverseIterator<Iterator, Ref, Ptr> Self;
        Iterator _cur;
        ReverseIterator(Iterator it)
            :_cur(it){}
        Ref operator*()
        {
            Iterator tmp = _cur;
            --tmp;
            return *tmp;
        }
        Ptr operator->()
        {
            ;//...
        }
        Self& operator++()
        {
            _cur--;
            return *this;
        }
        Self& operator--()
        {
            _cur++;
            return *this;
        }
        bool operator!=(const Self& s)
        {
            return _cur != s._cur;
        }
    };
}

额，没看懂....

反向迭代器包含一个正向迭代器（支持--的双向迭代器）？

这是做了复用，以后看

大概知道了思路就是正向迭代器利用泛型思想来反向迭代器，并且成为一个适配器。
