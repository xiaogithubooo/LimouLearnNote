# 1.传统错误

在`C`语言中，传统的错误处理方式有：

1.   `assert()`，缺陷就是太过于武断，会直接终止程序
2.   返回错误码，在`Linux`编程中就十分常见

因此实际上`C`都是通过错误码来处理错误的，部分情况下使用终止程序处理严重错误。

# 2.异常概念

`C++`的异常是一种处理错误的方式，当一个函数发现自己无法处理某个错误时，就可以抛出异常，让函数直接或间接的调用者处理这个错误。 

-   `throw`：当问题出现时，通过使用`throw`关键字，程序就会抛出某个类型的异常
-   `catch`：该关键字可以捕获异常，可以设置多个类型的捕获
-   `try`：`try`块中的代码标识将被激活的某些异常，它后面通常跟着一个或多个`catch`块，异常通常在这里被抛出，捕获异常则会使用`catch`

# 3.异常使用

```cpp
throw /*抛出异常*/
//...
try {
    //正常执行
}
catch (/*接收异常*/){
    //代码 1
}
catch (/*接收异常*/){
    //代码 2
}
catch (/*接收异常*/){
    //代码 2
}
```

假设我们写一个除法，有可能出现除零错误

```cpp
#include <iostream>
using namespace std;

class Data
{
public:
	Data(int data = 100)
		: _data(data)
	{
		cout << "构造" << '\n';
	}
	~Data()
	{
		cout << "析构 " << '\n';
	}
private:
	int _data;
};

double Division(int left, int right)
{
	if (right == 0)
	{
		throw "除零错误";
	}
	return (double)left / (double)right;
}

void Func()
{
	Data d1;//虽然抛出异常，但是这里的析构也会调用
	int left, right;
	cin >> left >> right;
	cout << Division(left, right) << '\n';
	Data d2;//如果发生除零错误，这里以后代码就不会被执行，因此 d2 不会调用构造和析构
}

int main()
{
	//一般都在外层代码捕获
	try
	{
		Func();
	}
	catch (const char* str)
	{
		cout << str << '\n';
	}
	return 0;
}
```

在函数调用链中异常栈的展开匹配原则：

1.   首先检查`throw`本身是否在`try`块内部
2.   如果是再查找匹配的`catch`语句
3.   如果有匹配的接受异常的类型，则调到`catch`的地方进行处理（这一行为很像函数的传参，抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在`catch`后销毁）
4.   没有匹配的`catch`则退出当前函数栈，继续在调用函数的栈中进行查找匹配的`catch`
5.   如果到达`main`函数的栈，依旧没有匹配的，则终止程序（行为类似`assert`）

上述这个沿着调用链查找匹配的`catch`子句的过程称为“栈展开”。所以实际中我们最后都要加一个`catch(...)`捕获任意类型的异 常，否则当有异常没捕获，程序就会直接终止。

找到匹配的`catch`子句并处理以后，会继续沿着`catch`子句后面继续执行。

# 4.异常安全

构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化。

析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏（内存泄漏、句柄未关闭等）。

>   补充：`C++`中的异常经常会导致资源泄漏的问题，比如在`new`和`delete`中抛出了异常，导致内存泄漏，在`lock`和`unlock`之间抛出了异常导致死锁，`C++`经常使用`RAII`来解决以上问题，关于`RAII`我们智能指针这节进行讲解。

# 5.异常体系