我们在异常代码中留下了一个坑没填，就是下面这个代码关于`array`多次释放资源的问题。

```cpp
#include <iostream>
using namespace std;

double Division(int a, int b)
{
	if (b == 0)
	{
		throw "Division by zero condition";
	}
	return (double)a / (double)b;
}

void Function()
{
	int* array_1 = new int[10];//(6)new 本身也会抛出异常
	int* array_2 = new int[10];//(7)new 本身也会抛出异常

	try 
	{
		int len, time;
		cin >> len >> time;
		cout << Division(len, time) << '\n';//(1)假设抛出“除零异常”
	}
	catch (...)//(2)“除零异常”被代码拦截下来
	{
		//(3)先释放 array，防止内存泄露
		cout << "delete_1[] " << array_1 << '\n';
		delete[] array_1;
		cout << "delete_2[] " << array_2 << '\n';
		delete[] array_2;

		throw;//(4)重新将异常抛出去
	}
	cout << "delete_1[] " << array_1 << '\n';
	delete[] array_1;
	cout << "delete_2[] " << array_2 << '\n';
	delete[] array_2;
}

int main()
{
	try
	{
		Function();
	}
	catch (const char* error)//(5)“除零错误”会在这里被接收
	{
		cout << error << endl;
	}
	catch (const exception& e)//(8)new 的异常可以在这里被接收
	{
		cout << e.what() << '\n';
	}
	return 0;
}
```

这样捕捉异常就会十分困难，稍不注意就会导致内存泄漏，因此我们有必要学习智能指针。

# 1.内存泄漏分类

要解决这一痛病，就需要“对症下药”，那常见的内存泄露有哪一些呢？`C/C++`程序中一般我们关心两种方面的内存泄漏： 

1.   堆内存泄漏（`Heap leak`)  ：堆内存是指程序执行中，通过`malloc`、`calloc`、`realloc`、`new`等函数或关键字，从堆空间中分配的某块内存。该资源被用完后就必须通过调用对应的`free`或者`delete`释放掉。假设由于程序的设计错误，导致这部分内存资源没有被正常释放，那么以后这部分空间将无法再被使用（持续占用），就会产生内存泄漏 
2.   系统资源泄漏（`system resource leak`）：指程序使用系统分配的资源，比如使用了：方套接字、文件描述符、管道等，没有使用对应的函数释放掉，导致系统资源的浪费，严重时会导致系统效能减少，系统执行不稳定，资源逐渐减少

# 2.内存泄漏应对方案

## 2.1.事前预防型

1.   工程前期指定好良好的设计规范，编码过程中养成良好的编码规范，申请的内存空间需要匹配者释放（但如果碰上带有异常的代码，就算注意释放了，可能还会出现问题）
2.   采用`RAII`思想和智能指针来管理资源

## 2.2.事后查错型

1.   有些公司内部规范使用内部实现的私有内存管理库，这套库自带内存泄漏检测的功能选项
2.   出问题了使用内存泄漏工具检测（不过很多工具都不够靠谱，或者收费昂贵）

# 3.指针指针的原理

## 3.1.智能指针的模拟

实际上智能指针的原理没那么复杂，我们可以简单实现一个智能指针，让指针在是否抛出异常的情况下都可以正常释放，进而解决内存泄漏的问题。

```cpp
#include <iostream>
using namespace std;

class SmartPtr
{
public:
	SmartPtr(int* ptr)
		: _ptr(ptr)
	{}
	~SmartPtr()
	{
		delete _ptr;
		cout << "delete[] " << _ptr << '\n';
	}
private:
	int* _ptr;
};

int main()
{
	int* p = new int[10];
	SmartPtr sp(p);//交给智能指针管理
	return 0;
}
```

实际上这就是`RAII(Resource Acquisition Is Initialization)`，即：“资源请求立即初始化”。这翻译什么意思？好像和上面用到的东西没什么太大关联呀？实际上，这里的资源指`new`一类的调用，初始化就是将获取到的资源放入到构造函数内。

因此`RAII`实际就是一种利用对象生命周期控制持续资源（例如：内存、文件句柄、网络连接、互斥量等等）的简单技术，在对象生命周期结束时使用析构函数释放。实际上就是将管理资源的责任转移给了一个对象，这样做的好处很明显：

1.   无需显式释放资源
2.   对象在生命周期内始终保持有效

库中的智能指针是类似的原理，但是生成的智能指针对象需要像指针一样被用户使用，这就是库中智能指针和我们实现的简易智能指针的最大区别（因此重载`*`和`->`和`()`等符号就尤为重要，以及关于智能指针对象的拷贝问题）。

不过在考虑拷贝问题之前，我们先来试着将我们自己的`SmartPtr{};`改造为一个“指针”，也就是重载两个和指针脱不了干系的符号：`*`和`->`。

```cpp
```

# 4.库内的智能指针

## 4.1.[std::auto_ptr](www.cplusplus.com/reference/memory/auto_ptr/)库



## 4.2.[std::unique_ptr](https://cplusplus.com/reference/memory/unique_ptr/)库



## 4.3.[std::shared_ptr](https://cplusplus.com/reference/memory/shared_ptr/)库



>   内存泄漏检查工具
>
>   这个后续补充...
>
>   [Linux下几款C++程序中的内存泄露检查工具_c++内存泄露工具分析-CSDN博客](https://blog.csdn.net/gatieme/article/details/51959654)
>
>   [VS编程内存泄漏：VLD(Visual LeakDetector)内存泄露库-CSDN博客](https://blog.csdn.net/GZrhaunt/article/details/56839765)
>
>   [内存泄露检测工具比较 - 默默淡然 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liangxiaofeng/p/4318499.html)