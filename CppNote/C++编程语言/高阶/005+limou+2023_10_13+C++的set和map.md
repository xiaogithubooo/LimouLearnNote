# 1.set

`set`是`C++`的容器，底层使用了平衡搜索树的红黑树（`Red-Black Tree`）。使用起来很简单，就是需要注意不能有重复的元素。并且不允许通过迭代器直接修改元素，这会导致搜索树的结构被破坏。

合理使用该容器可以达到排序和去重的目的。

除了普通的`set`还有一个`multiset`，插入的时候允许键值冗余的平衡搜索二叉树，使用这个容器可以只达到排序的目的。其他的功能和`set`差不多，但是使用`count()`接口的时候会出现些许不同（返回一个键值的出现次数）如果使用`find()`会按照中序的顺序查找。

# 2.map

而`map`是存储键值对的关联容器，依靠`pair<Key, T>`键值对结构对象来构造二叉树（或者使用函数模板`make_pair()`的自动推导和构造，而且一般是作为内联），底层也是红黑树。

需要注意`find()`函数的返回值是一个迭代器，指向要查找的键值对，如果找到了指定的键，则返回指向该键值对的迭代器。如果未找到指定的键，则返回指向`map`末尾元素的迭代器`end()`。

不过`map`有个别具一格的`[]`重载，可以根据`key`值，查找对应的`value`值。其中`insert()`的返回值也很特殊，是一个`pair<iterator, bool>`类型。

```cpp
V& operator[]<const K& key>
{
    pair<iterator, bool> ret = insert(make_pair(key, V()));//插入的时候有两种可能：成功或者失败，成功返回一个<当前迭代器,true>，失败返回一个<当前迭代器,false>
    return ret.first->second;//找到迭代器中的值
}
```

这就使得`[]`有多种可能性：

1.   通过`key`查找对应的`value`
2.   修改`key`对应的`value`值
3.   插入从未出现过的`key`值，默认`value=V()`



