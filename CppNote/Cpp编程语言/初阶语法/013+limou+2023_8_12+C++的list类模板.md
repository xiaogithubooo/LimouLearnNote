# 1.list的基础认知

`list`实际上是一个带头双向链表的容器，允许在序列内的任何位置执行时间复杂度为`O(1)`插入和删除操作。

```c++
template < class T, class Alloc = allocator<T> > class list;
```

# 2.成员函数（Member functions）

## 2.1.构造函数

## 2.2.析构函数

## 2.3.拷贝构造和赋值重载

# 3.迭代器（Iterators）

# 4.容积（Capacity）

## 4.1.empty()

测试容器是否为空。

## 4.2.size()

返回大小。

## 4.3.max_size

返回最大大小。

# 5.元素访问（Element access）

## 5.1.front()

访问第一个元素。

## 5.2.back()

访问最后一个元素。

# 6.修改器（Modifiers）

## 6.1.assign()

将新内容分配给容器。

## 6.2.emplace_front()

在开头构造和插入元素。

## 6.3.push_front()

在开头插入元素。

## 6.4.pop_front()

删除第一个元素。

## 6.5.emplace_back()

在末尾构造和插入元素。

##  6.6.push_back()

在末尾添加元素。

## 6.7.pop_back()

删除最后一个元素。

## 6.8.emplace()

构造和插入元素。

## 6.9.insert()

插入元素。

## 6.10.erase()

擦除元素。

## 6.11.swap()

交换内容。

## 6.12.resize()

更改大小。

## 6.13.clear()

内容清晰。

# 7.操作（Operations）

## 7.1.splice()

将元素直接从一个列表拼接到另一个列表。

## 7.2.remove()

删除具有特定值的元素。

## 7.3.remove_if()和remove_if()

删除满足条件的元素。

## 7.4.unique()

在有序的链表中去除掉重复的节点。

## 7.5.merge()

将两个有序链表归并在一起（取小的节点尾插）。

## 7.6.sort()

这个排序区别与算法内部的排序有所区分，并且链表不可以直接使用算法库里的`sort()`，这涉及到迭代器的分类。`list`的成员函数`sort()`底层是归并排序。并且该函数在大数据量的情况下效率也一般，只是使用上比较方便（在实践中直接对链表排序也是挺少见的，更常见的做法是：将`list`中的数据拷贝到`vector`里，在`vector`中进行排序，再拷贝回去，而拷贝数据的代价并不算很大）。

> 在功能上，迭代器分为：1.正向 2.反向
> 
> 在性质上，迭代器分为：
> 
> 1. 单向（只支持++，比如哈希表、单链表）
> 
> 2. 双向（支持++/--，比如双向链表、红黑树（map和set））
> 
> 3. 随机（++/--/+/-，vector、string、deque）

## 7.7.reverse()



# 8.感测器（Observers）

## 8.1.get_allocator()

## 8.2.get_allocator()

# 9.非成员函数重载（Non-member function overloads）



> 补充：在`list`的实现中，由于是链表，所以使用`[]`效率很低，因此并没有重载这一个操作符。
