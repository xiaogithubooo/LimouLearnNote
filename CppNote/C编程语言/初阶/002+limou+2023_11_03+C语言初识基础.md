[TOC]

>   补充一些先导课程...

# 1.数据类型

## 1.1.数据类型使用分类

数据类型主要分为以下几类关键字：

```cpp
//数据类型
char     	//字符数据类型，存储单个字符 
short       //短整型，存储较小的整数
int         //整形，存储一般大小的整数
long        //长整型，存储较大的整数
long long   //更长的整形，存储更大的整数
float   	//单精度浮点数，存储低精度的小数
double      //双精度浮点数，存储高精度的小数
```

为什么需要数据类型关键字呢？数据类型可以帮助我们创建容器，也就是后面讲到的变量。

变量可以存储数据，这些数据不是立刻就需要被计算机作处理作输出的，可能还需要对变量内部的数据做一些其他的处理，等到处理完后才可以被计算机输出。

而使用容器/变量就是一种很好的选择，不同数据类型关键字创建出来的空间大小不同，内部存储规则也有可能不同，因此：根据数据的类型来择取数据类型关键字相当重要。

>   补充`1`：实际上在之后的编码中，使用整型类关键字较多，原因您以后就会明白。
>
>   补充`2`：上述有提到数据大小的字眼，如果您是编程新手，可能还需要了解下面的几个视频的知识。
>
>   -   了解什么是二进制，为什么我们需要二进制：[关于二进制，没有比这个讲的更清楚的了](https://www.bilibili.com/video/BV1Cb411s7hT?vd_source=4772b64d7a3cb1873f14bc0153c4de68)
>   -   这个视频可以了解一些计算机存储单位：[Bit、Byte、kb、KB、MB，KiB、MiB都有什么区别？硬盘容量不符竟是这个的原因！](https://www.bilibili.com/video/BV1QW411h7iu?vd_source=4772b64d7a3cb1873f14bc0153c4de68)

而数据类型还有符号之分，如果是有符号的数据，直接使用数据类型关键字即可（或者在数据类型的最前面加上关键字`signed`，但是这是默认行为，即使您不写也会自动加上）。但如果数据不具有符号，没有正数和负数之分，则最好使用`unsigned`修饰清楚。

## 1.2.数据类型的符号修饰

后续补充...

## 1.3.数据类型的存储范围

后续补充...

# 2.变量常量

## 2.1.变量

### 2.1.1.变量的创建

变量的创建很简单，只需要根据不同的数据的特点，择取对应的关键字以及选择一个名词作为变量名，直接创建即可。

```cpp
//创建变量
int a = 10;//变量 a 存储了 10 这个整数数据
int b = a;//同样可以用变量存储其他变量内的携带的数据，变量 b 存储了 a 内的值
flaot c = 3.14;//变量 c 存储了 3.14 这个小数，但是其值可能精确度不高
char ch = 'x';//ch 存储了 'x' 这个字符，注意需要加上单引号，告诉编译器 x 是一个字符而不是某一个新创建的变量

a = 100;//变量 a 被修改成 100，也就是说：变量之所以叫变量，就是因为可以被修改
```

上述的`a`、`b`、`c`、`ch`是四个变量的变量名，使用它们就是在使用变量。

并且我们还可以注意到，在代码的结尾`a`变量发生了变动，这也就是为什么变量称为“变量”的原因：在代码运行过程种，可被修改的量。

>   补充：变量的命名规则
>
>   不可以随意取变量名，我们需要遵循以下规则：
>
>   1.   最好由字母（包括大写和小写）、数字和下划线组成
>   2.   不以数字开头
>   3.   长度不超过`63`个字符
>   4.   区分大小写
>   5.   不能使用已有的关键字（您不能给变量取名为`int`、`float`等关键字）
>   6.   最好取有意义的英文名词、动词等，非必要不直接使用一个字母作为变量名

### 2.1.2.变量的作用域

”作用域“是程序设计的概念，通常来说，代码中所用到的变量名并不是总是有效、可用的，而变量名的可用范围就是该变量的作用域。

1.   局部变量作用域：就是变量所在的局部范围（其实就是一对`{}`内）
2.   全局变量作用域：在一个工程/源文件中，均可被使用（缺点是可能不够安全，这个被声明的变量容易改变值，引起其他地方的`bug`）

>   补充：需要注意的是，创建全局变量后，其内部初始的值为`0`，但是最好由我们自己初始化，时刻对刚创建的变量进行初始化是一种好的编程习惯。

### 2.1.3.变量的生命周期

”生命周期“就是指创建变量和销毁变量的时间段。

1.   局部变量生命周期：局部变量使用完就会被销毁，也就是说局部变量的生命周期从进入作用域时，生命开始，离开作用域时，生命结束。开始和结束之间，就是该局部变量的生命周期

2.   全局变量生命周期：全局变量的生命周期和“整个程序”是一样的，程序结束时，全局变量也就被销毁

## 2.2.常量

### 2.2.1.字面常量

就是在创建变量中，使用的直接从字面上就可以看出属于什么数据类型的量。

### 2.2.2.常变量

创建变量的过程中，使用`const`关键字可以让这个变量具有常量属性，在后续使用中虽然可以使用改变了，但是无法修改变量的值。

>   注意：但您需要记住，哪怕被`const`修饰了也依旧是一个变量，只不过无法被修改罢了。

### 2.2.3.宏常量

使用宏语法可以定义一个常量，这是`C`的一种特殊语法，我们以后会展开来讲。

### 2.2.4.枚举常量

枚举常量实际上属于结构体的知识，需要使用关键字`enmu`来创建一个枚举体。

```cpp
#include <stdio.h>

//#define 定义的标识符常量，在代码编译过程中，
//代码中有 MAX 的地方会先被全部替换成 100，
//注意，宏常量的定义，其末尾不加分号，容易出 bug
#define MAX 100

//以下创建了一个枚举常量，只能枚举出离散变量，但是连续变量就不能被枚举出来
enum Sex
{
	MALE,		//默认值为0
	FEMALE,		//默认值为1
	SECRET		//默认值为2
};
//若是将 MALE 设定为 5，则后面就依次改为 6、7，
//这叫“初始化值”，不是“修改值”，所以是常量，而非变量

int main()
{
	//1.字面常量
	//这里只是写出字面常量，顾名思义“从字面上就可以看出来”
	100;	//整型常量
	'W';	//字符常量
	3.14;	//浮点常量

	//2.const 常变量
	int number_1 = 1;		//在这里 1 也是常量，但是 a 是变量
	number_1 = 20;			//number_1 是变量，值可以从 10 变成 20
	const int number_2 = 10;	//const 修饰的常变量
	//number_2 = 20;			//使用了 const 关键字后，这里就会报错，变量 number_2 无法被修改

	//3.宏常量
	int n = MAX;	//MAX 常量会在代码运行前被替换成 100，因此变量 n 会被初始化为 100

	//4.枚举常量
	enum Sex s = FEMALE;	//变量 s 的值被初始化为 1

	return 0;
}
```

# 3.字符基础

## 3.1.字符

`C`语言表示字符由`''`引起，例如：`'w'`。

## 3.2.字符串

字符串由`""`引起，例如：`"abc"`，`"abc"`会自动在末尾加上`\0`，`\0`表示“结束”，是一个转义字符，并不算入字符串的内容，只是做一个结束标志。

>   注意：`"a"`和`'a'`是有区别的，前者有`\0`结尾，后者则没有！

字符串可以用两种方式存储，这两种方式在存储方式上有些许不同：

```cpp
char* s_ptr = "abcd";	 	//使用指针指向字符串
char s_arr[] = "abcd";		//使用数组存储字符串
```

您不必纠结什么是指针、数组，您只需要知道这样做就可以找到或者存储一个字符串即可。

## 3.3.转义字符

利用`\`字符，可以转变某些字符原有的意义，达到其他的目的。

常见的有：`\?`（打印`?`），`\'`（打印`'`），`\"`（打印`"`），`\\`（打印`\`），`\n`（换行），`\t`（水平制表符），`\v`（垂直制表符），`\b`（退格符，相当于`backspace`），`\f`（换页），`\r`（回车），`\ddd`（ddd表示八进制），`\xdd`（`dd`表示十六进制）。

上述转移字符可以使用`printf()`来验证效果，例如：`printf("\n")`就会在终端窗口换行。

>   补充：早期的编译器有三字母词概念，例如：`??)`代表`]`，因此`\?`是用来转义`?`的，使用`\?`可以正常打印出`?`，而不会被编译器识别为三字母词（类似想打印`"`，不能直接写`"`，而是要写`\"`）。
>
>   ```cpp
>   //由于三字母词的存在，打印出 (are you ok]
>   printf("(are you ok??)")
>       
>   //因此利用 \? 防止识别为三字母词，正常打印(are you ok??)
>   printf("(are you ok\?\?)")
>   
>   //printf(""");  //打印失败，会报错
>   printf("\""); 	//使用反义字符就可以打印出单个 "
>   ```

## 3.4.字符编码

实际上，字符需要转化为数字然后存储到计算机中，计算机需要显示字符时，再根据这个数字在字符集中查找对应的字符，然后才显示出来，而字符和数字之间对应的方案就叫做“`ASCII`码表/`ASCII`字符集”。

![image-20231123141937017](./assets/image-20231123141937017.png)

>   补充：上述表格来源于`C/C++`官网文档[ASCII 码表](https://zh.cppreference.com/w/cpp/language/ascii)，更多关于字符编码的知识可以在视频[锟斤拷�⊠是怎样炼成的——中文显示“⼊”门指南](https://www.bilibili.com/video/BV1cB4y177QR?vd_source=4772b64d7a3cb1873f14bc0153c4de68)中深入了解。

`ASCII`表虽然不用全部记忆（用时查），但是还是有必要简单记忆一下排布顺序：

-   字符`A~Z`的`ASCII`码值从`65~90`
-   字符`a~z`的`ASCII`码值从`97~122`
-   对应的⼤小写字符(`a`和`A`)的`ASCII`码值的差值是`32`（不是`26`！）
-   数字字符`0~9`的`ASCII`码值从`48~57`
-   在这些字符中`ASCII`码值从`0~31`这`32`个字符是不可打印字符，⽆法打印在屏幕上观察，他们具有别的特殊用法（都是一些控制字符或者反义字符）

如果输入对应的`ASCII`码值到变量`ch`中，使用`printf("%c", ch)`就打印出对应的字符。另外，还可以利用`\`来使用`ASCII`码值表，不过这种是使用八进制和十六进制的`ASCII`码值来打印字符：

```cpp
#include <stdio.h>
int main()
{
	printf("%c\n", 88);			//输出 X，使用 88 这个十进制来打印字符
	printf("%c\n", '\130');		//输出 X，其中 \130 是八进制的数字
	printf("%c\n", '\x58');		//输出 X，其中 \x58 是十六进制的数字

	//转义字符也算字符，整体包括 \ 符号看作一个整体
	return 0;
}
```

>   补充：需要注意的是，使用反义字符来表示字符时，其数值不可以超过`128`，也就是不能超过`ASCII`编码范围。

# 4.代码注释

## 4.1.注释作用

可以让别人看懂自己的代码，或者给未来的自己看懂自己的代码。再本系列中，我写的注释主要让您更 深入理解一些代码细节。

## 4.2.注释方式

`C`语言主要有两种注释方式，一是行注释`//...`，二是块注释`/*...*/`，需要注意的是，在双引号引起的字符串内无视这两种注释方式，例如：`"This a /*string1*/ and //string2"`，这是被允许的，不会被编译器识别出有注释的文本。

>   补充`1`：`/**/`不可以嵌套使用，例如：`/* /*...*/ */`，第一个`/*`只会和第一个出现的`*/`佩对，将两者中间的代码屏蔽掉。
>
>   补充`2`：`VS 2022`注释快捷键
>
>   用光标选中需要注释的代码，通过快捷键`[ctrl+k/ctrl+c]`添加注释，`[ctrl+k/ctrl+u]`取消注释，当然，您也可以找找工具栏的按钮，那里也有注释和取消注释的按钮。
>
>   补充`3`：实际上，行注释是`C++`的注释风格，在后面被添加到`C`中，我更推荐使用这种注释，不会产生配对问题，进而造成奇怪的错误。
>
>   补充`4`：注释会被编译器忽略，在代码被运行后，注释会被替换成空格。

# 5.逻辑语句

首先我们需要知道，在`C`语言中，一个表达式的结果不为`0`，这代表这个表达式为“真”，如是非零（包括负数）则为“假”。

```cpp
#include <stdio.h>
int main()
{
    printf("%d\n", 5 == 6);//5 肯定不等于 6，整个表达式结果为假，输出 0
    printf("%d"\n, 10 != -1);//10 确实不等于 -1，因此整个表达式结果为真，输出 1
    return 0;
}
```

而根据由表达式做出某些行为，就是控制语句的功能，该表达式可以被称为“条件”。这里我只是简单介绍一些常见的逻辑语句，让您知道如何使用逻辑语句。

## 5.1.选择语句

### 5.1.if语句

`if`语句可以根据某个条件做出选择，基本的代码格式是：

```cpp
if (<条件>)
{
    //代码 1
}
else
{
    //代码 2
}
```

只要`if`后的条件的结果为真，那么执行代码`1`，而不执行代码`2`。若为假，则跳过代码`1`，执行代码`2`。也就是说，代码`1`和代码`2`的结果只会执行一个。

```cpp
#include <stdio.h>
int main()
{
	int a = 1;
	if (a == 1)//如果 a 等于 1 就会执行代码 1，否则执行代码 2
	{
		printf("haha\n");//代码 1
	}
	else
	{
		printf("hehe\n");//代码 2
	}
	return 0;
}//因此只打印了 haha，不会打印 hehe，您可以修改一下变量的值再运行试试
```

还可以写出一些多分支的循环语句，可以进行多种选择。

```cpp
if (<条件 1>)
{
    //代码 1
}
else if (<条件 2>)
{
    //代码 2
}
else if (<条件 3>)
{
    //代码 3
}
else
{
	//代码 4
}
```

如果您愿意，还可以写出具有`5`种，乃至`6`种等等多种情况的`if`语句。

>   注意：最好不要在`if`语句后面加上分号，否则输出会出乎您的预料。
>
>   ```cpp
>   #include <stdio.h>
>   int main()
>   {
>       int a = 100;
>       if(a != 100);//失误多写了一个分号
>           printf("limou");//误以为不会输出 limou
>       return 0;
>   }
>   ```
>
>   上面代码的含义就发生的变化，正确的代码缩进就变成了下面这样。
>
>   ```cpp
>   #include <stdio.h>
>   int main()
>   {
>       int a = 100;
>       if(a != 100)
>           ;
>       printf("limou");
>       return 0;
>   }
>   ```
>
>   或者写成下面这样。
>
>   ```cpp
>   #include <stdio.h>
>   int main()
>   {
>       int a = 100;
>       if(a != 100)
>       {
>           ;
>       }
>       printf("limou");
>       return 0;
>   }
>   ```
>
>   因此代码还是会输出`limou`。

### 5.1.2.switch语句

`switch`语句也是一种选择语句，其作用是根据条件跳转到对应的标签，并且开始执行标签后的代码。

```cpp
switch (<条件>)//整型表达式
{
    case <某个常量值1>:
        //代码1
        break;
        
    case <某个常量值2>:
        //代码2
        break;
        
    case <某个常量值3>:
        //代码3
        break;
        
    case <某个常量值4>:
        //代码4
        break;
        
    //...
        
    default:
        //代码n
        break;
}
```

`switch`语句会根据入口处的整型表达式的结果来选择对应的标签，将程序跳转到该标签，然后开始执行往下执行代码，其中`break`语句是必须的，否则代码会一直往后执行，将所有代码执行完才结束`switch`语句。

其中`default`是可选的，只有在其他标签都没有被匹配到的情况下才会执行。

>   注意：不要在`switch()`后加分号！

## 5.2.循环语句

循环语句实际上就是`if`语句的拓展，只不过多加了循环执行的特性。最经典的循环语句就是`while`，除此以外，`C`还有一些其他书写循环的写法。

### 5.2.1.while

`while`的书写格式是：

```cpp
while(<条件>)
{
    //需要被循环执行的某段代码
}
```

因此我们可以借助循环语句，减少一些重复性的工作。

```cpp
#include <stdio.h>
int main()
{
    int i = 0;
    while (i < 10)
    {
        printf("%d ", i);
        i++;
    }
    return 0;
}
```

还可以写出一些可以被死循环的代码。

```cpp
#include <stdio.h>
int main()
{
	int number = 10;
	while (number < 20)//只要 number 小于 20 就进入循环
	{
		printf("你好\n");
	}
	return 0;
}
//结果是打印出无限的“你好”，这乍一看有些吓人，
//但在VS中可以直接关闭控制台就可以结束这个循环，
//或者按下快捷键 [ctrl + c]（不同系统的快捷键可能不太一样）
```

>   注意：不要轻易在`while()`后加分号，但是有些时候我们确实需要这样做，我们遇到再提及。

### 5.2.2.do-while

`do-while`也是书写循环的一种方式，但是和`while()`略有不同，两者在“先判断条件再执行代码，还是先执行代码再判断条件”上的顺序不一样，有时我们的确需要这种语句，简化我们的代码。

```cpp
#include <stdio.h>
int main()
{
	int i = 0;
	do
	{
		printf("%d\n", i);
		++i;//让 i 不断加一
	} while (i < 10);//先执行一次上面的代码，然后才进行判断，和 while 先判断再做的顺序相反

	return 0;
}//就会打印出 0~9 的 10 个数字
```

在之前的`while`循环中，我们是写了一个“死循环”（不断执行某些语句的代码，除非手动停下，否则不会自动停止），但是更多的时候，我们会设计出让循环自动停下来的代码，在上面代码中体现在`++i`这句代码中，只要让`i`不断自增`1`，总会出现`i > 10`的情况，因此就会导致`while(i < 10)`出的条件为假，导致循环停止。

### 5.2.3.for

`for`循环对比其他的循环语句会稍显复杂，我们需要先了解`for`循环语句的书写格式：

```cpp
for(<①初始化计数器>; <②判断计数器范围>; <④递增计数器>) //循环入口
{
	//③某些需要重复执行的代码
}
```

为什么是这种怪异的格式呢？我们回顾一下之前写的一段`while`代码：

```cpp
#include <stdio.h>
int main()
{
    int i = 0;			    //初始化计数器 i 为 0
    while (i < 10)			//判断计数器是否在某个范围内
    {
        printf("%d ", i);	 //执行某些需要被循环的语句
        i++;				//计数器更新（自增 1）
    }
    return 0;
}
```

我们可以发现，很多的循环语句都在做上面的事情：

1.   初始化计数器`i`为`0`
2.   判断计数器是否在某个范围内
3.   执行某些需要被循环的语句
4.   计数器更新（自增`1`）

但是这样写出的代码不够简洁，有的时候甚至会漏写某个步骤，这个时候怎么办呢？`C`提供了一种`for`循环语句，在循环的入口处就可以初始化计数器，然后根据循环条件判断是否执行循环体内的代码，最后更新计数器。也就是说，`for`代码的执行流程为$①\to ②\to ③\to ④ \to ① \to ...$

```cpp
#include <stdio.h>
int main()
{
	int i;
	for (i = 0; i < 10; i++)
	{
		printf("你好\n");
	}
	return 0;
}
```

# 6.函数

在`C`语言中，函数就是处理数据得出数据的代码块。

## 5.1.一些库函数

### 5.1.1.scanf()

该函数可以根据用户在控制台的输入和格式化字符，给变量设定值，是一个输入函数。

```cpp
#include<stdio.h>
int scanf(char* s, ...)
```

-   `scanf`读取失败就返回`EOF`，通常`EOF`的值是`-1`
-   正常读取则返回读取到格式化数据的个数

另外，在`VS 2022`，直接使用`scanf()`会报一个错误和一个警告：

1.   错误：`“This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.”`，出现这个错误，就需要在一开头使用`#define _CRT_SECURE_NO_WARNINGS 1`来屏蔽这个错误（出现这个错误的原因就是因为微软认为`scanf()`函数不够安全，要求您使用`scanf_s()`，但是为了学到“原汁原味”的`C`语言，我们最好还是继续使用`scanf()`）。

     但是每一次都需要添加这句话，未免有些麻烦，因此我们可以修改`VS 2022`的文件`newc++file.cpp`，在内部第一行写入`#define _CRT_SECURE_NO_WARNINGS 1`保存即可，以后创建`.c`文件后就会自动在第一行填充这句语句。

     那为什么微软会认为`scanf()`不安全呢？这和指针有关，我们之后学习了指针再来提及。

2.   警告：“`scanf()`的返回值被忽略”，提示我们要用上`scanf()`的返回值，我们可以暂时忽略这个，编译器只是提醒你：要注意使用返回值，不要轻易忽略。您可以用一个变量`scaRet`来接收使用`scanf()`的返回值。

有些时候，还可以利用`scanf()`的返回值来循环输入/多组输入，我们以后有机会再提及。

### 5.1.2.printf()

该函数可以根据变量的值和格式化字符，输出变量的值到控制台上，是一个输出函数。

```cpp
#include<stdio.h>
int printf(char* s, ...)
```

`printf`的返回值是是输出的字符数量，包括数字，字母，标点符号，空格，转义字符等

```cpp
#include<stdio.h>
int main()
{
	int A = 43;
	printf("%d\n", printf("%d", printf("%d", A)));
	return 0;
}
//结果会输出什么呢？432
//第三个 printf 输出 "43" 字符数量为 2，于是返回值为 2，第二个 printf 就输出 "2"
//第二个 printf 输出 "2" 字符数量为 1，于是返回值为 1，第一个 printf 就输出 "1"
```

```cpp
#include<stdio.h>
int main()
{
	printf("%d\n", printf("0,1,2,3\n"));
	return 0; 
}
//结果为
//0，1，2，3
//8
```

我们还可以用这个函数结合操作符`sizeof()`来打印出前面我们提及的“数据类型”的大小，其中注意：`sizeof()`不是一个函数，其作用只是获取一个数据类型或者变量的大小，可以使用`printf()`和`%zd`打印出来。

```cpp
#include <stdio.h>
int main()
{
    printf("%zd\n", sizeof(char));
    printf("%zd\n", sizeof(short));
    printf("%zd\n", sizeof(int));
    printf("%zd\n", sizeof(long));
    printf("%zd\n", sizeof(long long));
    printf("%zd\n", sizeof(float));
    printf("%zd\n", sizeof(double));
    return 0;
}
```

>   补充：关于占位符

### 5.1.3.strlen()

可以计算`C`风格字符串的长度，这里`C`风格字符串指的就是：以`\0`为结尾的字符串，该函数可以计算出字符串的长度（不包含`\0`）。

>   补充：在之后的学习中，我们还会遇到更多的库函数。这里我给出了一份方便[检索库函数的在线网站](https://legacy.cplusplus.com/reference/clibrary/)，虽然是全英文的，但还是请您留存一份，总有一天您会用上的。

## 5.2.自定义函数

库函数是标准规定需要实现的函数，依靠编译器厂家来实现功能，那么我们可不可以和编译器厂家一样，编写属于自己的函数呢？这是允许的，但是需要支持一定的规则。

### 5.2.1.函数结构

一个函数应该由函数返回值、函数名、函数参数构成函数签名。

### 5.2.2.函数分类

根据函数的实现者，可以分为：

-   库函数：已经写好内部代码的函数，直接使用即可，例如`printf()`

-   自定义函数：自己写的一个自定义的函数，例如`Add()`

根据函数是否有返回值（有无`return`语句），可以分为：

-   无需返回的函数（无返回值的函数）

    ```cpp
    void MyPrint(int number)
    {
    	printf("[%d]", number);
    }
    ```

-   需要返回的函数（有返回值的函数）

    ```cpp
    int Add(int x, int y)
    {
        int z = x + y;
        return z;//返回 z
    }
    ```

### 5.2.3.函数作用

之所以会有函数的存在，其中的几个目的是为了减少代码量、更加清晰地识别代码。

一个设计好的函数，我们要做某些事情的时候，只需用这个函数就行，而不必每次都去重复写这个函数里面的内容。

>   类比：就好像，你要吃薯片，虽然可以自己做薯片，但是你可以直接买商店的包装薯片，而不必每次都自己去做。而函数就可以类比那些帮你包装好薯片的加工厂。

# 7.数组

有时候我们需要大量相同数据类型的变量，这个时候就可以使用数组同时存放一组相同类型的变量。

```cpp
元素类型 数组名[元素个数] = {元素列表};
int arr_1[3] = {0};//数组的初始化，和 int a = 0 这种单个变量初始化是类似的，不过数组的初始化 0 会让数组内每一个元素都初始化为 0
int arr_2[4]={ 1, 2, 3 };//不完全初始化，数组内只有部分元素被初始化了，还有的元素没有被初始化，内部可能存储的是一个随机值
char arr_3[] = "bit";//利用数组存放字符串，内部有四个元素，分别是 'b'、'i'、't'、'\0'
```

数组的存在可以让您不用一个一个的定义多个变量，减少重复的工作量。

那如何取出数组里单个的变量/元素呢？`C`使用“数组的下标/索引”来获取数组内的元素，下标从`0`开始，可以用下标访问一个元素。

```cpp
#include <stdio.h>
int main()
{
	int arr[3] = { 5,4,3 };
	printf("%d\n", arr[1]);//输出4
	
	//因此可以利用循环来输出arr的所有元素
	int i = 0;
	while (i < 3)
	{
		printf("%d ", arr[i]);//依次输出 5 4 3
		i++;
	}
	return 0;
}
```

# 8.操作符

`C`语言很灵活，操作符有很多，操作符需要多少个量进行运算，就说该操作符有多少个操作数，例如：`+`操作符需要两个操作数才可以进行加法运算，因此也叫三目运算符。

由于我们第一次接触操作符，因此我们来细细讲解一些操作符的细节。

## 8.1.算术操作符

-   `+`：对两个操作数做加法
-   `-`：对两个操作数做减法
-   `*`：对两个操作数做乘法，需要注意的是，乘法没有办法像数学一样缩写，`3*x`不能写成`3x`，也不能写成`3·5`
-   `/`：对两个操作数做除法
-   `%`：对两个操作数做取模，且操作数必须都是整数，该操作符可以得到两个操作数相除。如果是负数，结果以第一个操作数的符号

## 8.2.移位操作符

-   `<<`：对一个整数的二进制做逻辑左移，末尾直接补零即可
-   `>>`：对一个整数的二进制做逻辑右移，开头一般补符号位
-   `&`：按位与
-   `^`：按位异或
-   `|`：按位或
-   `~`：对一个操作数的存储结果二进制序列全部位取反

## 8.3.赋值操作符

-   `=`：这个操作符我们之前就被用过了，不过这里强调一个点，”初始化（`int a=0`）和赋值（`a=20`）是两个概念“，至于区别是什么我们以后详细深入

-   `+=`、`-=`、`*=`、`/=`

-   `&=`、`^=`、`|=`

-   `<<=`、`<<=`

## 8.4.符号操作符

`+`、`-`，这两个操作符不是加法和减法，而是正负数的前缀符号，用来标明操作数的正负性。

## 8.5.关系操作符

`==`、`>=`、`<=`、`!=`

## 8.6.逻辑操作符

首先我们需要知道`C`语言对真和假的理解：视一切非零值为真（包括负数）。

-   `&&`：对于`子表达式1 && 子表达式2`中，只有两个子表达式同时为真，整个表达式才为真，否则为假
-   `||`：对于子`表达式1 || 子表达式2`中，只要两个子表达式中有一个为真，整个表达式就为真，否则为假
-   `!`：对于`!子表达式`，若子表达式为真，则整个表达式就为假，否则整个表达式为真

另外还需要重点提及的是`&&`和`||`的短路特性，对于`&&`中，如果左边的子表达式为假，则无需执行左边的子表达式（因为根据第一个子表达式，已经足够判定整个表达式是假了）。同样。对于`||`也是如此，如果左表达式为真，则无需执行右边的子表达式（因为已经可以肯定整个表达式必为真了） 。

```cpp
#include <stdio.h>
int main()
{
    int i = 0;
    int j = 2;
    int z = 0;
    z = ((i++) && (j += 2));
    printf("%d\n", j);//输出 2
    return 0;
}
```

```cpp
#include <stdio.h>
int main()
{
    int i = 0;
    int j = 2;
    int z = 0;
    z = ((++i) && (j += 2));
    printf("%d\n", j);//输出 4
    return 0;
}
```

## 8.7.条件操作符

对于`exp1 ? exp2 : exp3`：

-   若是`exp1`为真，整个表达式的结果为`exp2`
-   若是`exp1`为假，整个表达式的结果为`exp3`

咦？这个操作符可以做到和`if`语句类似的效果，好像哪一个都可以呀？一般条件操作符只能写一些简单的条件判断，对于多个条件的判断（尤其是带有嵌套的`if`语句），使用`if`语句可读性更好，代码书写的顾虑较少。

```cpp
int main()
{
    int a = 0;
    int b = 0;
    
    scanf("%d", &a);//用户输入，给 a 赋值
    
    if(a > b)
        b = 3;
    else
        b = -3;
    
    printf("%d\n", b);
    return 0;
}
```

上面的条件判断就可以改写为下面的条件操作符，可以看到代码确实简洁了许多。

```cpp
int main()
{
    int a = 0;
    int b = 0;
    
    scanf("%d", &a);//用户输入，给 a 赋值
    
    b = (a > b ? 3 : -3);    
    
    printf("%d\n", b);
    return 0;
}   
```

## 8.8.逗号操作符

对于`(exp_1, exp_2, exp_3, exp_4, exp_5, exp_6, …, exp_n)`从左往右算，则最后一个表达式`exp_n`的值为整个式子的值。

```cpp
//使用逗号操作符
int main()
{
    int a = 1, b = 1, c = 1;
    int x = (a + 1, b + 2, c + 2);
    printf("%d\n", x);
    return 0;
}
```

## 8.9.地址操作符

`&`可以对一个变量进行取地址，我们下面讲解指针的时候会使用这个操作符，这里先跳过，简单了解一下就行。

## 8.10.结构操作符

下标引用`[]`、使用结构成员的`.`和`->`。

## 8.11.自增操作符

`--`、`++`

>   补充：有种说法是认为前置`++`要比后置`++`要高效，实际上这在`C`语言的`++`操作符和`C++`的内置类型`++`操作符中体现不出来，但是在`C++`的自定义类型中重载后`++`的的确存在这种区别，不过这就涉及到`C++`语言的使用了，我们就不提及，只是做简单的解释。

## 8.12.其他操作符

-   `sizeof`应该是属于运算符，而不是函数，因为其本身不会真的进行某些计算
-   `()`这个括号操作符和某个函数名结合使用，变成函数调用，但是实际上大家常常忽略这个操作符，因为知道和不知道没什么太大区别

>   左右只要有一个数是浮点数，就会执行浮点数运算（还有输出格式要写成%f）。另外，如果两端都是整数，那么运行结果也只会是整数，哪怕用%f输出也是一样的。
>
>   直接写18<=a<=30语法没问题，都是写法是错误的应该写成a>=18&&a<=30，不然是报错的
>
>   实际上()经常被人忽略，它又叫函数调用操作符。最大的用处就是标识一个函数
>
>   []主要的作用就是利用数组的下标来访问数组的各个元素，Add(a,b)中，()的操作对象是Add、a、b
>
>   .和->是属于结构体知识的，后期会讲
>
>   单目操作符、双目操作符、三目操作符的区别

注意C语言的代码和数学写法的区别**

（1）等号

数学里的等于是“=”，C语言的等于是“==”

（2）大于（小于）等于号

数学里“1≤x≤2”，但在C语言里面要写成“(x>=1)&&(x<=2)”

（3）乘法

数学里面“3x”表示“3*x”，但是在C语言里面就必须写成“3*x”，不能只写“3x”（编译器会报错的）

![image-20231128084604723](./assets/image-20231128084604723.png)

# 9.关键字

我们之前提到的数据类型关键字，是`C`语⾔中关键字的一类。而之前提到的条件、循环，也需要关键字`if`、`while`、`do...while`、`for`来构成逻辑语句。

实际上，大多数的编程语言都会有一批保留名字的符号，这些名字不能交给用户去定义变量名和函数名，具有特殊的含义和语法使用规则。这些名字就被被称为“关键字”，或者说“保留字”、“关键词”。

常见的关键字有：

```cpp
break、case 、char、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static struct、switch、typedf、union、unsigned、void、volatile、while
```

这些关键字您可以自己稍微拓展学习一下，在以后的学习中我还会提及，您也需要熟记这些关键字（实际上敲多了就记住了，本人英语很烂，也是靠不断的敲击记忆的...）。

>   补充：这里我也给您留了一份[关键字的相关文档](https://zh.cppreference.com/w/c/keyword)。

下面我简单介绍几个比较容易理解的关键字，让您能快速理解并且使用。

## 9.1.typedef

假设有个人的名字全称是“欧阳李四”，而他村里的人却叫他小名“狗蛋”。这就相当于起了一个“别名”，故`typedef`的作用就像是给一些类型起了个“别名”。（叫“狗蛋”是为了方便，而您使用`typedef`也是为了方便）

```cpp
unsigned int num_1 = 100;
typedef unsigned int num uint;
unit num_2 = 10;//num_1 和 num_2 是同一种类型的
```

## 9.2.static

（1）从C语言的角度来说，内存的分布可以暂时简化为

栈区：局部变量、形式参数

堆区：动态内存分配（像maiioc、calloc、realloc free等动态内存分配函数就是在这个地方被使用）

静态区：静态变量、全局变量（静态区里的东西，整个程序结束才会销毁）

（2）static（静态）的作用

①修饰局部变量

void test()

{

  int a=1;

  a++;

  printf(""%d",a);

}

int main()

{

  int i=0;

  while(i<10)

   {

​     test();

​     i++;

  }

   return 0;

}//这打印了10个2，也就是2 2 2 2 2 2 2 2 2 2

void test()

{

  static int a=1;//增加了static

  a++;

  printf(""%d",a);

}

int main()

{

  int i=0;

  while(i<10)

  {

​    test();

​    i++;

  }

  return 0;

}//这就打印了2 3 4 5 6 7 8 9 10 11，说明上面的a的值没有被销毁，仍然保留着上一次a的值

加了static就相当于：你在做数学试卷，被老师叫去谈话，当你回来的时候，继续往下做题，没有必要重新从第一题开始。

不加static就相当于：你在做数学试卷，被老师叫去谈话，当你回来的时候，又从头开始做题了。

注意：一个局部变量本来放在栈区，加了static修饰的局部变量，就会放在静态区了，存储位置发生变化，导致局部变量出了作用域不会被销毁，改变了变量的使用周期（即存储位置发生了变化）。

注意：被static修饰后，这个a后面就不会重新创建为a=1了（但是a的值是可以再被改变的，只是每次都不会被重新创建a，静态和常量不是一个概念！！！）。

注意：静态变量和全局变量还是有很大区别的！静态变量只会在被修饰的局部变量里面值不变，而全局变量整个程序都是适用的。

②修饰全局变量

使得全局变量只能在本源文件里面使用，同时能让其他源文件里，另外一个被extern修饰的全局变量跨文件作用失效。（让全局变量的外部链接属性消失了）。其实这样的话就有对这个变量进行隐藏的功能（不会被别人看到，有保密效果）

//源文件1

extern int a；

printf("%d",a);//打印不出a的值

//源文件2

static int a=10；//则只能在本源文件里使用

③修饰函数

//在main_1.c中

int Add(int x,int y)

{

  return (x+y);

}

//在main_2.c中

extern int Add(int x,int y);//没有extern的时候，有的编译器是不会去调用别的头文件里面定义的函数的

int main()

{

  int a=10,b=20,sum;

  sum=Add(a,b);

  printf("%d\n",sum);

  return 0;

}

实际上在C++里面static还有两种用法，所以实际上是有两种用法

## 9.3.extern

可以跨`.c`文件使用一个被`extern`修饰的变量

```cpp
extern int num=1;
```

另外函数也有类似的使用方法

```cpp
int Add(int x,int y)
{
    return x+y;
}
```

```cpp
exterp int Add(int,int)//这里是函数的声明，只需要告知函数的参数是什么即可
{
    int a=10,b=20;
    int sum=Add(a,b);
    printf("%d\n",sum);
    return 0;
}
```

与`static`的同时出现时，会让`extern`的作用会消失

# 10.宏

关于宏的使用，我们在前面有简单提及过，我们这里来详细讲解一下

## 10.1.宏常量

```cpp
#include <stdio.h>
#define M 100
#define STR "hello bit"

int main()
{
    printf("%d\n",M);
    printf("%s\n",STR);
    return 0;
}
//就会分别输出100和hello bit
```

## 10.2.宏体

```cpp
#define MAX(x, y) (x > y ? x : y)//包括宏参（宏参是没有类型的），宏内容。
//宏与函数是有去区别的
int main()
{
    int a=10, b=20;
    int m = MAX(a, b);
    printf("%d\n", m);
    return 0;
}
```

# 11.指针

在学习指针之前，首先要理解一点关于内存的基本概念概念。

## 11.1.内存是什么

内存是电脑上特别重要的存储器，计算机中的程序运行后都是在内存中运行的，内存在哪里呢？就在内存条中，这也就是为什么有些人会追求`16G`、`32G`甚至更大内存的电脑，内存越大，同时运行的程序也就会越多，程序可以使用的资源空间而就越多，电脑整体来看也就越快。

而内存条内的内存空间，可以被分割成一个个“小内存”，这个“小内存”可以用一个小格子表示，每个小格子有一个对应的编号，计算机就可以依靠这些编号来快速找到这个小格子。

而这个编号就是地址，这个小格子就叫内存单元，内存单元一般可以存放一个字节的数据（刚好放一个`char`类型的数据，大小是`8`比特，或者叫”八位组“）。

## 11.2.编址如何编

`32`位电脑实际就是指有`32`根地址线（相当于电线），电线是可以被通电的，有高电平，低电平，转化为数字信号就是`1`或者`0`，`32`个二进制位就可以产生$2^{32}$个编号，也就能够产生$2^{32}$个地址（管理$2^{32}$字节的空间，其实也就`4G`大小的空间）。因此，一般`32`位电脑使用`4G`大小的内存就足够使用了。

>   注意：`64`位也可以类似理解。

## 11.3.代码怎么写

此时我们就可以更深刻理解`int a = 10`的含义：向内存申请`4`个字节的空间，存储`10`这个值（具体怎么存放我们以后讲）。

这里放个图把...

`a`实际上是占用`4`个字节的空间，但是每个字节都有地址，因此`&a`取的地址，其实是第一个字节的地址（也就是最小的地址）

而`int *pa = &a`中，把`a`的地址存放到变量`pa`中，`pa`就是一个存放地址的变量，它的类型是int*，我们把`pa`叫做一个”指针变量“，也叫”指针“。

## 11.4.指针怎么用

注意：*在表明pa是指针变量，int是在说明pa指向的对象是int类型。

注意：通过地址可以找到变量的值，甚至改变变量的值

注意：定义指针时，*跟在类型还是跟在变量上都可以

注意：%p是用来专门打印地址的，如果

（5）当然指针变量本身也是一个变量

（6）那么指针变量本身的大小是多少个字节呢？

指针变量是存放地址的，地址是：

①32位机器上：32个0/1组成的2进制序列，需要32位bit位的空间存储，指针变量就需要4个字节

②64位机器上：64个0/1组成的2进制序列，需要64位bit位的空间存储，指针变量就需要8个字节（编译器可以换位数）

int main()

{

​    char* p1;

  int* p2;

   double *p3;

   printf("%zd\n",sizeof(p1));//zd是

   printf("%zd\n",sizeof(p2));

   printf("%zd\n",sizeof(p3));

}//在x86（32位机器）结果都是4，而64位机器都是8

注意：故不要被*前面的类型影响判断

注意：编译器如果报警告就可以将%d改成%zd

# 12.结构体

结构体是为了描述更多的复杂变量而诞生的，有些变量仅仅靠单个的`char`、`int`、`float`…来描述是不够的，这个时候就需要结构体的存在了。

`struct`是创建结构体的重要关键字，结构的存在使得描述一个变量时，可以使用多个数据类型来综合描述，内部每一个成员就是结构体成员。

```cpp
struct Student
{
    char name[20];//名字
    int age;//年龄
    char id[15];//学号
    float score;//成绩
};
```

结构体成员可以利用`.`或者`->`来访问，两者用法是有区别的

struct Student

{

  char name[20];//名字

   int age;//年龄

   char id[15];//学号

   float score;//成绩

};

int main()

{

  struct Student s1={"张三",20,"2022010823",88.5f};

  struct Student s2={“翠花”,18,"2022030405",98.0f};

  printf("%s %d %s %f",s1.name,s1.age,s1.id,s1.score);

  struct Student *ps1=&s1;

   printf("%s %d %s",(*ps1).name,(*ps1).age,(*ps1).id,(*ps1).score);

   printf("%s %d %s %f",ps1->name,ps1->age,ps1->id,ps1->score);

}

# 13.语句




# 14.编码素养

## 14.1.编码风格

编写`C`的代码过程中，有很多的代码风格值得我们学习，我这里只总结了一些常见的代码风格，更多的代码风格我在段尾给出了相关的链接。

>   补充：编码风格相关链接

## 14.2.编码自救

我们在编写代码中，难免会出现错误，我们首先需要做到以下几点：

1.   不畏惧编译器的错误提示（包括警告）

2.   编译器给出的提示不仅仅是错误提示，还包含警告提示，不要忽略后者

3.   拥有一定的搜索检索能力，不要用`baidu`（乐色堆），推荐使用`bing`，也提倡使用多个平台的内置收索，小红书也好、`CSDN`也好、博客园也好，甚至您有办法的话，使用`google`、`chat GPT`也是可以的，总之，站到更远的互联网，不要拘泥于国内互联网

4.   有些时候，编译器也会“犯迷糊”，您写的代码在编译器看来可能暂时没有错误，但这不代表以后没有错误（有可能含有隐藏的`bug`，但这不会导致运行出错）

     这是新手常会误会的错误，认为只要有好的编译器，并且代码能运行就说明正确。但实际上，写代码时我们要尽可能足够严谨，否则就会出现意想不到的错误

只有您知道和遵循上述几点，才能得到快速的进步和`debug`的能力。

# 15.代码练习

下面我给出一些代码练习（附带答案），以及一些相关的题目链接，方便您进行代码练习。
