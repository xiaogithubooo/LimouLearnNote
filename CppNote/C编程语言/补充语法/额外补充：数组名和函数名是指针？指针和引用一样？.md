在`2023/8/26`日晚上，我看到一个所谓“典”的视频，一开始还没太在意，后面想了想发现我貌似也一直犯了以下的错误，而错误的原因在于我在新手阶段学习`C/C++`并不是查阅文档扎好脚步学习的，而被在铺天盖地的新手学习基础教程里学习的，导致一些对语言的误解越来越深。

# 1.数组名和函数名是指针？

原视频在`b`站：[数组名是指针？典](https://www.bilibili.com/video/BV1jY4y1o7Dg?vd_source=4772b64d7a3cb1873f14bc0153c4de68)。

以下是我的个人理解：

1. 数组名就是数组的名，不是指针，具有数组类型，因此取地址得到整数组地址，`sizeof(数组名)`就是得到整个数组大小

2. 在使用数组名的时候（例如`arr+1`）会发生隐式转化，转化后的类型的确为指针

3. 函数名也确实是函数名，不是指针，关联一个函数类型，因此取地址得到函数地址，`sizeof()`没有办法求出（因为`sizeof()`在编译时确定，而函数栈帧在运行时确定，此时才会给函数分配空间，没有办法给出具体的大小）

4. 在使用函数名的时候（例如`f+1`）会发生隐式类型转化，转化后的类型的确为指针

<img src="./assets\545c9735-e3e8-4b36-b6b0-efff5e63c7bf.jpg" title="" alt="545c9735-e3e8-4b36-b6b0-efff5e63c7bf" style="zoom:50%;">

# 2.指针和引用底层一样？

有一种说法就是：在汇编层面指针和引用是一样，但是这种说法已经脱离了`C/C++`语言本身，我在视频的下方有看到一条评论是这样的，我也认为这说得确实比较恰当：

> 古明地现：“不管存储的数据是什么数据类型，`int`也好，`char`也罢，到最后都会变成内存中具体的值，也就是说，高级语言编译后会丢失原有的很多信息。所以仅仅通过分析产们生成的汇编码来判断高级语言中它们的意义是否相同，这样的做法是十分不妥当的。比如`unsigned int a = 40;short b = 40;`过汇编后内存地址内的数据都是一样的，汇编指令也是一样的。但是这不能证明高级语言层面的`a`和`b`完全等价，更不能训明`short`和`unsined int`是同一种数据类型，简简单单看看汇编码就说某些东西一样的人，只能说他们想的太简单了。”
