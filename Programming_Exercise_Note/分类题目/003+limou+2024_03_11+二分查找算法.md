# 1.原理

二分查找最恶心的地方在于越界和死循环，并且很难查找 `bug`，但是还请您继续看下去。

一般我们学到的二分查找算法是基于序列有序的情况下才能使用，但是实际上并不是这样的，这只是一种狭义的理解。

## 1.1.朴素二分查找

最朴素的二分查找我相信有很多人都知道，这里给一道 [704. 二分查找](https://leetcode.cn/problems/binary-search/) 给您做一做。

更加朴素、直接、暴力的查找方法就是顺序查找，顺序查找之所以低效的原因是它无法得知哪些数据需要被丢弃，只能把数据一个一个访问。

而由于序列本身是有顺序的（假设升序），因此如果直接从中间开始访问，和目标值比较大小，一次比较就可以舍弃大致一半的数据，这样折半下去就是一种指数爆炸，第一次查找比较的时候，就能少做一半的数据。

```cpp
class Solution 
{
public:
    int search(std::vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)
        {
            int middle = left + (right - left) / 2; //在除以 2 的时候也可以是 left + (right - left + 1) / 2，这两种写法某一次查找时，数据量为奇数时是没有差别的。但是数据量为偶数时，中间数有两个，两种写法分别对应前后两个中间数，在朴素二分法种，选择哪一个都是可以的
            
            if (nums[middle] < target)
            {
                left = middle + 1;
            }
            else if (nums[middle] > target)
            {
                right = middle - 1;
            }
            else
            {
                return middle;
            }
        }
        return -1;
    }
};
```

那时间复杂度怎么计算呢？寻找 $1$ 次就有 $n/2$ 的数据被丢弃，$2$ 次就有 $\frac{\frac{n}{2}}{2}$，最坏情况到 `x` 次剩 $\frac{n}{2^x}=1$ 个数据，也就是 $x=log_{2}{(n)}$，时间复制度就是 $O(log_{2}{(n)})$

而实际上，有顺序只是一种条件，如果我们能保证舍弃另外一半的数据也不影响我们查找，就可以得到广义的二分查找法。

我把能这样二分操作，但是不影响查找的性质，用 `二段性` 这个词来描述。也就是说：具有二段性的序列，可以使用二分查找算法，并且可以和大小顺序无关。这样抽象出来的二分查找算法才是我们下面要学的真正意义上的二分查找算法。

而进一步，如果二分无法舍弃一部分数据，可以三分、四分...

```cpp
class Solution 
{
public:
    int search(std::vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)
        {
            int middle = left + (right - left) / 3; //可以改成其他整数，而 2 是最高效的（大量数据的情况）
            
            if (nums[middle] < target)
            {
                left = middle + 1;
            }
            else if (nums[middle] > target)
            {
                right = middle - 1;
            }
            else
            {
                return middle;
            }
        }
        return -1;
    }
};
```

只要保证不断循环的分割中，总能舍弃一部分数据，就可以抽象出多分查找法。

但是大部分的多分查找都是二分查找，这其实也可以说是数学中概率学（数学期望）的知识。 

## 1.2.左边界二分查找

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)，这道题目有个比较骚气的方法，就是先确定和 `target` 相等的索引位置，然后向前和向后查找同样相同的数据，最后返回该数据范围的起始和末尾位置即可.

## 1.3.右边界二分查找

# 2.题目

