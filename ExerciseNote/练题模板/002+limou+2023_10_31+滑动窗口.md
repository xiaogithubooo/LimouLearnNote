# 1.原理

我们用这道题目[LCR 008. 长度最小的子数组](https://leetcode.cn/problems/2VG8Kg/)来讲解“滑动窗口”的解法。

## 1.1.暴力$O(n^{3})$

遍历每一个子数组（都要大于等于`7`），最统计出最小的数组。

这样做的话，划分左右区间（`left`和`right`）就需要$O(n^{2})$，然后每一个区间都要求和，所有求和又需要$O(n)$，整体时间复杂度就是$O(n^{3})$。

## 1.2.优化$O(n^{2})$

如何将上述解法优化呢？首先在求和上就可以优化到$O(n)$。

划分区间从`[left,left=right]`开始，先让`sum+arr[right]`，然后再`right++`，这样子就不需要重复计算`sum`了，这样就可以优化为$O(n^{2})$。

## 1.3.优化$O(n)$

全部都是正整数，也就是，加的数越多，得到的结果`sum`就越大（也就是具有单调性），因此当我们划分区间`[left,right]`后得到的`sum`只要比`target`大或等于就无需再`right++`了，继续让其加加得到的数组肯定会比`target`大，但是数组长度也变大了，这是我们不需要的。

上述划分结束后，我们就得到了一个`[left,right]`窗口区间和对应的`sum`，其中`[left,right-1]`的`sum`一定小于`[left,right]`的`sum`或者说`target`。

后面让这个窗口区间挪动起来，找比这个区间长度要小，但是窗口的`sum`大于等于`target`的，并且实时更新`maxLength`。

直接让`sum-arr[left]`，然后`left++`即可得到`[left,right]`区间的新`sum`。

查看这个`sum`是否大于`target`，如果是继续加加，如果不是就整个窗口移动，直到`right`到结尾。

而这种`left`和`right`双指针同向移动的情况就称为“滑动窗口”。

```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int sum = 0;
        int maxLength = 0;

        int left = 0;
        int right = 0;

        while (right < nums.size())
        {
            sum += nums[right];
            if (sum >= target)
            {
                break;
            }
            right++;
        }
        maxLength = right - left + 1;
        //得到窗口[left, right]
        
        if(sum < target)
        {
            return 0;
        }

        while(right < nums.size())
        {
            sum -= nums[left];
            left++;
            if (sum >= target)
            {
                maxLength = right - left + 1;
            }
            else//sum < target
            {
                right++;
                if (right >= nums.size())
                {
                    break;
                }
                sum += nums[right];
            }
        }
        return maxLength;
    }
};
```

或者写得更加高明一些：

```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int n = nums.size();
        int sum = 0;
        int len = INT_MAX;

        for(int left = 0, right = 0; right < n; right++)
        {
            sum += nums[right];
            while(sum >= target)
            {
                len = min(len, right - left + 1);
                sum -= nums[left++];
            }
        }
        return len == INT_MAX ? 0 : len;
    }
};
```

>   时间复杂度：由于只操作两个指针，最坏情况下操作$n+n$次，也就是$O(n)$

# 2.题目
