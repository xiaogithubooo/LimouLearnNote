# 1.原理

我们用这道题目[LCR 008. 长度最小的子数组](https://leetcode.cn/problems/2VG8Kg/)来讲解“滑动窗口”的解法。

## 1.1.暴力$O(n^{3})$

遍历每一个子数组（都要大于等于`7`），最统计出最小的数组。

这样做的话，划分左右区间（`left`和`right`）就需要$O(n^{2})$，然后每一个区间都要求和，所有求和又需要$O(n)$，整体时间复杂度就是$O(n^{3})$。

## 1.2.优化$O(n^{2})$

如何将上述解法优化呢？首先在求和上就可以优化到$O(n)$。

划分区间从`[left,left=right]`开始，先让`sum+arr[right]`，然后再`right++`，这样子就不需要重复计算`sum`了，这样就可以优化为$O(n^{2})$。

## 1.3.优化$O(n)$

全部都是正整数，也就是，加的数越多，得到的结果`sum`就越大（也就是具有单调性），因此当我们划分区间`[left,right]`后得到的`sum`只要比`target`大或等于就无需再`right++`了，继续让其加加得到的数组肯定会比`target`大，但是数组长度也变大了，这是我们不需要的。

上述划分结束后，我们就得到了一个`[left,right]`窗口区间和对应的`sum`，其中`[left,right-1]`的`sum`一定小于`[left,right]`的`sum`或者说`target`。

后面让这个窗口区间挪动起来，找比这个区间长度要小，但是窗口的`sum`大于等于`target`的，并且实时更新`maxLength`。

直接让`sum-arr[left]`，然后`left++`即可得到`[left,right]`区间的新`sum`。

查看这个`sum`是否大于`target`，如果是继续加加，如果不是就整个窗口移动，直到`right`到结尾。

而这种`left`和`right`双指针同向移动的情况就称为“滑动窗口”。

```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int sum = 0;
        int maxLength = 0;

        int left = 0;
        int right = 0;

        while (right < nums.size())
        {
            sum += nums[right];
            if (sum >= target)
            {
                break;
            }
            right++;
        }
        maxLength = right - left + 1;
        //得到窗口[left, right]
        
        if(sum < target)
        {
            return 0;
        }

        while(right < nums.size())
        {
            sum -= nums[left];
            left++;
            if (sum >= target)
            {
                maxLength = right - left + 1;
            }
            else//sum < target
            {
                right++;
                if (right >= nums.size())
                {
                    break;
                }
                sum += nums[right];
            }
        }
        return maxLength;
    }
};
```

或者写得更加高明一些：

```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int n = nums.size();
        int sum = 0;
        int len = INT_MAX;

        for(int left = 0, right = 0; right < n; right++)
        {
            sum += nums[right];
            while(sum >= target)
            {
                len = min(len, right - left + 1);
                sum -= nums[left++];
            }
        }
        return len == INT_MAX ? 0 : len;
    }
};
```

>   时间复杂度：由于只操作两个指针，最坏情况下操作$n+n$次，也就是$O(n)$

因此可以看出，滑动窗口的题目基本都是：

1.   设定窗口范围
2.   让数据进窗口
3.   判断是否符合要求，不符合则让数据出窗口

# 2.题目

## 2.1.[LCR 016. 无重复字符的最长子串](https://leetcode.cn/problems/wtcaE1/)

### 2.1.1暴力

<img src="./assets/image-20231102185735050.png" alt="image-20231102185735050" style="zoom:80%;" />

>   时间复杂度：$O(n^{2})$

### 2.1.2.优化

![image-20231102190332558](./assets/image-20231102190332558.png)

```cpp
class Solution
{
public:
    int lengthOfLongestSubstring(string str)
    {
        int left = 0;
        int right = 0;
        int maxSize = 0;
        int hash[128] = { 0 };

        while (left < str.size())
        {
            while (right < str.size() && hash[str[right]] == 0)//不是重复的字符就放入哈希表之中
            {
                hash[str[right++]]++;
            }
            //走到这里说明出现了重复的字符，这个重复元素就是str[right]
            maxSize = maxSize > right - left ? maxSize : right - left;//记录最大长度
            while (str[left] != str[right])//让left直接跳到在和str[right]重复的元素后面
            {
                hash[str[left]]--;
                left++;
            }
            hash[str[left]]--;
            left++;//走到这里还要在加加一次
        }

        return maxSize;
    }
};
```

还可以写得更加简洁：

```cpp
class Solution
{
public:
    int lengthOfLongestSubstring(string str)
    {
        int left = 0, right = 0, maxSize = 0, n = str.size(), hash[128] = { 0 };

        while (right < n)
        {
            hash[str[right]]++;//进窗口
            while (hash[str[right]] > 1)//判断
                hash[str[left++]]--;//出窗口

            maxSize = max(maxSize, right - left + 1);//记录最大长度
            right++;
        }

        return maxSize;
    }
};
```

>   时间复杂度：$O(n)$

## 2.2.[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

如果转变思路为：一个区间内包含的`0`的个数不超过`K`，求这样的区间的最大值。

![image-20231104133959236](./assets/image-20231104133959236.png)

```cpp
class Solution
{
public:
    int longestOnes(vector<int> nums, int K)
    {
        int left = 0, right = 0;
        int zero = 0;
        int maxSize = 0;
        int n = nums.size();
        
        while (right < n)
        {
            if (nums[right] == 0) zero++;

            while (zero > K)
            {
                if (nums[left] == 0) zero--;
                left++;
            }

            right++;
            maxSize = max(maxSize, right - left);
        }
        return maxSize;
    }
};
```

## 2.3.[1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

这道题目正面做比较困难，可以反面做。

![image-20231120164121343](./assets/image-20231120164121343.png)

```cpp
class Solution
{
public:
    int minOperations(vector<int> nums, int x)
    {
        //1.设置 target
        int sum = 0;//整个数组求和
        for (auto e : nums) sum += e;
        int target = sum - x;//求出 target

        //2.处理特殊情况
        if (target < 0)//target 不可能小于 0
            return -1;

        //3.下面开始找到中间区间和为 target 即可
        int left = 0;
        int right = 0;
        int ret = -1;//这里之所以设置为 -1 是因为有可能出现找不到的情况（例如：左右端的数字均大于 target）
        int add = 0;

        while (right < nums.size())
        {
            //1.进窗口
            add += nums[right];

            //2.判断出窗口
            while (add > target)
            {
                add -= nums[left];
                left++;
            }

            //3.更新结果
            if (add == target)
            {
                ret = (int)max(ret, right - left + 1);
            }

            right++;
        }

        if (ret < 0)
            return ret;
        return nums.size() - ret;
    }
};
```

## 2.4.[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

依旧是使用滑动窗口，这个题比较简单。

```cpp
class Solution
{
public:
    int totalFruit(vector<int>& fruits)
    {
        int left = 0, right = 0;
        unordered_map<int, int> um;
        int count = 0;

        while (right < fruits.size())
        {
            //1.进窗口
            um[fruits[right++]]++;

            //2.出窗口
            while (um.size() > 2)
            {
                um[fruits[left]]--;
                if (um[fruits[left]] == 0)
                    um.erase(fruits[left]);
                left++;
            }

            //3.更新
            if (um.size() == 2)
            {
                count = max(count, right - left);
            }
        }

        if (left == 0)
        {
            count = fruits.size();
        }

        return count;
    }
};
```

或者修改一下，简化代码：

```cpp
class Solution
{
public:
    int totalFruit(vector<int>& fruits)
    {
        int left = 0, right = 0;
        unordered_map<int, int> um;
        int count = 0;

        while (right < fruits.size())
        {
            //1.进窗口
            um[fruits[right++]]++;

            //2.出窗口
            while (um.size() > 2)
            {
                um[fruits[left]]--;
                if (um[fruits[left]] == 0)
                {
                    um.erase(fruits[left]);
                }
                left++;
            }

            //3.更新
            count = max(count, right - left);
        }

        return count;
    }
};
```

但是这里的哈希删除效率比较低下，实际上我们可以根据题目特点（`0 <= fruits[i] < fruits.length`）来创建一个自己的哈希表，而不使用库内的哈希表，这也是一种做题技巧。

```cpp
class Solution
{
public:
    int totalFruit(vector<int>& fruits)
    {
        int left = 0, right = 0;
        int um[100001] = { 0 };
        int count = 0;
        int kinds = 0;

        while (right < fruits.size())
        {
            //1.进窗口
            if(um[fruits[right]] == 0)
                kinds++;
            um[fruits[right++]]++;

            //2.出窗口
            while (kinds > 2)
            {
                um[fruits[left]]--;
                if(um[fruits[left]] == 0)
                    kinds--;
                left++;
            }

            //3.更新
            count = max(count, right - left);
        }

        return count;
    }
};
```

