# 1.双指针

双指针是一种解题常用方法，常用于将数组按照某种要求进行分块/划分，这里的指针对于数组来说，可以替换成下标（毕竟使用下标实际上就是用了指针）。

## 1.1.划分区间

通常将这两个指针命名位`dest/cur`（或者`begin/end`），利用这两个指针将区间划分为三个不同性质的区间`[0, dest-1][dest, cur-1][cur, n-1]`，在`cur`移动的时候，保持三个区间的性质不变。

实际上这也是快速排序中的前后指针、三路划分中使用的原理。仔细回想一下，快速排序的算法逻辑中，实际上也是将下标`[left, right]`之间的数据划分为`[left, key-1][key, key][key+1, right]`，并且让这三个区间保持某种性质不变（在快排中是第一个区间比`key`小/大，最后一个区间比`key`大/小）。

具体可以看一下这一道[题目](##2.1.[力扣283. 移动零])。

## 1.2.覆盖重写

利用双指针可以达到覆盖数组的目的，这里可以看看这道[题目](##2.2.[力扣1089. 复写零])。

# 2.题目

## 2.1.[力扣283. 移动零](https://leetcode.cn/problems/move-zeroes/)

这道题目的解法有很多，这里我写一个常见的解法：使用`cur`扫描/遍历数组，使用`dest`来作为分界线，在划分成的`[0,dest-1][dest, cur-1][cur, n-1]`中，三个区间的性质是：`[0,dest-1]`是已经处理过确认非`0`的区间，`[dest, cur-1]`是确认为`0`的区间，`[cur, n-1]`是待处理的部分，然后接下来一直移动`cur`直至`[cur, n - 1]`为空，区间一直保持以上的性质。

```c++
class Solution
{
public:
    void moveZeroes(vector<int>& nums)
    {
        size_t dest = 0;   
        size_t cur = 0;     
        while(cur < nums.size())
        {
            if(nums[cur] != 0)
            {
                std::swap(nums[cur], nums[dest]);
                dest++;
            }
            cur++;
        }
    }
};
//时间复杂度为O(n)，因为只需要遍历一次即可解决问题
//空间复杂度为O(1)，因为不计输入数据，只用到了两个有限的变量
```

## 2.2.[力扣1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/)

首先最容易想到的就是使用另外一个`vector<int> ret`顺序表来存储复写后的数组，并且拷贝回`vector<int> arr`即可。

```c++
class Solution
{
public:
    void duplicateZeros(vector<int>& arr)
    {
        std::vector<int> ret;
        for(auto it : arr)
        {
            ret.push_back(it);
            if(it == 0)
            {
                ret.push_back(0);
            }
        }
        int i = 0;
        for(auto& it : arr)
        {
            it = ret[i]; 
            i++;
        }
    }
};
```

虽然可以过，但是忽略了“就地修改”这个规则，这又该怎么办呢？

我们可以定义一个`dest`指向数组的最后一个元素，`cur`指向复写操作后最后的一个元素，也就是说：对于`arr=[1,0,2,3,0,4,5,0]`经过复写操作后为`ret=[1,0,0,2,3,0,0,4]`。因此先假设`dest`下标指向`arr[5]=4`的位置，假设`cur`下标指向`arr[7]=0`的位置，然后从右往左判断覆盖即可。

但是怎么找到经过复写操作后的最后一个元素的下标呢？依旧可以使用双指针寻找，你么看错，就是双指针里面套双指针。

1. 我们假设`dest=-1, cur=0`然后让`cur`遍历整个数组，只要遇到`0`就让`dest+=2, cur++`，如果是遇到非`0`就让`dest+=1, cur++`。
2. 理解`dest`为记录了复写后数组的大小
3. 最后当`dest>arr.size()-1`的时候，停止下来，此时的`cur`一定指向复写操作后数组的最后一个元素
4. 然后执行之前说的操作即可



# 3.总结



