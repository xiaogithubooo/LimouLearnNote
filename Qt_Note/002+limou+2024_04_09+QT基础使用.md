>   前要：我推荐新手先难受会，使用 `Qt Creator` 来直接开发。

# 1.基本的 Qt 代码

## 1.1.创建项目

我们先来创建一个项目跑起来先，看看界面是什么样子的。

![image-20240409205016881](./assets/image-20240409205016881.png)

![image-20240409205315539](./assets/image-20240409205315539.png)

![image-20240409205338078](./assets/image-20240409205338078.png)

>   补充：元编程是指编写能够操作、生成或者改变其他程序或者自身的程序。简单来说，元编程是关于编写程序的程序，它可以自我修改或者生成新的代码，也可以在运行时动态地创建、修改和执行代码。



使用 `Qt Creator` 会自动生成一些代码，接下来选择一个父类来用于后续的继承。

-   `QMainWindows`：表示完整的窗口
-   `QWidget`：表示一个控件（窗口上的一个具体元素，例如输入框、按钮、下拉框、单选按钮、复选按钮）
-   `QDialog`：表示一个对话框

![image-20240409211651876](./assets/image-20240409211651876.png)

`Qt` 中创建图形化界面的程序, 有两种：

1.   `Qt` 创建 `C++` 代码的方式

2.   通过 `from file` 图形化的方式

选择基于不同版本编译器的 `Qt SDK` 来构建后续代码。

![image-20240409211852382](./assets/image-20240409211852382.png)

![image-20240409211913096](./assets/image-20240409211913096.png)

然后分别解释一下自动生成的几个文件。

```shell
MyTest:
│
├─QtTestempty
│       main.cpp
│       mywidget.cpp
│       mywidget.h
│       mywidget.ui
│       QtTestempty.pro
│       QtTestempty.pro.user
│
└─ build-QtTestempty-Desktop_Qt_5_14_0_MinGW_64_bit-Debug
        .qmake.stash
        main.o
        Makefile
        moc_mywidget.cpp
        moc_mywidget.o
        moc_predefs.h
        mywidget.o
        QtTestempty.exe
        ui_mywidget.h
```

上面很明显包含了 `C/C++` 式的文件，我们先看这几个。

```cpp
// main.cpp

#include "mywidget.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv); // 传递命令行参数给 QApplication 类
    MyWidget w; // 创建一个控件对象, 继承自 QWidget
    w.show(); // 显示控件对象, hide() 则可以将控件隐藏
    return a.exec(); // exec() 是 QCoreApplication 类成员方法, 可启动 Qt 的事件循环, 和 Linux 中的 exec 进程替换没有关系
}

```

```cpp
// mywidget.h

#ifndef MYWIDGET_H
#define MYWIDGET_H

#include <QWidget> // 使用 Qt 内置的类和头文件一致

QT_BEGIN_NAMESPACE
namespace Ui { class MyWidget; }
QT_END_NAMESPACE

class MyWidget : public QWidget
{
    Q_OBJECT // 这是 QT 内置的宏, 该宏展开后就会生成大量代码, 当类需要使用 Qt 的“信号”和“槽”机制的时候就要引入

public: // 下面两个类方法做了头文件、源文件分离的实现
    MyWidget(QWidget *parent = nullptr); // Qt 引入了对象树的概念, 创建 Qt 的对象, 就可以吧对象挂在对象树上(N叉树), 往上挂时需要指定父节点
    ~MyWidget();

private:
    Ui::MyWidget *ui; //和 form file 相关
};
#endif // MYWIDGET_H

```

```cpp
// mywidget.cpp

#include "mywidget.h"
#include "ui_mywidget.h" // from file 被 qmake 生成的头文件

MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MyWidget)
{
    ui->setupUi(this); //把 from file 生成的页面和当前的 widget 关联起来
}

MyWidget::~MyWidget()
{
    delete ui; //释放资源
}

```

还有一个关于 `qmake` 的配置文件。

```properties
# QtTestempty.pro 是 qmake 进行元编程时的重要依据, “qmake+QtTestempty.pro”类似 makefile 的使用(但是这个工具古老且经典)
# 经过一次运行后, 在和本项目同级目录下的 build-QtTestempty-Desktop_Qt_5_14_0_MinGW_64_bit-Debug 中, 实际上也可以看到 Makefile 的身影
# 而且还有一些相关的配置文件, 还有一个依据 mywidget.ui 生成的 ui_mywidget.h 头文件, 您可以打开一览简单看一看
QT       += core gui # 表示引入的 Qt 模块

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++11 # 编译选项(使用的 C++ 标志)

# The following define makes your compiler emit warnings if you use
# any Qt feature that has been marked deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

# 当前项目参与构建的文件, 不需要手动修改, Qt 会自动维护好
SOURCES += \
    main.cpp \
    mywidget.cpp

HEADERS += \
    mywidget.h

FORMS += \
    mywidget.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

```

另外，我们来查看 `mywidget.ui` 文件，这是一个 `XML` 的只读文件，主要是用来描述界面的样式，`qmake` 会根据这个文件进行元编程，生成对应 `C++` 代码，然后编译成一个界面。

想要修改 `XML` 文件，只能通过点击对应界面跳转的 `UI` 设计界面，通过鼠标操作和设计界面的方式来修改。

![image-20240410110935077](./assets/image-20240410110935077.png)

![image-20240410111450944](./assets/image-20240410111450944.png)

>   补充：`XML` 和 `HTML` 很是类似，用起来也像，但是两者的作用不太一样，`XML` 中的标签表示什么含义取决于程序员自定义（`HTML` 的由标准委员会使用相同的规则来规定）。

## 1.2.Hello World 代码的实现

### 1.2.1.使用 UI 界面来实现

![image-20240410120645717](./assets/image-20240410120645717.png)

对应元编程结果如下：

![image-20240410120813613](./assets/image-20240410120813613.png)

### 1.2.2.使用纯代码来实现

一般使用代码来构造界面的时候，会把构造界面的代码放到 `Widget/MainWindows` 的构造函数中。

```cpp
// mywidget.cpp

#include "mywidget.h"
#include "ui_mywidget.h" // from file 被 qmake 生成的头文件
#include <QLabel> //还有一个 QLabel 是较早的实现版本
#include <QString>

MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MyWidget)
{
    ui->setupUi(this); //把 from file 生成的页面和当前的 widget 关联起来
    QLabel* label = new QLabel(this); //Label 其实就是“标签”, 也就是界面上用来显示的字符串, 并且指定父对象
    label->setText(QString("Hello World!")); //C++ 早期的字符串有 C 式风格字符串和混乱的 std::string, 因此就有了自己的基础类来支持字符串(QString)、动态数组(QVector)、链表(QList)、字典(QMap)...因此就有可能有两种解决方案, 不过很多情况都使用 Qt 自己的
    label->setGeometry(QRect(230, 130, 91, 21)); //设定标签位置和标签形状
    //另外, 这里故意没有使用 delete label, 这是 Qt 的一个特点, 您在这里可以不调用 delete
    //因为前面的 QLabel* label = new QLabel(this); 把对象通过父对象挂到了对象树上, 对象树可以把界面上的各种元素组织起来
}

MyWidget::~MyWidget()
{
    delete ui; //释放资源
}

```

![1712724729748](./assets/1712724729748.jpg)

并且，无论是手动使用 `delete` 还是使用栈变量，都是不科学的，应当将 `Qt` 对象的生命周期交给对象树，否则就会出现对应资源不显示的问题。