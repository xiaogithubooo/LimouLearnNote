# 1.网络的基本概念



# 2.网络的第三方库

## 2.1.cpp-httplib

`cpp-httplib`（也称为 `httplib`）是一个基于 `C++` 的轻量级 `HTTP` 框架，它提供了简单易用的 `API`，用于创建 `HTTP` 服务器和客户端。本身简单易用，适用于快速搭建简单的 `HTTP` 服务器和客户端，因此本身可能不支持复杂的功能。

`httplib` 的安装也很简单，直接克隆库中的 `httplib.h` 到项目中即可（https://github.com/yhirose/cpp-httplib）。接口有点多，我先写出常用的接口声明和类声明（另外，该编译该库最好使用 `g++7.3`）。

### 2.1.1.协议接口

首先 `http` 报文内会包含：

-   首部：请求方法（`GET、POST`）、`URL(<protocol>://<username>:<password>@<host>:<port>/<path>?<params>#<fragment>)`、协议版本
-   报头：`key-value\r\n` 对
-   空行：`\r\n`
-   正文：请求的数据或者返回的数据

而 `http` 报文还会分为请求报文和响应报文，因此在 `httplib` 中存在以下两个类（只是作为归纳的两个简化的类，实际声明可能有很大的不同）。

```cpp
//Request 类
struct MultipartFormDataMap
{
    std::string name; //表单字段的名称, 用于标识表单数据
    std::string content; //文件内容
    std::string filename; //文件名称
    std::string content_type; //文件类型
};

struct Request
{
    //(1)请求行
    std::string method; //请求方法
    std::string path; //资源路径（不是所有的 URL, 通常是域名之后, 查询字符之前）
    Params params; //查询字符串
    std::string version; //协议版本
    
    //(2)请求头部
    Headers headers; //头部

    //(3)请求正文
    std::string body; //正文
    MultipartFormDataMap files; //保存客户端上传的文件信息
    Ranges ranges; //指定要获取资源范围, 会根据 Range 字段指定的范围来返回相应的资源内容, 一旦中断后重连, 就会从中断的位置继续下载文件, 而不需要重新下载整个文件
    
    bool has_header(const char *key) const;
   	//检查请求头部是否包含指定键名的头部字段, 参数 key 是要检查的头部字段的键名
    //如果请求头部中包含指定键名的头部字段, 则返回 true 否则返回 false
    
    std::string get_header_value(const char *key, size_t id = 0) const;
    //获取请求头部中指定键名的报头字段的值, 参数 key 是要获取的字段键名, 参数 id 是可选的
    //若头部字段有多个同名键名, 则可通过 id 来指定获取其中一个
    //如果请求头部中存在指定键名的头部字段, 则返回该字段的值, 否则返回空字符串
    
    void set_header(const char *key, const char *val);
    //用于设置请求头部中的一个新的头部字段或更新已存在的头部字段
    
    bool has_file(const char *key) const;
    //用于检查请求中是否包含指定键名的文件字段(表单 name)
    
    MultipartFormData get_file_value(const char *key) const;
    //用于获取请求中指定键名的文件字段的值(表单 name)
};
```

```cpp
//Response 类
struct Response
{
    //(1)状态行
    std::string version;    //协议版本
    int status = -1;        //状态码
    std::string reason;     //状态描述
    
    //(2)响应头部
    Headers headers;        //响应头部
    
    //(3)响应正文
    std::string body;       //响应体
    std::string location;   //重定向地址

    //设置响应头部
    void set_header(const char *key, const char *val);

    //设置响应正文
    void set_content(const std::string &s, const char *content_type);
};
```

### 2.1.2.双端接口

```cpp
//Server 类
class Server
{
public:
	//1.路由方法设置
    //请求路由：Handler 是函数类型, 无返回值, 传入请求, 带出响应
    using Handler = std::function<void(const Request&, Response&)>;
    //请求路由数组：众多 Handler 类型函数的列表 std::regex 是正则表达式, 用于填充和路由方法匹配 http 请求资源路径(实际上就是请求中的 path), 以后就可以根据用户端请求的路由选择对应的路由函数进行请求处理(若没有对端就会收到 404)
    using Handlers = std::vector<std::pair<std::regex, Handler>>;
    
    //(2)线程池设置
    //线程池成员, 其工作就是接受请求, 解析请求, 在映射表中查看是否有可以执行方法, 每接到链接请求, 就会把新的客户端连接抛入线程池中,
    std::function<TaskQueue* (void)> new_task_queue;

    //(3)请求方法设置, 通过下面接口, 针对不同的请求, 把路由方法添加到 Handlers 中
    //注册处理 GET 请求的处理程序
    Server &Get(const std::string &pattern, Handler handler);
    //注册处理 POST 请求的处理程序
    Server &Post(const std::string &pattern, Handler handler);
    //注册处理 PUT 请求的处理程序
    Server &Put(const std::string &pattern, Handler handler);
    //注册处理 PATCH 请求的处理程序
    Server &Patch(const std::string &pattern, Handler handler);
    //注册处理 DELETE 请求的处理程序
    Server &Delete(const std::string &pattern, Handler handler);
    //注册处理 OPTIONS 请求的处理程序
    Server &Options(const std::string &pattern, Handler handler);

    //4.启动 HTTP 服务器
    bool listen(const char* host, int port, int socket_flags = 0);
};
```

```cpp
//Client 类
class Client
{
public:
    //传入对端服务器的 ip 和 port
    Client(const std::string &host, int port);

    //发送 GET 请求到指定路径, 可附带头部信息, 并返回结果
    Result Get(const char *path, const Headers &headers);

    //发送 POST 请求到指定路径, 包含纯文本主体、内容长度、内容类型
    Result Post(const char *path, const char *body, size_t content_length, const char *content_type);

    //发送 POST 请求到指定路径，包含多部分表单数据项
    Result Post(const char *path, const MultipartFormDataItems &items); //最后一个参数是一个文件数组
};
```

### 2.1.3.实际使用

接下来我们尝试使用一下上述的接口。

先写一个自动化脚本，方便多次代码编译。

```makefile
# makefile

all: clean http_server http_client

maker: http_server http_client

http_server: http_server.cpp
	g++ -o $@ $^ -std=c++11 -lpthread -O3

http_client: http_client.cpp
	g++ -o $@ $^ -std=c++11 -lpthread -O3 

.PHONT: clean
clean:
	rm http_server http_client
```

然后编写服务端代码，支持两个接口。

```cpp
//http_server.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include "../cpp-httplib/httplib.h"

int main(int argc, char const* argv[]) {
    using namespace httplib;
    Server svr;

    svr.Get(R"(/my_get)", [](const Request& req, Response& res) {
            std::cout << "a get request." << std::endl;
            res.set_content("hello world!", "text/plain");
            res.status = 200;
        }
    );

    svr.Post(R"(/my_post)", [](const Request& req, Response& res) {
            std::cout << "a post request." << std::endl;
            auto ret = req.has_file("file");
            if (!ret) 
            {
                std::cout << "not file upload.\n";
                res.status = 404;
                return;
            }
                
            const auto& file = req.get_file_value("file");
            std::cout
                << file.filename << std::endl
                << file.content_type << std::endl
                << file.content << std::endl;
        
            std::string message = "The file is ";
            message += file.filename;
            message += "-";
            message += file.content_type;
            message += "\n";
            message += file.content;
            
            res.set_content(message.c_str(), "text/plain");
            res.status = 200;
        }
    );

    svr.listen("0.0.0.0", atoi(argv[1]));
    
    return 0;
}
```

`make maker` 编译成功后，直接运行 `./http_server 选定的端口号`。

而客户端我们不着急编写，我们直接使用浏览器测试一下 `GET` 接口。

![image-20240418135434119](./assets/image-20240418135434119.png)

观察服务端代码的输出结果。

```bash
# 运行结果
$ ./http_server 选定的端口号
a get request.
```

然后再测试 `POST` 接口，看看是否可以上传文件。

```html
<!-- test.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Upload</title>
</head>
<body>
    <form action="http://这里填您的服务器公网ip/这里填您给服务端代码绑定的port" method="post" enctype="multipart/form-data">
        <input type="file" name="file" id="file">
        <input type="submit" value="提交文件">
    </form>
</body>
</html>
```

页面渲染如下，选择任意一个文件进行提交。

![image-20240418135750328](./assets/image-20240418135750328.png)

```bash
# 运行结果
$ ./http_server 选定的端口号
a get request. # 这一句是之前运行的
a post request.
test.html
text/html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Upload</title>
</head>
<body>
    <h2>File Upload</h2>
    <form action="http://这里填您的服务器公网ip/这里填您给服务端代码绑定的port" enctype="multipart/form-data">
        <input type="file" name="file" id="file">
        <input type="submit" value="Upload">
    </form>
</body>
</html>
```

到这里，您基本就会初步使用这个库了。

当然，如果写得完整一些则如下：

```cpp
//较完整的 http_client.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include "../cpp-httplib/httplib.h"

int main(int argc, char const* argv[]) {
    using namespace httplib;
    Server svr;

    svr.Get(R"(/my_get)", [](const Request& req, Response& res) {
            std::cout << "a get request." << std::endl;
            res.set_content("hello world!", "text/plain");
            res.status = 200;
        }
    );

    svr.Post(R"(/my_post)", [](const Request& req, Response& res) {
            std::cout << "a post request." << std::endl;
            auto ret = req.has_file("file");
            if (!ret) 
            {
                std::cout << "not file upload.\n";
                res.status = 404;
                return;
            }
                
            const auto& file = req.get_file_value("file");
            std::cout
                << file.filename << std::endl
                << file.content_type << std::endl
                << file.content << std::endl;
        
            std::string message = "The file is ";
            message += file.filename;
            message += "-";
            message += file.content_type;
            message += "\n";
            message += file.content;
            
            res.set_content(message.c_str(), "text/plain");
            res.status = 200;
        }
    );

    svr.listen("0.0.0.0", atoi(argv[1]));
    
    return 0;
}
```

另外，直接使用浏览器上传文件忽略了很多上传细节，我们来自己写一个较完整的客户端试试。

```cpp
//较完整的 http_client.cpp
#include <iostream>
#include <cstdlib>
#include <fstream>
#include "../cpp-httplib/httplib.h"

int main(int argc, char const* argv[]) {
    using namespace httplib;
    Client cli(argv[1], atoi(argv[2]));

    //1.发送 GET 请求
    auto res_get = cli.Get("/my_get");
    if (res_get->status == 200) {
        std::cout << "get success" << std::endl;
        std::cout << "返回响应的状态码: " << res_get->status << std::endl;
        std::cout << "返回响应具体内容: " << res_get->body << std::endl;
    } else {
        std::cout << "get error" << std::endl;
    }

    //2.发送 POST 请求
    //读取文件内容
    std::ifstream file("example.txt", std::ios::binary);
    if (!file.is_open()) {
        std::cout << "open error" << std::endl;
        return 1;
    }

    //读取文件内容到字符串
    std::stringstream buffer;
    buffer << file.rdbuf(); //使用 rdbuf() 获取文件流的底层缓冲区, 类似 read(), 您也可以使用 read() 的
    std::string file_content = buffer.str();

    MultipartFormData item;
    item.name = "file"; //表单字段名
    item.filename = "example.txt"; //作为文件名
    item.content = file_content.c_str(); //文件内容
    item.content_type = "text/plain"; //文件格式
    MultipartFormDataItems items;
    items.push_back(item);

    //发送 POST 请求上传文件, 并且返回 res 响应
    auto res = cli.Post("/my_post", items);

    if (res && res->status == 200) { //注意 res 其实就是一个指向响应的智能指针
        std::cout << "port success" << std::endl;
        std::cout << "返回响应的状态码: " << res_get->status << std::endl;
        std::cout << "返回响应具体内容: " << res->body << std::endl;
    } else {
        std::cout << "port error" << std::endl;
    }

    return 0;
}
```

然后在客户端用的机器这边写一个 `example.txt` 文本文件，内容是 `Hello, I am limou3434`。运行两端程序后，结果如下：

```bash
# 运行结果
$ ./http_server 5000
a get request.
a post request.
example.txt
text/plain
Hello, I am limou3434

$ ./http_client 127.0.0.1 5000
get success
返回响应的状态码: 200
返回响应具体内容: hello world!
port success
返回响应的状态码: 200
返回响应具体内容: The file is example.txt-text/plain
Hello, I am limou3434
```

到这里我们会发现，所谓的上传文件实际上就是客户端读取文件内容，然后包装为请求发送给服务端，最后服务端对该文件传输做出响应而已。

## 2.2.Muduo

`Muduo` 是一个基于 `C++11` 的网络库，用于开发高性能的服务器应用程序。由陈硕开发的，旨在提供简单且高效的网络编程解决方案。`Muduo` 的设计目标是为多线程网络编程提供支持，并在多核系统上实现高并发性能。

`Muduo` 提供了以下主要特性：

1.  **“事件驱动”的“异步”编程模型**：`Muduo` 基于事件驱动的设计，使用非阻塞 `I/O` 和多线程技术，实现了高效的异步编程模型，使得服务器能够同时处理多个连接，提高了系统的并发能力和响应速度。
2.  **Reactor 模式：** `Muduo` 采用了 `Reactor 模式`，通过 `epoll` 或者 `kqueue` 等系统调用来处理事件，使得服务器能够高效地管理大量的连接。
3.  **线程池：** `Muduo` 提供了线程池来管理多线程，有效地利用多核资源，并且避免了线程频繁创建和销毁的开销。
4.  **定时器：** `Muduo` 支持定时器功能，可以方便地实现定时任务，例如心跳检测、超时处理等。
5.  **TCP 和 UDP 支持：** `Muduo` 提供了对 `TCP` 和 `UDP` 协议的支持，可以用于开发各种类型的网络应用，如 `Web` 服务器、游戏服务器、消息队列等。

>   补充：`Reactor 模式` 是一种设计模式，用于处理并发的 `I/O` 操作。它的核心思想是，将 `I/O` 事件的处理分离成两个阶段：事件的监视和事件的处理。在 `Reactor` 模式中，一个 `Reactor` 对象负责监视所有的 `I/O` 事件，并将这些事件分发给对应的处理器（也称为处理器句柄），然后处理器负责具体的事件处理。

>   补充：在前端开发中，`"Reactor"` 一词可以指代一种基于组件化的前端开发模式，即将前端页面拆分成多个独立的组件，每个组件负责特定的功能或者展示。这种模式使得前端开发更加灵活、可维护性更强，因为开发者可以独立地开发、测试和部署每个组件，而不会影响到其他部分的功能。
>
>   在这种意义下，因为 `Reactor` 模式强调了组件的独立性和可重用性，这与前端分离的理念是一致的。因此，虽然在不同的领域中，`"Reactor"` 这个词可能指代不同的概念，但是它们都强调了将系统拆分成独立的部分，并且通过组合这些部分来构建更加复杂的系统。

```mermaid
graph LR
	c1["client 1"] & c2["client 2"] & c3["client 3"] -->|"请求"| main
    main(["main Reactor\n Accpetor(listen_fd)"]) --> sub1["sub Reactors 1\nread() write()"] & sub2["sub Reactors 2\nread() write()"] & sub3["sub Reactors 3\nread() write()"]
```

-   一个线程只能有一个事件循环（`EventLoop`）用来响应计时器和 `IO` 事件
-   一个文件描述符只能由一个线程进行读写，换句话来说就是一个 `TCP` 链接必须归属某个 `EventLoop` 来管理

