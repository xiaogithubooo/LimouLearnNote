# 1.日志的基本概念



# 2.日志的第三方库

## 2.1.Boost.Log

### 2.1.1.Boost.Log 的下载

关于 `Boost.Log` 的下载，我推荐您直接下载整个 `Boost` 库。

```shell
# 下载 Boost 所有的开发包
$ sudo apt update
$ sudo apt install libboost-all-dev # 默认下载 1.74.0 版本的
$ dpkg -s libboost-dev | grep version # 或者使用 apt-cache policy libboost-all-dev 查看
$ sudo apt autoremove libboost-all-dev # 可以使用该指令把相关安装包进行卸载
```

>   待补充：下面文本没有经过验证，以后验证
>
>   对于那些想要亲自安装最新的 Boost C++ 库的人来说，您必须通过其源代码来安装它们。
>
>   首先访问 Boost C++ 网站并打开“下载”部分。找到“加速下载”选项，然后单击“当前版本”。
>
>   将显示您可以下载的可用当前版本的列表。右键单击“tar.gz”选项并复制其链接。您也可以单击它开始下载。
>
>   在您的终端上，使用 wget 通过终端下载文件。使用通过 wget 命令复制的链接来启动下载。
>
>   下载完成后，导航至下载目录。在这里，我们将文件移至“下载”以验证我们是否下载了包含源代码的 tar 文件。
>
>   使用以下命令提取存档文件：
>
>   *$* tar xvf boost_1_81_0_tar.gz
>
>   导航到提取的“Boots”目录。
>
>   *$* cd boost_1_81_0/
>
>   我们必须安装所需的依赖项来支持 Boost C++ 的安装。运行以下命令，所有依赖项将安装：
>
>   *$* sudo apt install build-essential python3-dev g++ autotools-dev libicu-dev libbz2-dev -y
>
>   然后我们需要设置 Boost 的引导程序。以下命令启动 [Bootstrap](https://cn.basicit.org/bootstrap5/) 脚本并构建 B2 引擎：
>
>   *$* sudo ./bootstrap.sh --prefix=/usr/
>
>   您现在可以运行生成的 B2 引擎。
>
>   *$* ./b2
>
>   最后，使用 B2 安装 Boost C++。
>
>   *$* sudo ./b2 install
>
>   程序运行后，安装将完成，您的系统上将拥有可用的 Boost C++ 库。然后，您可以在编写 C++ 项目时调用它们。
>
>   来自连接 https://cn.linux-console.net/?p=13955

### 2.1.2.Boost.Log 的使用

关于 `Boost.Log` 的使用，您可以 [查阅 Boost.Log 的官方文档](https://www.boost.org/doc/libs/1_79_0/libs/log/doc/html/index.html)，但是这个文档有些晦涩难懂。并且使用过 `Boost.Log` 的新手几乎都会被这个 [Boost logger linking issue](https://stackoverflow.com/questions/18881602/boost-logger-linking-issue) 坑到。

解决方案就是将静态库和目标程序做分离编译，或者干脆直接作为一条指令。

```shell
# 尝试使用 Boost.Log 避开编译坑点
$ g++ -DBOOST_LOG_DYN_LINK -c mylog.cpp
$ g++ mylog.o -lboost_log -lpthread -o mylog
# 或者直接使用 g++ mylog.cpp -o mylog -DBOOST_LOG_DYN_LINK -lboost_log -lpthread 一条语句
# 或者直接在 CMakelist.txt 中使用 add_definitions(-DBOOST_LOG_DYN_LINK)
```

>   吐槽：我就被坑过，以后再来看看是什么原因...

先来使用最基础的宏指令 `BOOST_LOG_TRIVIAL(日志等级) << "...";`，这是一个启动日志记录的指令，后面的字符串是对应的日志消息。而您也有必要了解一下内部的日志等级：

1.  **trace(跟踪)**：用于记录最为详细的调试信息，如 `函数的进入和退出、循环中的变量取值等`。适用于需要非常详细的调试信息、对系统执行流程进行深入了解的场景。不过这也设置日志消息时非常繁琐，使用起来几乎和某些 `IDE` 调试过程的输出日志毫无差异。
2.  **debug（调试）**：用于记录一般的调试信息，如 `关键变量的取值、状态变化等`。适用于正常的调试过程中需要关注的重要信息，能够帮助理解系统状态和执行流程。
3.  **info（信息）**：用于记录程序正常执行时的重要信息，如 `提示启动、关闭、关键操作的成功完成等`。适用于记录程序的运行状态、关键事件的发生以及执行流程的重要节点。
4.  **warning（警告）**：用于记录可能会导致问题或错误的情况，但不会影响系统继续运行的信息。适用于标识一些潜在的问题或异常情况，需要引起关注但不会导致系统崩溃或故障。
5.  **error（错误）**：用于记录发生了错误但程序仍能够继续执行的情况，如 `某个功能无法正常工作、某个文件无法打开等`。适用于记录导致程序功能受损或部分失败的错误情况。
6.  **fatal（致命）**：用于记录导致程序无法继续执行的严重错误，如 `内存分配失败、关键组件初始化失败等`。适用于记录程序遇到无法恢复的致命错误，需要立即引起开发人员的关注。

这个宏输消息中，包含用户自定义的日志消息、时间戳、当前线程标识（以十六进制地址形式给出）、严重性级别。并且 `Boost.Log` 保证写入日志是线程安全的。

>   吐槽：但是 `Boost.Log` 有些难用，我个人推荐使用 `Spdlog`...

## 2.2.Spdlog

`Spdlog` 非常强大，可以是 `C++` 的最佳日志库，支持以下功能：

*   非常快（见[基准测试](https://github.com/gabime/spdlog#benchmarks)）
*   仅标头和已编译，使用简单
*   使用出色的 `fmt` 库，所以有功能丰富的格式，高可自定义格式
*   可选的日志异步模式，多线程/单线程记录器以及多种日志目标
*   动态支持日志过滤，可以在运行时和编译时修改日志级别，也支持从 `argv` 或 `environment var` 加载日志级别。
*   回溯支持，将调试消息存储在环形缓冲区中，并在以后根据需要显示它们，可在性能损失小的情况下避免频繁 `IO` 操作
*   支持 `trace, debug, info, warn, error, critical, off` 这 `7` 种日志级别，可以非常方便过滤不同级别的日志
*   跨平台，支持 `Linux、Windows、MacOS` 等多个平台
*   社区活跃，反响较好

### 2.2.1.Spslog 的下载

关于 `Spslog ` 的下载，我推荐您直接使用包管理器 `sudo apt install libspdlog-dev` 来下载，或者获取 [前往 github 使用 cmake 进行构建获取](https://github.com/gabime/spdlog)（不过删除也比较麻烦...）。

```shell
# 包管理安装 Spslog
sudo apt install libspdlog-dev
```

```shell
# 构建安装 Spslog 
$ git clone https://github.com/gabime/spdlog.git
$ cd spdlog && mkdir build && cd build
$ cmake ..
$ sudo install spdlog # 安装到系统的安装目录下
$ ls /usr/local/include/ | grep "spdlog" # 检查是否安装成功对应的头文件
```

### 2.2.2.Spslog 的使用

稍微测试一下 `README.md` 里的例子（有删改），看看是否安装顺利，顺便告诉您常见的使用方法。

#### 2.2.2.1.输出不同等级的日志消息

```shell
# 尝试使用 Spdlog
$ cat slog.cpp 
#include <spdlog/spdlog.h>

int main() 
{
    spdlog::info("欢迎来到 spdlog!");
    spdlog::error("一些 error 消息和参数: {}", 1);
    
    spdlog::warn("很容易填充数字，比如 {:08d}", 12);
    spdlog::critical("支持 int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}", 42);
    spdlog::info("支持 floats {:03.2f}", 1.23456);
    spdlog::info("支持位置参数 {1} {0}..", "argv0", "argv1");
    spdlog::info("{:<30}", "支持对齐(这里是左对齐)");
    
    spdlog::set_level(spdlog::level::debug); // 设置全局日志级别为debug
    spdlog::debug("应该显示此消息..");    
    
    // 更改日志格式
    spdlog::set_pattern("[%H:%M:%S %z] [%n] [%^---%L---%$] [thread %t] %v");
    
    // 也可以使用另外一种风格的宏日志, 不过我个人不推荐...
    spdlog::trace("一些 trace 消息和参数 {}", 42);
    SPDLOG_TRACE("一些 trace 消息和参数 {}", 42);
    SPDLOG_DEBUG("一些 debug 消息");
    SPDLOG_INFO("一些 info 消息");
    SPDLOG_CRITICAL("一些 critical 消息");

    return 0;
}

$ g++ slog.cpp -lspdlog -lpthread
$ ./a.out 
# 尝试使用 Spdlog
$ cat slog.cpp 
#include <spdlog/spdlog.h>

int main() 
{
    spdlog::info("欢迎来到 spdlog!");
    spdlog::error("一些 error 消息和参数: {}", 1);
    
    spdlog::warn("很容易填充数字，比如 {:08d}", 12);
    spdlog::critical("支持 int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}", 42);
    spdlog::info("支持 floats {:03.2f}", 1.23456);
    spdlog::info("支持位置参数 {1} {0}..", "argv0", "argv1");
    spdlog::info("{:<30}", "支持对齐(这里是左对齐)");
    
    spdlog::set_level(spdlog::level::debug); // 设置全局日志级别为debug
    spdlog::debug("应该显示此消息..");    
    
    // 更改日志格式
    spdlog::set_pattern("[%H:%M:%S %z] [%n] [%^---%L---%$] [thread %t] %v");
    
    // 也可以使用另外一种风格的宏日志, 不过我个人不推荐...
    spdlog::trace("一些 trace 消息和参数 {}", 42);
    SPDLOG_TRACE("一些 trace 消息和参数 {}", 42);
    SPDLOG_DEBUG("一些 debug 消息");
    SPDLOG_INFO("一些 info 消息");
    SPDLOG_CRITICAL("一些 critical 消息");

    return 0;
}

$ g++ slog.cpp -lspdlog -lpthread
$ ./a.out 
[2024-05-28 01:04:35.802] [info] Welcome to spdlog!
[2024-05-28 01:04:35.802] [error] Some error message with arg: 1
[2024-05-28 01:04:35.802] [warning] Easy padding in numbers like 00000012
[2024-05-28 01:04:35.802] [critical] Support for int: 42;  hex: 2a;  oct: 52; bin: 101010
[2024-05-28 01:04:35.802] [info] Support for floats 1.23
[2024-05-28 01:04:35.802] [info] Positional args are supported too..
[2024-05-28 01:04:35.802] [info] left aligned                  
[2024-05-28 01:04:35.802] [debug] This message should be displayed..
[01:04:35 +08:00] [] [---I---] [thread 652737] Some info message
```

#### 2.2.2.2.创建不同作用日志记录器

`Spdlog` 库提供了几种不同的日志记录对象，可以根据需要选择合适的日志记录器类型。

1.  **Basic Logger (stdout/stderr)**:
    *   `spdlog::stdout_logger_mt`：标准输出日志记录器，输出到控制台
    *   `spdlog::stderr_logger_mt`：标准错误输出日志记录器，输出到控制台
2.  **Color Logger (stdout/stderr)**:
    *   `spdlog::stdout_color_mt`：彩色标准输出日志记录器，以颜色区分不同级别的日志消息，并输出到控制台
    *   `spdlog::stderr_color_mt`：彩色标准错误输出日志记录器，以颜色区分不同级别的日志消息，并输出到控制台
3.  **File Logger**:
    *   `spdlog::basic_logger_mt`：基本文件日志记录器，将日志消息写入到文件中
    *   `spdlog::rotating_logger_mt`：带有日志文件轮转功能的日志记录器，可以限制日志文件大小并自动进行轮转（带有日志文件轮转功能的日志记录器是指能够在日志文件大小达到一定阈值时，自动创建新的日志文件，并将旧的日志文件重命名或移动到备份目录，从而避免单个日志文件过大，提高了日志文件的可读性和管理性）
    *   `spdlog::daily_logger_mt`：每日生成一个新的日志文件的日志记录器
4.  **Syslog Logger**:
    *   `spdlog::syslog_logger`：`syslog` 日志记录器，将日志消息发送到系统日志守护进程里。`syslog` 是 `Unix` 和类 `Unix` 操作系统中用于记录系统事件的标准方法，`syslogd` 是负责接收、记录和处理系统日志消息的守护进程，这个记录器可以方便日志消息与系统级别的日志进行统一管理和监控

基本日志记录器我就不提了，和其他三种记录器是一样的使用方法，下面展示其他三种记录器的使用方法。

```shell
# 使用彩色日志记录器
$ cat slog.cpp 
// 使用基本日志记录器
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>

int main()
{
    // 创建一个彩色标准输出日志记录器
    auto console = spdlog::stdout_color_mt("console"); // 默认日志等级为 info

    // 输出不同级别的日志消息
    console->trace("This is a trace message");  // 这条日志不会被输出
    console->debug("This is a debug message");  // 这条日志不会被输出
    console->info("This is an info message");    // 这条日志会被输出
    console->warn("This is a warning message");  // 这条日志会被输出
    console->error("This is an error message");  // 这条日志会被输出
    
    // 重置日志等级后在输出日志
    console->set_level(spdlog::level::trace);
    console->trace("This is a trace message");  // 这条日志会被输出
    console->debug("This is a debug message");  // 这条日志会被输出
    console->info("This is an info message");    // 这条日志会被输出
    console->warn("This is a warning message");  // 这条日志会被输出
    console->error("This is an error message");  // 这条日志会被输出
    
    auto err_logger = spdlog::stderr_color_mt("stderr");    
    spdlog::get("stderr")->debug("some debug message"); // 这会输出到 stderr 中
    spdlog::get("stderr")->info("some info message"); // 这会输出到 stderr 中
    
    return 0;
}

$ g++ slog.cpp -lpthread
$ ./a.out 
[2024-05-28 11:47:38.953] [console] [info] This is an info message
[2024-05-28 11:47:38.953] [console] [warning] This is a warning message
[2024-05-28 11:47:38.953] [console] [error] This is an error message
[2024-05-28 11:47:38.953] [console] [trace] This is a trace message
[2024-05-28 11:47:38.953] [console] [debug] This is a debug message
[2024-05-28 11:47:38.953] [console] [info] This is an info message
[2024-05-28 11:47:38.953] [console] [warning] This is a warning message
[2024-05-28 11:47:38.953] [console] [error] This is an error message
[2024-05-28 11:47:38.953] [stderr] [info] some info message
    
$ ./a.out 2>&1 1>/dev/null # 只要 stderr 的输出
[2024-05-28 11:48:00.702] [stderr] [info] some info message
```

```shell
# 使用文件日志记录器
$ cat slog.cpp 
#include <spdlog/sinks/basic_file_sink.h>
int main()
{
    // 创建基本文件记录器
    auto basic_logger = spdlog::basic_logger_mt("basic_logger", "logs/basic-log.txt");
    basic_logger->debug("This is a debug message");  // 这条日志不会被输出到 logs/basic-log.txt
    basic_logger->info("This is an info message");    // 这条日志会被输出到 logs/basic-log.txt
    basic_logger->warn("This is a warning message");  // 这条日志会被输出到 logs/basic-log.txt
    basic_logger->error("This is an error message");  // 这条日志会被输出到 logs/basic-log.txt
    
    // 创建一个最大大小为 5 MB的文件旋转记录器和 3 个旋转文件的旋转记录器
    auto max_size = 1048576 * 5; // 最大大小
    auto max_files = 3; // 最大文件个数
    auto some_logger_name = spdlog::rotating_logger_mt("some_logger_name", "logs/rotating.txt", max_size, max_files); // 这个您可以自己测试一些, 测试起来有点麻烦我就不演示了...
    
    return 0;
}

$ g++ slog.cpp -lpthread
$ ./a.out 

$ ls
logs   slog.cpp

$ cd logs/

/logs$ ls
basic-log.txt

/logs$ cat basic-log.txt # 也是默认日志等级为 info
[2024-05-28 11:55:33.086] [basic_logger] [info] This is an info message
[2024-05-28 11:55:33.086] [basic_logger] [warning] This is a warning message
[2024-05-28 11:55:33.086] [basic_logger] [error] This is an error message
```

```shell
# 使用每日日志记录器
$ cat slog.cpp 
#include "spdlog/sinks/daily_file_sink.h"
int main()
{
    // 创建一个每日日志——每天凌晨 2:30 创建一个新文件
    auto daily_logger = spdlog::daily_logger_mt("daily_logger", "logs/daily.txt", 2, 30);
    return 0;
}
# 演示起来也有点麻烦, 这里我也偷个懒...
```

