# 1.日志的基本概念



# 2.日志的第三方库

## 2.1.Boost.Log

### 2.1.1.Boost.Log 的下载

关于 `Boost.Log` 的下载，我推荐您直接下载整个 `Boost` 库。

```shell
# 下载 Boost 所有的开发包
$ sudo apt update
$ sudo apt install libboost-all-dev # 默认下载 1.74.0 版本的
$ dpkg -s libboost-dev | grep version # 或者使用 apt-cache policy libboost-all-dev 查看
$ sudo apt autoremove libboost-all-dev # 可以使用该指令把相关安装包进行卸载
```

>   待补充：下面文本没有经过验证，以后验证
>
>   对于那些想要亲自安装最新的 Boost C++ 库的人来说，您必须通过其源代码来安装它们。
>
>   首先访问 Boost C++ 网站并打开“下载”部分。找到“加速下载”选项，然后单击“当前版本”。
>
>   将显示您可以下载的可用当前版本的列表。右键单击“tar.gz”选项并复制其链接。您也可以单击它开始下载。
>
>   在您的终端上，使用 wget 通过终端下载文件。使用通过 wget 命令复制的链接来启动下载。
>
>   下载完成后，导航至下载目录。在这里，我们将文件移至“下载”以验证我们是否下载了包含源代码的 tar 文件。
>
>   使用以下命令提取存档文件：
>
>   *$* tar xvf boost_1_81_0_tar.gz
>
>   导航到提取的“Boots”目录。
>
>   *$* cd boost_1_81_0/
>
>   我们必须安装所需的依赖项来支持 Boost C++ 的安装。运行以下命令，所有依赖项将安装：
>
>   *$* sudo apt install build-essential python3-dev g++ autotools-dev libicu-dev libbz2-dev -y
>
>   然后我们需要设置 Boost 的引导程序。以下命令启动 [Bootstrap](https://cn.basicit.org/bootstrap5/) 脚本并构建 B2 引擎：
>
>   *$* sudo ./bootstrap.sh --prefix=/usr/
>
>   您现在可以运行生成的 B2 引擎。
>
>   *$* ./b2
>
>   最后，使用 B2 安装 Boost C++。
>
>   *$* sudo ./b2 install
>
>   程序运行后，安装将完成，您的系统上将拥有可用的 Boost C++ 库。然后，您可以在编写 C++ 项目时调用它们。
>
>   来自连接 https://cn.linux-console.net/?p=13955

### 2.1.2.Boost.Log 的使用

关于 `Boost.Log` 的使用，您可以 [查阅 Boost.Log 的官方文档](https://www.boost.org/doc/libs/1_79_0/libs/log/doc/html/index.html)，但是这个文档有些晦涩难懂。并且使用过 `Boost.Log` 的新手几乎都会被这个 [Boost logger linking issue](https://stackoverflow.com/questions/18881602/boost-logger-linking-issue) 坑到。

解决方案就是将静态库和目标程序做分离编译，或者干脆直接作为一条指令。

```shell
# 避开编译坑点
$ g++ -DBOOST_LOG_DYN_LINK -c mylog.cpp
$ g++ mylog.o -lboost_log -lpthread -o mylog
# 或者直接使用 g++ mylog.cpp -o mylog -DBOOST_LOG_DYN_LINK -lboost_log -lpthread 一条语句
# 或者直接在 CMakelist.txt 中使用 add_definitions(-DBOOST_LOG_DYN_LINK)
```

>   吐槽：我就被坑过，以后再来看看是什么原因...

先来使用最基础的宏指令 `BOOST_LOG_TRIVIAL(日志等级) << "...";`，这是一个启动日志记录的指令，后面的字符串是对应的日志消息。而您也有必要了解一下内部的日志等级：

1.  **trace(跟踪)**：用于记录最为详细的调试信息，如 `函数的进入和退出、循环中的变量取值等`。适用于需要非常详细的调试信息、对系统执行流程进行深入了解的场景。不过这也设置日志消息时非常繁琐，使用起来几乎和某些 `IDE` 调试过程的输出日志毫无差异。
2.  **debug（调试）**：用于记录一般的调试信息，如 `关键变量的取值、状态变化等`。适用于正常的调试过程中需要关注的重要信息，能够帮助理解系统状态和执行流程。
3.  **info（信息）**：用于记录程序正常执行时的重要信息，如 `提示启动、关闭、关键操作的成功完成等`。适用于记录程序的运行状态、关键事件的发生以及执行流程的重要节点。
4.  **warning（警告）**：用于记录可能会导致问题或错误的情况，但不会影响系统继续运行的信息。适用于标识一些潜在的问题或异常情况，需要引起关注但不会导致系统崩溃或故障。
5.  **error（错误）**：用于记录发生了错误但程序仍能够继续执行的情况，如 `某个功能无法正常工作、某个文件无法打开等`。适用于记录导致程序功能受损或部分失败的错误情况。
6.  **fatal（致命）**：用于记录导致程序无法继续执行的严重错误，如 `内存分配失败、关键组件初始化失败等`。适用于记录程序遇到无法恢复的致命错误，需要立即引起开发人员的关注。

这个宏输消息中，包含用户自定义的日志消息、时间戳、当前线程标识（以十六进制地址形式给出）、严重性级别。并且 `Boost.Log` 保证写入日志是线程安全的。

>   吐槽：但是 `Boost.Log` 有些难用，我个人推荐使用 `Spdlog`...

## 2.2.Spdlog

### 2.2.3.Spslog 的下载

关于 `Spslog ` 的下载，我推荐您直接 [前往 github 使用 cmake 进行构建获取](https://github.com/gabime/spdlog)。

