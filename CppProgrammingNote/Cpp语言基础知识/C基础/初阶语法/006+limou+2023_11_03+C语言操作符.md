# 1.操作符是什么

`C 语言` 的操作符也被称为运算符，是用于执行特定操作的符号，可以拿来构建表达式并实现了程序中的各种计算和操作。

不过您首先需要知道，操作符一般是有对应的操作数的，例如 `1 + a` 这个表达式的操作数是常量 `1` 和变量 `a`，操作符为 `+`。而有些操作符只能操作更少或者更多的操作数，而根据操作数的个数，可以分为单目操作符、双目操作符、三目操作符。

不过我不按这个分类来讲，这种分类更多是强调操作符的使用规则，而不是作用，我以下回按照操作符的作用来分类讲解...

# 2.操作符的分类

我们从操作符的作用上来讲解，先不考虑多个操作符混杂的情况，只考虑一个操作符的使用。

## 2.1.算术操作符

*   `+，-，*，/`：常规的加减乘除操作符
*   `%`：取模操作符

上述操作符中都是双目操作符，包含两个操作数。除了 `%` 左右的操作数必须是两个整数，其他的操作符左右的操作数可以是整型数据，也可以浮点型数据。 

需要注意的是，对于 `/` 左右两个操作数在一个数是浮点数就执行浮点数的除法，否则都按照整型的除法。并且整型的除法只取商值而不取余数值，但是浮点型的除法和平时我们正常的除法一样。这是什么意思呢？请观察以下代码的现象。

```cpp
// 使用不同数据类型作除法的一种现象
#include <stdio.h>

int main() {
    int num1 = 2;
    int num2 = 7;
    double num3 = 7.0;
    double num4 = 2.; // 这里 C 语言允许使用 "2." 的方式表示 "2.0"
    double result1, result2, result3, result4; // 这里可以不初始化, 但是这不是很好的习惯, 我只是演示给您看这种做法在大部分情况下是没有问题的

    // 操作数都是整数时作除法, 结果依旧为整数类型数据
    result1 = num1 / num2; // 相当于 2 / 7 == 0...2 只把商的结果带走了, 但是余数直接丢弃, 整个结果不包含小数点以后的结果
    printf("result1 = num1 / num2 结果: %d\n", result1); // 结果为 0

    // 其中一个操作数是浮点数时做除法, 由于 num3 是浮点类型, num1 被转化为浮点类型的 2.0, 结果为浮点类型数据
    result2 = num1 / num3; // 相当于 2 / 7.0 == 2.0 / 7.0 == 0.285714...
    printf("result2 = num1 / num3 结果: %f\n", result2); // 结果为 0.285714

    // 混合除法，第一个操作数是整数，第二个是浮点数
    result4 = num3 / num4; // 相当于 7.0 / 2. == 7.0 / 2.0 == 3.500000
    printf("result3 = num3 / num4 结果: %f\n", result4); // 结果为 3.500000

    return 0;
}
```

而实际上，所有的操作符在使用的时候，如果使用的所有操作数的类型不统一，`C 语言` 会保证所有类型在计算的时候发送隐式转换，使得所有的操作数在计算时的类型时统一的（这样方便统一计算机规则，虽然听起来不可思议，但是计算机中整数的加减法和浮点数的加减法的确时不同的，无法直接兼容）。

体现在上述代码中，就是 `result2 = num1 / num3` 中的 `num1` 和 `num2` 不统一，因此把 `num1` 转化为和 `num2` 一样的整型即可。但您一定会有一个问题，为什么不转化 `num2` 为 `num1` 的 `int` 类型呢？

这是因为转化的过程中有时会很危险，一般转化方向都是存储容量较小的数据类型转化为存储容量较大的数据类型，例如 `int` 转为 `long`，`char` 转为 `int`，`flaot` 转为 `double`，`int` 转为 `double`...

>    类比：如果有一个只能存储 `1L` 的容器装满了水，为了保证所有的水不被流失，并且我们决定更换更大的容器。您会选择使用 `2L` 的新容器来存储这些水，还是使用 `0.5L` 的容器来存储这些水？一般情况下都是选择 `2L`，毕竟人总有宁滥勿缺的想法...因此编译器选择把 `int` 类型的数据转化为存储容量更大的 `double` 也十分的合理。另外，这种行为实际是 `C` 语言标准要求编译器实现的。

>   补充：如果取余涉及到负数怎么办？待补充...

## 2.2.赋值操作符

### 2.2.1.普通赋值操作符

“=”可以做到赋值给一个变量

（2）C语言允许连续赋值，并且从左到右理解

//连续赋值

int a = 10;

int x = 0;

int y = 20;

a = x = y + 1;

//连续赋值的另一种等价写法

int a = 10;

int x = 0;

int y = 20;

x = y + 1;

a = x;

### 2.2.2.复合赋值操作符

*   +=、-=、/=、*=等等。

（4）注意：赋值和初始化是有区别的，这是两个概念

int a = 3;//与a = 3不一样

## 2.3.单目操作符

*   ！逻辑反操作
*   -负值
*   +正值
*   &取地址
*   sizeof(操作数)求出操作数的类型长度（以字节为单位）
*   ~对一个是的二进制按位取反
*   ++前置、后置加加
*   --前置、后置减减
*   *间接访问操作符
*   (类型)强制类型转换

（1）sizeof()

\#include <stdio.h>

void test1(int arr[])

{

   printf("%d\n", sizeof(arr));//(3)

}

void test2(char ch[])

{

   printf("%d\n", sizeof(ch));//(4)

}

int main()

{

   int arr[10] = {0};

   char ch[10] = {0};

   printf("%d\n", sizeof(arr));//(1)

   printf("%d\n", sizeof(ch));//(2)

   test1(arr);

   test2(ch);

   return 0;

}

其中（1）（2）（3）（4）的值为40、10、8、8，因为（3）（4）是指针变量，本程序是在x64环境下运行的，所以得出的是指针类型的大小，如果是x86环境则值为4。

（2）++、--操作符要注意先后

//前置++和--

\#include <stdio.h>

int main()

{

  int a = 10;

  int x = ++a;//先对a进行自增，然后对使用a，也就是表达式的值是a自增之后的值。x为11。

  int y = --a;//先对a进行自减，然后对使用a，也就是表达式的值是a自减之后的值。y为10;

  printf("x=%d, y=%d", x, y);

  return 0;

}

//后置++和--

\#include <stdio.h>

int main()

{

  int a = 10;

  int x = a++;//先对a先使用，再增加，这样x的值是10；之后a变成11；

  int y = a--;//先对a先使用，再自减，这样y的值是11；之后a变成10；

   printf("x=%d, y=%d", x, y);

  return 0;

}

一道易错题目

\#include <stdio.h>int main()

{

   int a, b, c;

  a = 5;

  c = ++a;

  b = ++c, c++, ++a, a++;

  b += a++ + c;//注意这里先用a再++

  printf("a = %d b = %d c = %d\n:", a, b, c);

  return 0;

}

最后的结果是： a = 9 b= 23 c = 8

（3）~的运算，将数的二进制0转化为1，1转化为0，并且结果是补码，输出需要转化为原码

\#include<stdio.h>

int main()

{

  int a = 0;

  //0000 0000 0000 0000 0000 0000 0000 0000经过~后变成

  //1111 1111 1111 1111 1111 1111 1111 1111生成一个补码

  //1111 1111 1111 1111 1111 1111 1111 1110返回反码

  //1000 0000 0000 0000 0000 0000 0000 0001返回原码

  printf("%d\n", ~a);//故输出-1

  return 0;

}

注意有一种写法的理解

while(~scanf("%d", &number))//这里就是将scanf读取失败返回EOF（-1）的二进制按位取反为-1

{

  //某些代码

}

（4）注意强制转化是一种临时转化，不是永久转化

int main()

{

   int a = 1;

  printf("%f %zd\n", (float)a, sizeof(a));

  printf("%d %zd\n", a, sizeof(a));

  return 0;

}//可以看到两次输出sizeof都是4（x64）平台

## 关系操作符

*   \>和<
*   \>=和<=
*   !=和==

和数学上的用法类似，但我还是想强调一下，等于 `==` 不是 `=`，这一点经常会出错

## 条件操作符

*   exp1 ? exp2 : exp3，其意义是若exp1为真，执行exp2；若exp1为假，执行exp3

//分支语句写法

if(a > 5)

{

  b = 3;

}

else

{

  b = -3;

}

//使用三目操作符改写

a > 5 ? b = 3 : b = -3;

## 逗号操作符

*   exp1, exp2, exp3, ……

逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。

//代码1

int a = 1;

int b = 2;

int c = (a > b, a = b + 10, a, b = a + 1);//整个表达式的值是最后一个表达式的值 

**11、下标引用、函数调用和结构成员**

*   下标引用操作符[]，例如：arr[<某下标>]，可以访问数组的成员，注意其操作数有两个，一个是<数组名>，另一个是<数组下标/索引>
*   函数调用操作符()，例如使用一个自定义函数：function(x)，绝不能省略成“function x”，这个()是在提醒编译器，前面的关键词是一个函数！函数有多个参数的话，就有多少个操作数（采用“,”分割参数）
*   访问结构的成员有两种方法：
    *   “.”，“结构体.成员名”
    *   “->”，“结构体指针->成员名” 

//演示了结构体的成员访问方法

\#include <stdio.h>

struct Stu//一个结构体

{

   char name[10];

   int age;

   char sex[5];

   double score;

}；

void set_age1(struct Stu stu)

{

   stu.age = 18;

}

void set_age2(struct Stu* pStu)

{

   pStu->age = 18;//结构成员访问

}

int main()

{

   struct Stu stu;

   struct Stu* pStu = &stu;//结构成员访问

   stu.age = 20;//结构成员访问

   set_age1(stu);

   pStu->age = 20;//结构成员访问

   set_age2(pStu);

   return 0;

}

**12、表达式求值**

表达式求值的顺序一部分是由操作符的优先级和结合性决定。

同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

**Ⅰ、整型提升**

**（1）整型提升的概念**

C语言的整形算术运算总是至少以缺省（默认）整形类型的精度来进行的

为了获得这个精度，表达式中的“字符操作数”和“短整型操作数”在使用之前被转换为“普通整型”，这种转换称为整型提升。

**（2）整型提升的意义**

*   表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
*   通用CPU（general-purpose CPU）是难以直接实现两个8比特（1字节）字节直接相加运算（虽然机器指令 中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。

**（3）整型提升的例子**

char a, b = 3, c = 127;//b和c都被提升为整型类型，然后执行加法运算

//0000 0000 0000 0000 0000 0000 0000 0011 = 3

//0000 0000 0000 0000 0000 0000 0111 1111 = 127

//先截断存储在char中0000 0011和0111 1111，由于不溢出，故值不变

a = b + c;

//由于需要运算，需要整型提升来提高计算精度，因此0000 0011和0111 1111又变成了

//0000 0000 0000 0000 0000 0000 0000 0011 

//0000 0000 0000 0000 0000 0000 0111 1111 

//相加后就是//0000 0000 0000 0000 0000 0000 1000 0010 = 130

//加法运算完成后，结果被截断为1000 0010，然后被存储在a中。

//由于整个过程没有负数和溢出问题，所以平时使用运算的时候，整型提升会观察不出来

为什么说没有负数的问题呢？

因为负数的整形提升是用符号位提升的，上述正数用0来提升（例如0000 0011变成0000 0000 0000 0000 0000 0000 0000 0011 ） ，而负数的符号位是1，负数整型提升需要用1来补回

//①负数的整形提升

char c1 = -1;

//变量c1的二进制位(补码)中只有8个比特位：1111111

//因为 char 默认为有符号的 char，所以整形提升的时候，高位补充符号位，即为1

//提升之后的结果是：11111111111111111111111111111111

//②正数的整形提升

char c2 = 1;

//变量c2的二进制位(补码)中只有8个比特位：00000001

//因为 char 默认为有符号的 char，所以整形提升的时候，高位补充符号位，即为0

//提升之后的结果是：00000000000000000000000000000001

//③无符号整形提升，高位补0

**（4）整型提升的验证**

int main()

{

   char a = 0xb6;

   short b = 0xb600;

   int c = 0xb6000000;

   if(a==0xb6)

   {

​     printf("a");

  }

   if(b==0xb600)

   {

​     printf("b");

  }

   if(c==0xb6000000)

   {

​     printf("c");

  }

   return 0;

}

//c只要参与表达式运算，就会发生整形提升。

**Ⅱ、算术转化**

如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类

型，否则操作就无法进行。下面的层次体系称为寻常算术转换。（从高到下排列）

*   long double
*   double
*   float
*   unsigned long int
*   long int
*   unsigned int
*   int

如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运

算。C相信程序员，不会在这方面要求程序员转换，但是程序员必须承担相应的责任。例如下面的例子，就展示了算术转换一些潜在的风险。

float f = 3.14;

int num = f;//隐式转换，会有精度丢失

**Ⅲ、操作符的属性**

*   操作符的优先级
*   操作符的结合性
*   是否控制求值顺序

**Ⅳ、一些问题表达式**

*   问题表达式1

a*b + c*d + e*f

//可能顺序1；

a*b

c*d

a*b + c*d

e*f

a*b + c*d + e*f

//可能顺序2；

a*b

c*d

e*f

a*b + c*d

a*b + c*d + e*f

*   问题表达式2

c + ++c;//无法明确前一个c用的是加加之前的c值还是之后的c值

*   问题表达式3

int fun()

{

  static int count = 1;

  return ++count;

}

int main()

{

  int answer;

  answer = fun() - fun() * fun();

  printf( "%d\n", answer);//输出多少？

  return 0;

}

//上述代码中的 answer = fun() - fun() * fun(); 只能通过操作符的优先级得知：先算乘法，再算减法，函数的调用先后顺序无法通过操作符的优先级确定。

上述的表达式在不同的环境可能会有不同的代码。 



## 位操作符

注意：整数在内存中存的都是补码，下面的位操作都是发生在补码身上，再用原码显示出来。

注意：浮点数是不能用移位操作的，下面的操作数都是整数。

（1）<<左移操作符

int num = 10;

int a = num << 1;

//0000 0000 0000 0000 0000 0000 0000 1010

//0000 0000 0000 0000 0000 0000 0001 0100

//a的值为20

//注意num本身没有发生改变，除非使用<<=

（2）>>右移操作符（分为两种）

*   逻辑右移：左边用0填充，右边丢弃
*   算术右移：左边用符号位填充，右边丢弃

那么究竟什么时候用逻辑右移，什么时候用算术右移呢？绝大多数编译器用的都是算术右移。另外移动的位数是正数，负数是没有定义的！

*   &，按位与，全1才为1
*   |，按位或，有1就为1
*   ^，按位异或，同0异1

（1）不能创建临时变量（第三个变量），实现两个数交换（本质上^自己和自己是互逆运算）

\#include <stdio.h>

int main()

{

   int a = 10;

   int b = 20;

   a = a ^ b;

   b = a ^ b;

   a = a ^ b;

   printf("a = %d b = %d\n", a, b);

   return 0;

}

//a ^ a = 0

//0 ^ a = a 

//a ^ 0 = a

//假设^存在逆运算v

//则a ^ a v a= 0 v a，a= 0 v a

//则0 v a = a = 0 ^ a，故“v”<-->“^”。

//本方法缺陷在于：只能是整数，并且可读性差，效率也不一定提高

（2）求一个整数存储在内存中的二进制中1的个数

//方法1：

\#include <stdio.h>

int main()

{

   int num = 10;

   int count= 0;//计数

   while(num)

   {

​     if(num%2 == 1)

​     count++;

​     num = num/2;

   }

   printf("二进制中1的个数 = %d\n", count);

   return 0;

}//思考这样的实现方式有没有问题？

//方法2：

\#include <stdio.h>

int main()

{

   int num = -1;

   int i = 0;

   int count = 0;//计数

   for(i=0; i<32; i++)

   {

​     if( num & (1 << i) )

​     count++;

   }

   printf("二进制中1的个数 = %d\n",count);

   return 0;

}//思考还能不能更加优化，这里必须循环32次的。

//方法3：

#include <stdio.h>

int main()

{

   int num = -1;

   int i = 0;

   int count = 0;//计数

   while(num)

   {

​     count++;

​     num = num&(num-1);

   }

   printf("二进制中1的个数 = %d\n",count);

   return 0;

}//这种方式是不是很好？达到了优化的效果，但是难以想到。

## 逻辑操作符

*   &&逻辑与
*   ||逻辑或

注意：逻辑操作符的短路特性，可以减小运算。当a&&b中，a表达式为假，b表达式就不会被执行；当a||b中，a表达式为真，b表达式就不会被执行

\#include <stdio.h>

int main()

{

   int i = 0, a = 0, b = 2, c = 3, d = 4;

  i = a++ && ++b && d++;

  //i = a++ || ++b || d++;

  printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);

  return 0;

}

//程序输出的结果是什么？因为a为0（先使用未++），后面的表达式就不重要了

//a = 1

//b = 2

//c = 3

//d = 4

//如果换成i = a++ || ++b || d++;呢？

//a = 1

//b = 3

//c = 3

//d = 4
