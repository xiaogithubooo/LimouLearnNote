

**叠甲：以下文章主要是依靠我的实际编码学习中总结出来的经验之谈，求逻辑自洽，不能百分百保证正确，有错误、未定义、不合适的内容请尽情指出！**

[TOC]

>   概要：...

>   资料：...

---

>   吐槽：一些个人吐槽，可以看也可以不看...

>   警告：一些容易错误、遗漏的点...

>   区别：一些容易混淆、混乱的点...

>   补充：一些补充性知识，最好是看一下...

# 1.泛型编程

## 1.1.泛型的类

我们先来提及 `Java` 中的泛型类 `ArrayList`，它可以存储任意类型的对象列表（类似数组）。通常在使用 `ArrayList` 时，需要指定它要存储的对象类型。

```java
// 创建泛型类对象
ArrayList<String> stringList = new ArrayList<>();
ArrayList<Integer> intList = new ArrayList<>();
```

>   补充：如果没有指定具体的类型，那么 `ArrayList` 将使用原始类型，因此元素类型就是 `Object`，通常我不推荐您这么做，因为它会导致编译器警告，并且可能引入类型不安全的问题，您无法确定从列表中取出的对象的具体类型。
>
>   ```java
>   // 使用无类型的列表
>   import java.util.ArrayList;
>   import java.util.Objects;
>   
>   public class Main {
>       public static void main(String[] args) {
>           ArrayList list = new ArrayList();
>           list.add("String");
>           list.add(1);
>   
>           Object e1 = list.get(0);
>           // String ee1 = list.get(0); // 除非使用强制类型转换
>   
>           Object e2 = list.get(1);
>           // int ee2 = list.get(1); // 除非执行强制类型转换
>   
>           System.out.println(e1);
>           System.out.println(e2);
>       }
>   }
>   ```

那么我们怎么定义一个自己的泛型类呢？请看下面代码。

```java
// 自定义泛型的类
class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }

    @Override
    public String toString() {
        return "Box{" + "content=" + content + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Box<String> stringBox = new Box<>();
        stringBox.setContent("Hello, Generics");
        System.out.println(stringBox.getContent());
        System.out.println(stringBox); // 等价于 stringBox.toString()

        Box<Integer> intBox = new Box<>();
        intBox.setContent(123);
        System.out.println(intBox.getContent());
        System.out.println(intBox); // 等价于 intBox.toString()
    }
}
```

>   补充：在 `Java` 中，泛型不支持使用基本数据类型（如 `int`, `char`, `double` 等）作为类型参数（因此需要对基本数据类型使用封装类）。
>

还可以在泛型设计中加入对继承的限定，这样做可以确保泛型类型参数满足特定的条件。

```java
// 定义一个泛型类 Box，限定泛型类型参数必须是 Number 或其子类
class Box<T extends Number> {
    private T content;

    public Box(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }

    public void setContent(T content) {
        this.content = content;
    }

    public double getDoubleContent() {
        return content.doubleValue();
    }

    public static void main(String[] args) {
        // 创建一个装载整数的盒子
        Box<Integer> integerBox = new Box<>(10);
        System.out.println("Integer content: " + integerBox.getContent());
        System.out.println("Double value: " + integerBox.getDoubleContent());

        // 创建一个装载浮点数的盒子（编译时错误，因为 Double 不是 Number 的子类）
        // Box<Double> doubleBox = new Box<>(10.5); // 这行代码会导致编译错误

        // 使用通配符可以创建装载浮点数的盒子
        Box<Double> doubleBox = new Box<>(10.5);
        System.out.println("Double content: " + doubleBox.getContent());
        System.out.println("Double value: " + doubleBox.getDoubleContent());
    }
}

```

## 1.2.泛型方法

泛型通常还可以定义多个泛类型，这里我们结合泛型方法来编写一下代码。

```java
// 自定义泛型方法
class Box<T, V> {
    private T data1;
    private V data2;

    public void setContent(T data1, V data2) {
        this.data1 = data1;
        this.data2 = data2;
    }

    public String getContent() {
        return this.data1.toString() + " " + this.data2.toString();
    }

    @Override
    public String toString() {
        return "Box{" + "data1=" + this.data1 + "data2=" + this.data2 + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Box<String, Integer> strAndIntBox = new Box<>();
        strAndIntBox.setContent("Hello, Generics", 1);
        System.out.println(strAndIntBox.getContent());
        System.out.println(strAndIntBox);

        Box<Integer, Double> intAndDouBox = new Box<>();
        intAndDouBox.setContent(1, 3.14);
        System.out.println(intAndDouBox.getContent());
        System.out.println(intAndDouBox);
    }
}
```

## 1.3.泛型接口

```java
// 自定义泛型的接口
// 定义一个泛型接口
interface Pair<K, V> {
    K getKey();
    V getValue();
}

// 实现泛型接口的具体类
class OrderedPair<K, V> implements Pair<K, V> {
    private K key;
    private V value;

    public OrderedPair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    @Override
    public K getKey() {
        return key;
    }

    @Override
    public V getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "OrderedPair{" +
                "key=" + key +
                ", value=" + value +
                '}';
    }

    public static void main(String[] args) {
        OrderedPair<String, Integer> pair = new OrderedPair<>("One", 1);
        System.out.println(pair);
    }
}
```

1. **泛型接口 `Pair<K, V>`**：
    - `Pair` 接口有两个类型参数 `K` 和 `V`，分别表示键和值的类型。
    - 接口中定义了 `getKey()` 和 `getValue()` 方法，分别用于获取键和值。

2. **实现类 `OrderedPair<K, V>`**：
    - `OrderedPair` 类实现了 `Pair<K, V>` 接口，因此需要提供具体的类型参数。
    - 类中有两个私有字段 `key` 和 `value`，分别用来保存键和值。
    - 构造方法接收键和值作为参数，并将其赋值给相应的字段。
    - 实现了 `getKey()` 和 `getValue()` 方法来返回保存的键和值。
    - `toString()` 方法用于返回对象的字符串表示形式。

3. **使用泛型接口**：
    - 在 `main` 方法中，创建了一个 `OrderedPair` 类的实例，并指定了具体的类型参数 `<String, Integer>`。
    - 调用 `toString()` 方法打印出实例的内容。

这样，你就定义了一个泛型接口 `Pair` 和一个实现了该接口的具体类 `OrderedPair`。这种设计允许你在不同的上下文中使用相同的接口和实现，而无需针对每种类型都编写新的代码。

>   补充：需要注意的是，泛型的类型推导是在编译阶段中完成的，一旦编译为 `.class`，泛型就不存在了，也就是 **类型擦除**。

# 2.集合框架

## 2.1.框架的共性概述



## 2.2.框架的具体实现

### 数组



### 链表



### 队列

#### 普通队列

#### 双端队列

#### 优先队列



### 散列



### 树集



## 2.3.框架的映射视图



# 3.算法框架



# 4.遗留框架



---

>   结语：...