

**叠甲：以下文章主要是依靠我的实际编码学习中总结出来的经验之谈，求逻辑自洽，不能百分百保证正确，有错误、未定义、不合适的内容请尽情指出！**

[TOC]

>   概要：...

>   资料：...

---

# 1.线程创建

在 `Java` 的实现中，有三种方法做到多线程：

-   定义继承 `Thread{}` 的子类，并且覆盖 `run()`，该方法内部是线程需要做的事情，然后创建该子类的实例后调用 `start()`
-   实现 `Runnable` 接口，实现类需要实现内部的 `run()` 然后把该实现类的实例作为参数传递给 `Thread{}` 构造线程实例，使用线程实例的 `start()`
-   实现 `Callable<>` 接口，实现类需要实现内部的 `call()`，然后把该实现类的实例使用 `Callable<>` 引用，然后使用 `FutureTask<>` 继续封装为“未来任务”，实例化出新实例，交给 `Thread{}` 作为构造参数，然后使用对应的线程实例调用 `start()` 方法（这种方式最大的好处就是可以使用线程实例的 `get()` 获取返回值）

>   补充：一般推荐使用实现 `Runnable` 接口的方式来创建线程，因为这样更加灵活，可以避免 `Java` 单继承的限制，并且支持更好的资源共享和代码结构的清晰度。

```java
// 继承 Thread 类的子类
class MyThread extends Thread {
    private String message;

    // 构造方法, 接受需要传递的参数
    public MyThread(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        System.out.println("Thread is running with message: " + message);
        // 线程执行的逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建线程对象时传递参数
        String msg = "Hello, World!";
        MyThread thread = new MyThread(msg);
        thread.start();
    }
}
```

```java
// 实现 Runnable 接口的实现类
class MyRunnable implements Runnable {
    private String message;

    // 设置实例变量的方法
    public void setMessage(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        System.out.println("Runnable is running with message: " + message);
        // 线程执行的逻辑
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        String msg = "Hello, Runnable!";

        // 设置参数
        myRunnable.setMessage(msg);

        Thread thread = new Thread(myRunnable);
        thread.start();
    }
}
```

```java
// 实现 Callable 接口的实现类, 并且包装为 FutureTask
import java.util.concurrent.*;

// 实现 Callable 接口的类
class MyCallable implements Callable<String> {

    private int num;

    // 构造方法, 接收需要的参数
    public MyCallable(int num) {
        this.num = num;
    }

    // 实现 call() 定义线程执行的逻辑
    @Override
    public String call() {
        String sum = new String();
        for (int i = 1; i <= num; i++) {
            sum += i;
        }
        return sum;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        // 创建 Callable 对象
        Callable<String> callable = new MyCallable(10); // 使用接口对象引用实现类对象
        FutureTask<String> ft = new FutureTask<>(callable); // 然后使用 FutureTask 进行进一步封装为"将来任务"
        Thread t = new Thread(ft); // 创建线程
        t.start(); // 启动线程
        System.out.println("连接结果: " + ft.get()); // 获取线程执行结果
    }
}
```

然后我们开始看 `Thread` 的其他方法，我们使用第一种方式来演示。

```java
// 使用 Thread 的其他常见方法
// 继承 Thread 类的子类
class MyThread extends Thread {
    private String message;

    // 构造方法, 接受需要传递的参数
    public MyThread(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        System.out.println("线程得到的参数 " + message);

        // 打印线程名称
        System.out.println("线程名 " + this.getName());

        // 打印线程优先级
        System.out.println("线程优先级 " + this.getPriority());

        // 获取当前执行的线程对象
        System.out.println("当前正在执行的线程对象 " + Thread.currentThread());

        // 模拟线程工作
        for (int i = 0; i < 5; i++) {
            System.out.println(this.getName() + " - Count: " + i);
            try {
                Thread.sleep(1000); // 线程休眠 1 秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(this.getName() + " 线程完成执行");
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建线程对象时传递参数
        String msg = "Hello, World!";
        MyThread thread1 = new MyThread(msg);
        thread1.setName("MyThread-1"); // 设置线程名称
        thread1.setPriority(Thread.MAX_PRIORITY); // 设置线程优先级

        // 创建并启动另一个线程
        MyThread thread2 = new MyThread("Another Message");
        thread2.setName("MyThread-2"); // 设置线程名称
        thread2.setPriority(Thread.MIN_PRIORITY); // 设置线程优先级

        // 启动线程
        thread1.start();
        thread2.start();

        // 获取当前执行的线程对象
        System.out.println("当前正在执行的线程对象 " + Thread.currentThread());

        try {
            // 等待线程 1 完成
            thread1.join();
            System.out.println(thread1.getName() + " 已经完成回收");

            // 等待线程 2 完成
            thread2.join();
            System.out.println(thread2.getName() + " 已经完成回收");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 检查线程是否还在运行
        System.out.println(thread1.getName() + " 是否还在运行 " + thread1.isAlive());
        System.out.println(thread2.getName() + " 是否还在运行 " + thread2.isAlive());
    }
}
```

# 2.线程安全

## 2.1.同步代码块



## 2.2.同步方法



## 2.3.Lock 锁



# 3.线程通信



# 4.线程池化



---

>   结语：...